' Gambas class file

' Represents a poli line
' Element maintained by Terco

' Usando partes de la informacion de
' http://devmag.org.za/2011/04/05/bzier-curves-a-tutorial/

Create Static

Public Const Gender As String = "SPLine"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = "SPLine"
Public Const ParamType As String = "P+"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = ("Next Point")      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = "Close/Undo"
Public Const GAMBASCADENTITY As String = "EntityBase"
Public Const USEWITH As String = "clsEntityBuilder"
Public Const DrawingOrder As Integer = 0        ' 1 = draws first
Public Const OrthogonalIgnored As Boolean = False
Public Const OrthogonalForced As Boolean = False
Public Const StretchAble As Boolean = True           ' Si lo puedo deformar

' otras const
Public Const TypeControls As Integer = 0
Public Const TypeTangent As Integer = 1

Public Selected As Boolean

Public DrawAble As Boolean = False          ' True si durante la construccion ya tiene suficientes elementos para poder hacer una representacion digna
Public Visible As Boolean = True            ' si esta entidad puede ser mostrada independientmente
Public Finished As Boolean = False          ' colocar en true cuando se llegue a completar
Public StepsDone As Integer                 ' esto lo cambia cls ElementBuilder durante la construccion
Public drawingPoints As New Float[]

Public numDrawingPoints As Integer = 100

' JSON and DXF Read/Export
Public Const JSON_Reading As Boolean = True
Public Const JSON_Export As Boolean = False

Public Const DXF_Reading As Boolean = True
Public Const DXF_Export As Boolean = True

' fParam helpers
Public Const TotalParams As Integer = 10
Public Const ipaDegree As Integer = 0
Public Const ipaTotalKnots As Integer = 1
Public Const ipaTotalControlPoints As Integer = 2
Public Const ipaTotalFitPoints As Integer = 3
Public Const ipaKnotTolerance As Integer = 4
Public Const ipaControlTolerance As Integer = 5
Public Const ipaFitTolerance As Integer = 6
Public Const ipaFlag As Integer = 7
Public Const ipaTang1 As Integer = 8
Public Const ipaTang2 As Integer = 9

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

  Dim i As Integer

  If OnlySelected Then

    For i = 0 To e.Psel.Max
      If e.Psel[i] Then

        e.P[i * 2] += dx
        e.P[i * 2 + 1] += dy

      Endif
    Next

  Else

    puntos.Translate(e.p, dx, dy)
  Endif

End

Public Sub Rotate(e As Entity, radians As Float)

  puntos.Rotate(e.P, radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

  Dim i As Integer

  For i = 0 To e.p.max Step 2

    e.P[i] = e.P[i] * sX
    e.P[i + 1] = e.P[i + 1] * sY

  Next

End

Public Sub Draw(oE As Entity)

  If Not oE.Visible Then Return

  drawingPoints.Clear

  'oe.P.Clear
  'oe.P.Insert([10, 10, 70, 310, 210, 210, 210, 10])
  oE.ColorToPaint = gcd.GetGBColor(oE.colour, oE.Layerid)
  If oe.fParam.Count < Me.TotalParams Then oe.fParam.Resize(Me.TotalParams)
  oe.fParam[Me.ipaDegree] = 2
  ' La Spline de grado 2 es la que va a traves de Fit Points
  If oe.fParam[Me.ipaDegree] = 2 Then
    calculateDrawingPoints(oe.p)
    'SplineTroughFitPoints(oe.p)
  Else  ' a traves de control points (no los toca)

    'calculateDrawingPointsWithTangents2(oe.p, oe.fParam[me.ipaTang1] = 1, oe.fParam[me.ipaTang2] = 1)

    SplineTroughControlPoints(oe.p, oe.fParam[Me.ipaTang1] = 1, oe.fParam[Me.ipaTang2] = 1)
  Endif

  GLplus.PolyLines(drawingPoints, oE.ColorToPaint, oE.LineWidth, oe.linetype)

End

'' A fat version of the entity
Public Sub DrawSelected(oE As Entity)

  GLplus.PolyLines(oE.PolyLine, Starter.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
  GLplus.PolyLines(oE.PolyLine, gcd.ColorForSelected, oE.LineWidth, oE.LineType)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

  If Not oE.Visible Then Return

  '  GLplus.PolyLines(oE.p, Starter.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
  '  GLplus.PolyLines(oE.p, oE.ColorToPaint, oE.LineWidth + 2, oE.LineType)
  If oe.Selected Then
    GLplus.PolyLines(oE.PolyLine, Starter.flgWindowBackColor, oE.LineWidth + 2, gcd.stiDashed)
    GLplus.PolyLines(oE.PolyLine, gcd.ColorForSelected, oE.LineWidth + 2, oE.LineType)
  Else
    GLplus.PolyLines(oE.PolyLine, Starter.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
    GLplus.PolyLines(oE.PolyLine, oE.ColorToPaint, oE.LineWidth + 2, oE.LineType)
  Endif

End

Public Sub Draw2(oE As Entity)

End
'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity, Optional arrIndex As Integer = -1) As Integer

  cadLWPolyline.BuildPOI(oe)

End

' This function will return False if the element couldn't be created for some reason: bad or incomple user input
' True means all is good, False will instruct the clsEntityBuilder to delete it
Public Sub Finish(oE As Entity, Optional ParamsDone As Integer = -1) As Boolean

  'Print "Finish en EntityBase"
  'CreatePolygon(oe)
  BuildPOI(oe)

  ' busco el tipo de linea, si hace falta
  If oE.LineTypeName = "Dashed" Then oE.LineType = 1
  ' tareas finales de armado del objeto

  oE.psel.resize(oE.p.count / 2)

  oE.DrawAble = True
  oE.Selected = False
  oE.Finished = True

End

Public Function calculateDrawingPointsWithTangents(points As Float[])

  ' points es una copia de P

  ' En este caso, los Fit points no se proveeen, por lo que se calculan como el punto medio entre puntos de tangente

  Dim interval As Float = 1 / numDrawingPoints
  Dim t As Float = interval
  Dim i, segments, iPoints, sobran, i2, faltan As Integer
  Dim p0, p1, p2, p3 As New Float[]

  ' Tengo que ver cuantos puntos tengo, casos basicos
  If points.Count / 2 <= 2 Then ' es una recta

    drawingPoints.Insert(points.Copy())
    Return

  Else If points.Count / 2 = 3 Then
    ' es una curva quadratica
    ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
    ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 4, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return
  Else If points.Count / 2 = 4 Then

    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 6, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return

  Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda

    '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
    '    1  2  3  4  5    6    7    8    9   10
    '    F  T  nTangentes.............   T    F
    i = 0
    Do

      ' veo cuantos puntos me quedan
      If (i = 0) And (points.count - i >= 8) Then   ' primer tramo

        p0.Insert(points.Copy(i, 2))                ' PUNTO INICIAL
        p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
        p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE

        p3.Add((points[i + 6] + points[i + 4]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
        p3.Add((points[i + 7] + points[i + 5]) / 2)

        i += 4

      Else If points.count - i > 8 Then             ' tramos intermedios

        p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
        p0.Add((points[i + 1] + points[i + 3]) / 2)

        p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
        p2.Insert(points.Copy(i + 2, 2))            ' TANGENTE, igual al anterior

        p3.Add((points[i + 4] + points[i + 2]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
        p3.Add((points[i + 5] + points[i + 3]) / 2)

        i += 2

      Else If points.count - i = 8 Then             ' tramos intermedios

        p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
        p0.Add((points[i + 1] + points[i + 3]) / 2)

        p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE

        p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE, igual al anterior

        p3.Insert(points.Copy(i + 6, 2))            ' PUNTO FINAL,

        i += 6

      End If

      t = 0
      For iPoints = 0 To numDrawingPoints - 1

        drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
        t += interval
      Next

      p0.Clear
      p1.Clear
      p2.Clear
      p3.Clear

    Loop Until I = points.Count - 2
  End If

End

Public Function SplineTroughControlPoints(points As Float[], Tang1 As Boolean, Tang2 As Boolean)

  ' points es una copia de P

  ' En este caso, los Fit points no se proveeen, por lo que se calculan como el punto medio entre puntos de tangente

  Dim interval As Float = 1 / numDrawingPoints
  Dim t As Float = interval
  Dim i, segments, iPoints, sobran, i2, faltan As Integer
  Dim p0, p1, p2, p3 As New Float[]
  Dim fdis As Float

  ' Tengo que ver cuantos puntos tengo, casos basicos
  If points.Count / 2 <= 2 Then ' es una recta

    drawingPoints.Insert(points.Copy())
    Return

  Else If points.Count / 2 = 3 Then
    ' es una curva quadratica
    ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
    ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 4, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return
  Else If points.Count / 2 = 4 Then

    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 6, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return

  Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda

    '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
    '    1  2  3  4  5    6    7    8    9   10
    '    F  T  nTangentes.............   T    F
    i = 0
    Do

      ' veo cuantos puntos me quedan
      If i = 0 Then   ' primer tramo

        If tang1 Then ' la tangente es 01
          fdis = puntos.distancia(points[2], points[3], points[4], points[5])

          p0.Insert(points.Copy(2, 2))                ' PUNTO INICIAL

          p1.Add(p0[0] + fdis * points[0])            ' TANGENTE
          p1.Add(p0[1] + fdis * points[1])

          p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE

          p3.Add((points[i + 6] + points[i + 4]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
          p3.Add((points[i + 7] + points[i + 5]) / 2)

          i += 4

        Else

          p0.Insert(points.Copy(i, 2))     ' PUNTO INICIAL, se calcula

          p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
          p2.Insert(points.Copy(i + 2, 2))            ' TANGENTE, igual al anterior

          p3.Add((points[i + 4] + points[i + 2]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
          p3.Add((points[i + 5] + points[i + 3]) / 2)

          i += 2

        End If

      Else If points.count - i > 8 Then             ' tramos intermedios

        p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
        p0.Add((points[i + 1] + points[i + 3]) / 2)

        p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
        p2.Insert(points.Copy(i + 2, 2))            ' TANGENTE, igual al anterior

        p3.Add((points[i + 4] + points[i + 2]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
        p3.Add((points[i + 5] + points[i + 3]) / 2)

        i += 2

      Else If points.count - i = 8 Then             ' tramos final

        p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
        p0.Add((points[i + 1] + points[i + 3]) / 2)

        p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE

        p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE, igual al anterior

        p3.Insert(points.Copy(i + 6, 2))            ' PUNTO FINAL,

        i += 6

      End If

      t = 0
      For iPoints = 0 To numDrawingPoints - 1

        drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
        t += interval
      Next

      p0.Clear
      p1.Clear
      p2.Clear
      p3.Clear

    Loop Until I = points.Count - 2
  End If

End

Public Function SplineTroughFitPoints(points As Float[]) ' points es una copia de P

  Dim interval As Float = 1 / numDrawingPoints
  Dim t As Float = interval
  Dim i, segments, iPoints, sobran, i2, faltan As Integer
  Dim p0, p1, p2, p3 As New Float[]

  ' Tengo que ver cuantos puntos tengo, casos basicos
  If points.Count / 2 <= 2 Then ' es una recta

    drawingPoints.Insert(points.Copy())
    Return

  Else If points.Count / 2 = 3 Then
    ' es una curva quadratica
    ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
    ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
    p0.Insert(points.Copy(i, 2))                ' Fit point , la curva debe pasar por aca
    p1.Insert(points.Copy(i + 2, 2))            ' se calcula

    p2.Insert(points.Copy(i + 2, 2))            ' fit point
    p3.Insert(points.Copy(i + 4, 2))            ' tangente, el mouse esta aqui
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return
  Else If points.Count / 2 = 4 Then

    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 6, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return

  Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda
    ' La curva necesita  Fit-Control-Control-Fit
    ' Casos mas complejos
    ' A - Si tengo 4 puntos, tengo la curva cubica perfecta.
    ' B - Si tengo 5 puntos, estiro la curva moviendo el ultimo fit al ultimo control:
    '       Fit - Control - Control - Fit - > Control
    ' C - Si tengo 6 puntos, creo un Control q me de la misma tangente al 4to Fit, y agrego otro Fit en el ultimo Control:
    '       Fit0 - Control1 - Control2- Fit3- Control4 (creado, tang al 2) - Control5 (marcado) - Fit6 (creado = 5)

    ' el primer punto de control lo espejo del segmento anterior
    ' y lo inserto directamente en el array de los puntos
    ' pero en la anteultima posicion

    '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
    '    1  2  3  4  5    6    7    8    9   10

    For i = 0 To points.max Step 6
      If points.count - i >= 8 Then  ' caso A -> mando a dibujar
        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i + 2, 2))
        p2.Insert(points.Copy(i + 4, 2))
        p3.Insert(points.Copy(i + 6, 2))

      Else If points.count - i = 6 Then  ' caso B: Tengo Fit+Control+Control

        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i + 2, 2))
        p2.Insert(points.Copy(i + 2, 2))
        p3.Insert(points.Copy(i + 4, 2))

      Else If points.count - i = 4 Then  ' caso C: Tengo Fit+Control (nuevo)

        '   01 23 45 67 89  Max = 9 Count=10
        '    1  2  3  4  5
        '    F  C  C  F  C

        ' duplico el ultimo Control point
        points.Add(0)
        points.Add(0)
        points[points.max - 1] = points[points.max - 3]
        points[points.max] = points[points.max - 2]

        ' tengo q engañar a clsEntityBuilder
        'clsEntityBuilder.iPoints = points.Count / 2
        clsEntityBuilder.MoveOn()

        '   01 23 45 67 89 1011 Max = 11 Count=12
        '    1  2  3  4  5    6
        '    F  C  C  F  C    C
        '          ^-----|
        ' el control point agregado es correlativo al de la curva anterior
        points[points.max - 3] = 2 * points[points.max - 5] - points[points.Max - 7]
        points[points.max - 2] = 2 * points[points.max - 4] - points[points.Max - 6]

        ' ahora la tomo como un tipo B

        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i + 2, 2))
        p2.Insert(points.Copy(i + 4, 2))
        p3.Insert(points.Copy(i + 4, 2))

      Else If points.count - i = 2 Then  ' no hay nada q dibujar
        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i, 2))
        p2.Insert(points.Copy(i, 2))
        p3.Insert(points.Copy(i, 2))

      End If

      t = 0
      For iPoints = 0 To numDrawingPoints - 1

        drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
        t += interval
      Next

      p0.Clear
      p1.Clear
      p2.Clear
      p3.Clear

    Next
  End If

End

Public Function calculateDrawingPoints(points As Float[]) ' points es una copia de P

  Dim interval As Float = 1 / numDrawingPoints
  Dim t As Float = interval
  Dim i, segments, iPoints, sobran, i2, faltan As Integer
  Dim p0, p1, p2, p3 As New Float[]

  ' Tengo que ver cuantos puntos tengo, casos basicos
  If points.Count / 2 <= 2 Then ' es una recta

    drawingPoints.Insert(points.Copy())
    Return

  Else If points.Count / 2 = 3 Then
    ' es una curva quadratica
    ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
    ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 4, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return
  Else If points.Count / 2 = 4 Then

    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 6, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return

  Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda
    ' La curva necesita  Fit-Control-Control-Fit
    ' Casos mas complejos
    ' A - Si tengo 4 puntos, tengo la curva cubica perfecta.
    ' B - Si tengo 5 puntos, estiro la curva moviendo el ultimo fit al ultimo control:
    '       Fit - Control - Control - Fit - > Control
    ' C - Si tengo 6 puntos, creo un Control q me de la misma tangente al 4to Fit, y agrego otro Fit en el ultimo Control:
    '       Fit0 - Control1 - Control2- Fit3- Control4 (creado, tang al 2) - Control5 (marcado) - Fit6 (creado = 5)

    ' el primer punto de control lo espejo del segmento anterior
    ' y lo inserto directamente en el array de los puntos
    ' pero en la anteultima posicion

    '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
    '    1  2  3  4  5    6    7    8    9   10

    For i = 0 To points.max Step 6
      If points.count - i >= 8 Then  ' caso A -> mando a dibujar
        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i + 2, 2))
        p2.Insert(points.Copy(i + 4, 2))
        p3.Insert(points.Copy(i + 6, 2))

      Else If points.count - i = 6 Then  ' caso B: Tengo Fit+Control+Control

        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i + 2, 2))
        p2.Insert(points.Copy(i + 4, 2))
        p3.Insert(points.Copy(i + 4, 2))

      Else If points.count - i = 4 Then  ' caso C: Tengo Fit+Control (nuevo)

        '   01 23 45 67 89  Max = 9 Count=10
        '    1  2  3  4  5
        '    F  C  C  F  C

        ' duplico el ultimo Control point
        points.Add(0)
        points.Add(0)
        points[points.max - 1] = points[points.max - 3]
        points[points.max] = points[points.max - 2]

        ' tengo q engañar a clsEntityBuilder
        'clsEntityBuilder.iPoints = points.Count / 2
        clsEntityBuilder.MoveOn()

        '   01 23 45 67 89 1011 Max = 11 Count=12
        '    1  2  3  4  5    6
        '    F  C  C  F  C    C
        '          ^-----|
        ' el control point agregado es correlativo al de la curva anterior
        points[points.max - 3] = 2 * points[points.max - 5] - points[points.Max - 7]
        points[points.max - 2] = 2 * points[points.max - 4] - points[points.Max - 6]

        ' ahora la tomo como un tipo B

        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i + 2, 2))
        p2.Insert(points.Copy(i + 4, 2))
        p3.Insert(points.Copy(i + 4, 2))

      Else If points.count - i = 2 Then  ' no hay nada q dibujar
        p0.Insert(points.Copy(i, 2))
        p1.Insert(points.Copy(i, 2))
        p2.Insert(points.Copy(i, 2))
        p3.Insert(points.Copy(i, 2))

      End If

      t = 0
      For iPoints = 0 To numDrawingPoints - 1

        drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
        t += interval
      Next

      p0.Clear
      p1.Clear
      p2.Clear
      p3.Clear

    Next
  End If

End

'=======================================================================================================
' Nuevo metodo
'=======================================================================================================

'' Calculates a point in a Cubic Bezier curve
'' if P1=P2 this turn into a Quadratic curve
Public Function CalculateBezierPoint2D(t As Float, p0 As Float[], p1 As Float[], p2 As Float[], p3 As Float[]) As Float[]

  Dim u As Float = 1 - t    ' t va de 0 a 1
  Dim tt As Float = t * t
  Dim uu As Float = u * u
  Dim uuu As Float = uu * u
  Dim ttt As Float = tt * t
  Dim pr As New Float[]

  pr.Insert([0, 0])

  pr[0] = uuu * p0[0]            ' first term
  pr[0] += 3 * uu * t * p1[0]    ' second term
  pr[0] += 3 * u * tt * p2[0]    ' third term
  pr[0] += ttt * p3[0]           ' fourth term

  pr[1] = uuu * p0[1]            ' first term
  pr[1] += 3 * uu * t * p1[1]    ' second term
  pr[1] += 3 * u * tt * p2[1]    ' third term
  pr[1] += ttt * p3[1]           ' fourth term

  ' para 3D agregar [2]

  Return pr

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  Dim i, iFinal As Integer
  Dim fTangLargo As Float
  Dim fControlPoints As New Float[]
  Dim fFitPoint As New Float[]

  If c.Exist("ctrl_pts") Then

    e.fParam.Add(Me.TypeControls)
    For i = 0 To c["ctrl_pts"].Max
      e.P.Add(c["ctrl_pts"][i]["x"])
      e.P.Add(c["ctrl_pts"][i]["y"])
    Next
  End If

  If c.Exist("fit_pts") Then

    e.fParam.Add(Me.TypeTangent)
    For i = 0 To c["fit_pts"].Max
      e.P.Add(c["fit_pts"][i][0])
      e.P.Add(c["fit_pts"][i][1])
    Next
    ' fabrico control points ente fit_points

    ' i = 2
    ' Do
    '
    '   fControlPoints.Add((e.P[i] + e.P[i + 2]) / 2)
    '   fControlPoints.Add((e.P[i + 1] + e.P[i + 3]) / 2)
    '   fFitPoint.Add(e.P[i + 2])
    '   fFitPoint.Add(e.P[i + 3])
    '   e.P.insert(fControlPoints, i + 2)
    '   e.P.Insert(fFitPoint, i + 4)
    '   fControlPoints.Clear
    '   fFitPoint.Clear
    '   i = i + 6
    ' Loop Until i > iFinal
    '
    '
    If c.Exist("beg_tan_vec") Then
      fTangLargo = puntos.distancia(e.P[0], e.P[1], e.P[2], e.P[3]) / 2
      'fTangLargo = 1
      e.P.Insert([e.P[0] + c["beg_tan_vec"][0] * fTangLargo, e.P[1] + c["beg_tan_vec"][1] * fTangLargo], 2)

    Endif

    If c.Exist("end_tan_vec") Then
      fTangLargo = puntos.distancia(e.P[e.P.Max - 3], e.P[e.P.Max - 2], e.P[e.P.Max - 1], e.P[e.P.Max]) / 2
      'fTangLargo = 1
      e.P.Insert([e.P[e.P.Max - 1] - c["end_tan_vec"][0] * fTangLargo, e.P[e.P.Max] - c["end_tan_vec"][1] * fTangLargo], e.P.max - 1)

    Endif

  End If

  ' puede habre tangentes

  If e.P.Count = 0 Then e.P.Insert([0, 0, 0, 0, 0, 0, 0, 0])

  Return True

End

'      "entity": "SPLINE",
'      "index": 3357,
'      "type": 36,
'      "handle": [0, 1249847],
'      "size": 418,
'      "bitsize": 3284,
'      "ownerhandle": [12, 1, 2, 1249845],
'      "_subclass": "AcDbEntity",
'      "prev_entity": [4, 0, 0, 0],
'      "next_entity": [6, 0, 0, 1249848],
'      "layer": [5, 1, 16, 16],
'      "preview_exists": 0,
'      "entmode": 0,
'      "nolinks": 0,
'      "color": 256,
'      "ltype_scale": 1.0,
'      "ltype_flags": 0,
'      "plotstyle_flags": 0,
'      "invisible": 0,
'      "linewt": 29,
'      "_subclass": "AcDbSpline",
'      "scenario": 1,
'      "degree": 3,
'      "rational": 0,
'      "closed_b": 0,
'      "periodic": 0,
'      "knot_tol": 0.0000000001,
'      "ctrl_tol": 0.0000000001,
'      "weighted": 0,
'      "knots": [
'        0.00000000000000,
'        0.00000000000000,
'        0.00000000000000,
'        0.00000000000000,
'        0.11913126411571,
'        0.23975678553509,
'        0.49083550137789,
'        1.04447328364244,
'        1.44003107270299,
'        1.55491017607702,
'        1.92016945852300,
'        2.22324540117473,
'        2.48758013168516,
'        2.82200084095037,
'        3.00883554387170,
'        3.16218973969312,
'        3.16218973969312,
'        3.16218973969312,
'        3.16218973969312
'      ],
'      "ctrl_pts": [
'        {
'          "x": -0.21323049241494,
'          "y": 0.84482240616663,
'          "z": 0.0
'        },
'        {
'          "x": -0.1847166715454,
'          "y": 0.87190801033913,
'          "z": 0.0
'        },
'        {
'          "x": -0.1228526953775,
'          "y": 0.922359536827,
'          "z": 0.0
'        },
'        {
'          "x": 0.02043360444333,
'          "y": 1.00035857198183,
'          "z": 0.0
'        },
'        {
'          "x": 0.27257295630051,
'          "y": 1.1752608208499,
'          "z": 0.0
'        },
'        {
'          "x": 0.61052372379078,
'          "y": 1.38248143619054,
'          "z": 0.0
'        },
'        {
'          "x": 0.92880308857434,
'          "y": 1.54637696665506,
'          "z": 0.0
'        },
'        {
'          "x": 1.21565315275478,
'          "y": 1.6043944582336,
'          "z": 0.0
'        },
'        {
'          "x": 1.47769680033207,
'          "y": 1.61054542981341,
'          "z": 0.0
'        },
'        {
'          "x": 1.78840999609696,
'          "y": 1.61736294507911,
'          "z": 0.0
'        },
'        {
'          "x": 2.08859470791577,
'          "y": 1.60619051383182,
'          "z": 0.0
'        },
'        {
'          "x": 2.35172325891301,
'          "y": 1.59913454504708,
'          "z": 0.0
'        },
'        {
'          "x": 2.57162173748583,
'          "y": 1.55677519634268,
'          "z": 0.0
'        },
'        {
'          "x": 2.68480471484867,
'          "y": 1.53475995596965,
'          "z": 0.0
'        },
'        {
'          "x": 2.73031030857453,
'          "y": 1.51193841889326,
'          "z": 0.0
'        }
'      ]

Public Sub ExportDXF(e As Entity, hFile As File)

  Dim i As Integer

  Print #hFIle, "  0"                       ' Entity type
  Print #hFIle, "SPLINE"
  clsEntities.DXFExportCommon(e, hFile)
  Print #hFIle, "100"                     ' Subclass marker
  Print #hFIle, "AcDbSpline"
  Print #hFIle, "210"                     ' vector normal
  Print #hFIle, "  0"
  Print #hFIle, "220"
  Print #hFIle, "  0"
  Print #hFIle, "230"
  Print #hFIle, "  0"
  Print #hFIle, " 70"                      ' Spline flag (bit coded):1 = Closed spline 2 = Periodic spline 4 = Rational spline 8 = Planar 16 = Linear(planar bit Is Also set)
  Print #hFIle, e.fParam[Me.ipaFlag]
  Print #hFIle, " 71"                      ' grado de la ecuacion
  Print #hFIle, e.fParam[Me.ipaDegree]
  Print #hFIle, " 72"                      ' cantidad de nudos
  Print #hFIle, e.fParam[Me.ipaTotalKnots]
  Print #hFIle, " 73"                      ' cantidad de puntos de control ?????????????
  Print #hFIle, e.fParam[Me.ipaTotalControlPoints]
  Print #hFIle, " 74"                      ' cantidad de fit points
  Print #hFIle, e.fParam[Me.ipaTotalFitPoints]
  Print #hFIle, " 42"                      ' Knot tolerance (default = 0.0000001)
  Print #hFIle, e.fParam[Me.ipaKnotTolerance]
  Print #hFIle, " 43"                      ' Control-point tolerance (default = 0.0000001)
  Print #hFIle, e.fParam[Me.ipaControlTolerance]
  Print #hFIle, " 44"                      ' Fit tolerance (default = 0.0000000001)
  Print #hFIle, e.fParam[Me.ipaFitTolerance]
  For i = 0 To e.p.Max Step 2
    Print #hFIle, "40"                      ' Knot value ???
    Print #hFIle, "0"
  Next
  For i = 0 To e.p.Max Step 2
    Print #hFIle, " 10"                      ' Xi
    Print #hFIle, CStr(e.p[i])
    Print #hFIle, " 20"                      ' Yi
    Print #hFIle, CStr(e.p[i + 1])
    Print #hFIle, " 30"                      ' Zi
    Print #hFIle, "  0"

  Next

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

  Dim i As Integer
  Dim Pbase As New Float[]
  Dim Ptang1 As New Float[]
  Dim Ptang2 As New Float[]

  e.fParam.Resize(Me.TotalParams)

  For i = 0 To sClaves.Max

    If sClaves[i] = "70" Then e.fParam[Me.ipaFlag] = CInt(sValues[i])
    If sClaves[i] = "71" Then e.fParam[Me.ipaDegree] = CInt(sValues[i])
    If sClaves[i] = "72" Then e.fParam[Me.ipaTotalKnots] = CInt(sValues[i])
    If sClaves[i] = "73" Then e.fParam[Me.ipaTotalControlPoints] = CInt(sValues[i])
    If sClaves[i] = "74" Then e.fParam[Me.ipaTotalFitPoints] = CInt(sValues[i])
    If sClaves[i] = "42" Then e.fParam[Me.ipaKnotTolerance] = CFloat(sValues[i])
    If sClaves[i] = "43" Then e.fParam[Me.ipaControlTolerance] = CFloat(sValues[i])
    If sClaves[i] = "44" Then e.fParam[Me.ipaFitTolerance] = CFloat(sValues[i])

    If sClaves[i] = "40" Then e.fParam.Add(CFloat(sValues[i]))

    ' por lo general hay fit points o controls points, pero no ambos, cargo lo que sea en P
    If sClaves[i] = "10" Then Pbase.Add(CFloat(sValues[i]))
    If sClaves[i] = "20" Then Pbase.Add(CFloat(sValues[i]))
    If sClaves[i] = "11" Then Pbase.Add(CFloat(sValues[i]))
    If sClaves[i] = "21" Then Pbase.Add(CFloat(sValues[i]))

    ' tangentes
    If sClaves[i] = "12" Then Ptang1.Add(CFloat(sValues[i]))
    If sClaves[i] = "22" Then Ptang1.Add(CFloat(sValues[i]))

    If sClaves[i] = "13" Then Ptang2.Add(CFloat(sValues[i]))
    If sClaves[i] = "23" Then Ptang2.Add(CFloat(sValues[i]))

  Next

  ' con todos los datos recabados, armo el array

  If Ptang1.Count > 0 Then
    e.fParam[Me.ipaTang1] = 1
    e.P.Add(Ptang1[0])
    e.P.Add(Ptang1[1])
  End If
  e.P.Insert(Pbase.Copy(), e.P.Max)

  If Ptang2.Count > 0 Then

    e.fParam[Me.ipaTang2] = 1
    e.P.Add(Ptang2[0])
    e.P.Add(Ptang2[1])
  End If

  ' If e.fParam.Count = 0 Then e.fParam.Add(0)
  ' If e.fParam[0] = 1 And e.p.Count > 0 Then ' agrego el primer punto de nuevo
  '   e.p.Add(e.p[0])
  '   e.p.Add(e.p[1])
  ' End IfPtang

End
