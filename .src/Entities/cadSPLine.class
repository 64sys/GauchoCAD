' Gambas class file

' Represents a poli line
' Element maintained by Terco

' Usando partes de la informacion de
' http://devmag.org.za/2011/04/05/bzier-curves-a-tutorial/

Create Static

Public Const Gender As String = "SPLine"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = "SPLine"
Public Const ParamType As String = "P+"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = ("Next Point")      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = "Close/Undo"
Public Const GAMBASCADENTITY As String = "EntityBase"
Public Const USEWITH As String = "clsEntityBuilder"
Public Const DrawingOrder As Integer = 0        ' 1 = draws first
Public Const OrthogonalIgnored As Boolean = False
Public Const OrthogonalForced As Boolean = False
Public Const StretchAble As Boolean = True           ' Si lo puedo deformar
Public Selected As Boolean
Public ForDeletion As Boolean = True        ' this must be falsed in Finish
Public DrawAble As Boolean = False          ' True si durante la construccion ya tiene suficientes elementos para poder hacer una representacion digna
Public Visible As Boolean = True            ' si esta entidad puede ser mostrada independientmente
Public Finished As Boolean = False          ' colocar en true cuando se llegue a completar
Public StepsDone As Integer                 ' esto lo cambia cls ElementBuilder durante la construccion
Public drawingPoints As New Float[]

Public numDrawingPoints As Integer = 100

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

  Dim i As Integer

  If OnlySelected Then

    For i = 0 To e.Psel.Max
      If e.Psel[i] Then

        e.P[i * 2] += dx
        e.P[i * 2 + 1] += dy

      Endif
    Next

  Else

    puntos.Translate(e.p, dx, dy)
  Endif

End

Public Sub Rotate(e As Entity, radians As Float)

  puntos.Rotate(e.P, radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

  Dim i As Integer

  For i = 0 To e.p.max Step 2

    e.P[i] = e.P[i] * sX
    e.P[i + 1] = e.P[i + 1] * sY

  Next

End

Public Sub Draw(oE As Entity)

  If Not oE.Visible Then Return

  drawingPoints.Clear

  'oe.P.Clear
  'oe.P.Insert([10, 10, 70, 310, 210, 210, 210, 10])
  oE.ColorToPaint = gcd.GetGBColor(oE.colour, oE.Layerid)
  calculateDrawingPoints(oe.p)
  GLplus.PolyLines(drawingPoints, oE.ColorToPaint, oE.LineWidth, oe.linetype)

End

'' A fat version of the entity
Public Sub DrawSelected(oE As Entity)

  GLplus.PolyLines(oE.PolyLine, Starter.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
  GLplus.PolyLines(oE.PolyLine, gcd.ColorForSelected, oE.LineWidth, oE.LineType)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

  If Not oE.Visible Then Return

  '  GLplus.PolyLines(oE.p, Starter.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
  '  GLplus.PolyLines(oE.p, oE.ColorToPaint, oE.LineWidth + 2, oE.LineType)
  If oe.Selected Then
    GLplus.PolyLines(oE.PolyLine, Starter.flgWindowBackColor, oE.LineWidth + 2, gcd.stiDashed)
    GLplus.PolyLines(oE.PolyLine, gcd.ColorForSelected, oE.LineWidth + 2, oE.LineType)
  Else
    GLplus.PolyLines(oE.PolyLine, Starter.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
    GLplus.PolyLines(oE.PolyLine, oE.ColorToPaint, oE.LineWidth + 2, oE.LineType)
  Endif

End

Public Sub Draw2(oE As Entity)

  ' FIXME: requiere reparacion -> OpenGL
  Return

  If Not oE.Visible Then Return

  Dim i As Integer

  paint.LineWidth = oE.LineWidth / gcd.CurrentDrawing.ScaleZoom / gcd.ScaleLines

  If oE.Selected And Not gcd.ToolActive Then
    paint.brush = Paint.Color(gcd.ColorForSelected)
  Else
    paint.brush = Paint.Color(oE.ColorToPaint)
  Endif

  If Me.StepsDone = 1 Then
    paint.moveto(oE.p[0], oE.p[1])
    paint.lineto(oE.p[2], oE.p[3])

  Else If Me.StepsDone = 2 Then
    paint.moveto(oE.p[0], oE.p[1])
    paint.lineto(oE.p[2], oE.p[3])
    paint.lineto(oE.p[4], oE.p[5])

  Else If Me.StepsDone >= 3 Then 'If oE.P.Count / 2 < 5 Then
    paint.moveto(oE.p[0], oE.p[1])
    paint.curveto(oE.p[2], oE.p[3], oE.p[4], oE.p[5], oE.p[6], oE.p[7])
    '
    ' Else
    '
    '     'For i = 2 To oE.P.Max - 6 Step 2
    '         paint.moveto(oE.p[i], oE.p[i + 1])
    '         paint.curveto(oE.p[i + 2], oE.p[i + 3], oE.p[i + 4], oE.p[i + 5], oE.p[i + 6], oE.p[i + 7])
    '
    '     'Next
  End If

  '
  paint.Stroke

End
'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity, Optional arrIndex As Integer = -1) As Integer

  cadPLine.BuildPOI(oe)

End

' This function will return False if the element couldn't be created for some reason: bad or incomple user input
' True means all is good, False will instruct the clsEntityBuilder to delete it
Public Sub Finish(oE As Entity, Optional ParamsDone As Integer = -1) As Boolean

  'Print "Finish en EntityBase"
  'CreatePolygon(oe)
  BuildPOI(oe)

  ' busco el tipo de linea, si hace falta
  If oE.LineTypeName = "Dashed" Then oE.LineType = 1
  ' tareas finales de armado del objeto

  oE.psel.resize(oE.p.count / 2)
  oE.ForDeletion = False
  oE.DrawAble = True
  oE.Selected = False
  oE.Finished = True

  If Not True Then

    oE.ForDeletion = True
    oE.DrawAble = False

  End If

End

Public Function calculateDrawingPoints(points As Float[]) ' points es una copia de P

  Dim interval As Float = 1 / numDrawingPoints
  Dim t As Float = interval
  Dim i, segments, iPoints, sobran, i2, faltan As Integer
  Dim p0, p1, p2, p3 As New Float[]

  ' Tengo que ver cuantos puntos tengo, casos basicos
  If points.Count / 2 <= 2 Then ' es una recta

    drawingPoints.Insert(points.Copy())
    Return

  Else If points.Count / 2 = 3 Then
    ' es una curva quadratica
    ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
    ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
    p0.Insert(points.Copy(i, 2))
    p1.Insert(points.Copy(i + 2, 2))
    p2.Insert(points.Copy(i + 4, 2))
    p3.Insert(points.Copy(i + 4, 2))
    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
    Return

  Else
    i2 = points.Count Mod 8
    If i2 / 2 = 1 Then

      ' La curva necesita  Fit-Control-Control-Fit
      ' Casos mas complejos
      ' A - Si tengo 4 puntos, tengo la curva cubica perfecta.
      ' B - Si tengo 5 puntos, estiro la curva moviendo el ultimo fit al ultimo control:
      '       Fit - Control - Control - Fit - > Control
      ' C - Si tengo 6 puntos, creo un Control q me de la misma tangente al 4to Fit, y agrego otro Fit en el ultimo Control:
      '       Fit0 - Control1 - Control2- Fit3- Control4 (creado, tang al 2) - Control5 (marcado) - Fit6 (creado = 5)

      ' el primer punto de control lo espejo del segmento anterior
      ' y lo inserto directamente en el array de los puntos
      ' pero en la anteultima posicion
      '   0123456789  Max = 9
      '    1 2 3 4 5

      p1.add(points[points.Max - 3] + points[points.Max - 3] - points[points.Max - 5])
      p1.add(points[points.Max - 2] + points[points.Max - 2] - points[points.Max - 4])
      points.Insert(p1.Copy(), points.Max - 1)
      p1.Clear

    End If
  End If

  For i = 0 To points.count - 8 Step 6

    If points.count - i - 8 = 0 Then  ' caso A -> mando a dibujar
      p0.Insert(points.Copy(i, 2))
      p1.Insert(points.Copy(i + 2, 2))
      p2.Insert(points.Copy(i + 4, 2))
      p3.Insert(points.Copy(i + 6, 2))

    Else If points.max - i = 6 Then  ' caso B

      p0.Insert(points.Copy(i, 2))
      p1.Insert(points.Copy(i + 2, 2))
      p2.Insert(points.Copy(i + 4, 2))
      p3.Insert(points.Copy(i + 4, 2))

    End If

    For iPoints = 0 To numDrawingPoints - 1
      drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
      t += interval
    Next
  Next

End

' Public Function calculateDrawingPoints(points As Float[]) ' points es una copia de P
'
'   Dim interval As Float = 1 / numDrawingPoints
'   Dim t As Float = interval
'   Dim i As Integer
'
'   ' Tengo que ver cuantos puntos tengo, casos basicos
'   If points.Count / 2 = 2 Then ' es una recta
'
'     drawingPoints.Insert(points.Copy())
'     Return
'
'   Else If points.Count / 2 = 3 Then
'     ' es una curva quadratica
'     ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
'     ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
'     points.Insert([points[2], points[3]], 2)
'
'   End If
'
'   If points.Count / 2 > 3 Then
'
'     drawingPoints.insert(calculateNewPoint(points, 0))
'     For i = 0 To numDrawingPoints - 1
'       drawingPoints.insert(calculateNewPoint(points, t))
'       t += interval
'     Next
'   End If
'
' End
'

Public Function calculateNewPoint(points As Float[], t As Float) As Float[]
  ' Coordinates calculated using the general formula are relative To
  ' origin at bottom left.

  Dim x As Float = 0
  Dim y As Float = 0
  Dim n As Integer = points.Count / 2 - 1
  Dim i As Integer
  Dim bin As Float

  For i = 0 To n
    bin = C(n, i) * (1 - t) ^ (n - i) * t ^ i
    Debug i, bin

    x += bin * points[i * 2]
    y += bin * points[i * 2 + 1]
  Next
  Return [x, y]

End

Public Function C(n As Integer, k As Integer) As Float

  Dim coeff As Float = 1
  Dim x As Float

  For x = n - k + 1 To n
    coeff *= x

  Next
  For x = 1 To k
    coeff /= x
  Next

  'Debug coeff
  Return coeff

End

'=======================================================================================================
' Nuevo metodo
'=======================================================================================================

Public Function CalculateBezierPoint2D(t As Float, p0 As Float[], p1 As Float[], p2 As Float[], p3 As Float[]) As Float[]

  Dim u As Float = 1 - t    ' t va de 0 a 1
  Dim tt As Float = t * t
  Dim uu As Float = u * u
  Dim uuu As Float = uu * u
  Dim ttt As Float = tt * t
  Dim pr As New Float[]

  pr.Insert([0, 0])

  pr[0] = uuu * p0[0]            ' first term
  pr[0] += 3 * uu * t * p1[0]    ' second term
  pr[0] += 3 * u * tt * p2[0]    ' third term
  pr[0] += ttt * p3[0]           ' fourth term

  pr[1] = uuu * p0[1]            ' first term
  pr[1] += 3 * uu * t * p1[1]    ' second term
  pr[1] += 3 * u * tt * p2[1]    ' third term
  pr[1] += ttt * p3[1]           ' fourth term

  ' para 3D agregar [2]

  Return pr

End
