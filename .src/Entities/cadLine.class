' Gambas class file

' Element maintained by Terco
' V3
Inherits EntityBase
Public Const GENDER As String = "Line"
Public Const DrawingOrder As Integer = 1        ' 1 = draws first
Public Const HelperTrabajo As String = ("a line")
Public Const ParamType As String = "PP"                             ' that is Point, Point; could be Color Text, etc
Public Const ParamHelper As String = "Start point;End point"

Public Sub Draw()

    If Not Me.DrawAble Or Not Me.Visible Then Return
    
    If Me.Selected And Not modCAD.ToolActive Then Me.ColorToPaint = modCAD.ColorForSelected Else Me.ColorToPaint = Me.gbColor
    
    If modCAD.drwDrawingClass = modCAD.drwPaintClass Then
        
            paint.LineWidth = Me.LineWidth / appmain.hFcad.ScaleZoom / modCAD.ScaleLines 
            If Me.flxDash Then paint.Dash = Me.flxDash
            paint.brush = Paint.Color(Me.gbColor)
            paint.MoveTo(Me.p[0], Me.p[1])
            paint.LineTo(Me.p[2], Me.p[3])
            paint.Stroke
    End If        
    
    If modCAD.drwDrawingClass = modCAD.drwOpenGLClass Then
            
            GLplus.Lines(Me.p, Me.ColorToPaint, Me.LineWidth)
            

    Endif

End

'' Se fija si la posicion indicada esta aproximadamente sobre la entidad, de acuerdo a la tolerancia
'' mode es para establecer si se busca especificamente algun punto y devolver su posicion y tipo.
'' Mode: 
''      0 No busca nada en particular = Nearest
''      1       Endpoint
''      2       Midpoint
''      4       Perpendicular
''      8       Perpendicular
''      16      Perpendicular
''      32      Perpendicular
''      64      Perpendicular
''      128     Perpendicular
''      256     Perpendicular
'' Devuelve [x,y] punto de interes
Public Function AboveMe(Xreal As Float, Yreal As Float, tolerance As Float, mode As Integer, returnData As Float[]) As Boolean
    ' si una de las dos lineas de una cruz con centro en X,Y y largo Tolerance cruza la linea, estamos arriba
    Dim fInt As New Float[]
    
    If puntos.doIntersect(xreal - tolerance / 2, Yreal, Xreal + tolerance / 2, Yreal, Me.P[0], Me.P[1], Me.P[2], Me.P[3]) Then
        returnData.Clear
        ' busco el punto exacto en la linea donde se produce la interseccion
        fInt.Insert(puntos.lineLineIntersection([xreal - tolerance / 2, Yreal], [Xreal + tolerance / 2, Yreal], [Me.P[0], Me.P[1]], [Me.P[2], Me.P[3]]))
        returnData.Insert(fInt)
        Return True
        
    Endif
    
    
    If puntos.doIntersect(xreal, Yreal - tolerance / 2, Xreal, Yreal + tolerance / 2, Me.P[0], Me.P[1], Me.P[2], Me.P[3]) Then
        returnData.Clear
        ' busco el punto exacto en la linea donde se produce la interseccion
        fInt.Insert(puntos.lineLineIntersection([xreal, Yreal - tolerance / 2], [Xreal, Yreal + tolerance / 2], [Me.P[0], Me.P[1]], [Me.P[2], Me.P[3]]))
        returnData.Insert(fInt)
        Return True
        
        
        
    Endif
    
    Return False
    
End




'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI() As Integer

    Me.MyPoi.Clear
    ' P1
    Me.MyPoi.Insert([Me.p[0], Me.p[1]])

    ' P2
    Me.MyPoi.Insert([Me.p[2], Me.p[3]])
    
    ' MID
    Me.MyPoi.Insert([(Me.p[2] + Me.p[0]) / 2, (Me.p[3] + Me.p[1]) / 2])
    
    Return Me.MyPoi.Count / 2            ' marcamos 3 puntos para esta entidad
    
    
End
