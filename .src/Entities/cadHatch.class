' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
' Fast
'Inherits ToolsBase
Public Const Gender As String = "Hatch"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Hatch")
Public Const ParamType As String = "PTF"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = "Point;Texture;Scale"      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = " ;Concrete;1"
Public Const USEWITH As String = "cadHatchBuilder"
Public Const DrawingOrder As Integer = 0        ' 1 = draws first
Public Const OrthogonalIgnored As Boolean = False
Public Const OrthogonalForced As Boolean = False
Public Const StretchAble As Boolean = True           ' Si lo puedo deformar
Public Selected As Boolean

Public DrawAble As Boolean = False          ' True si durante la construccion ya tiene suficientes elementos para poder hacer una representacion digna
Public Visible As Boolean = True            ' si esta entidad puede ser mostrada independientmente
Public Finished As Boolean = False          ' colocar en true cuando se llegue a completar
Public StepsDone As Integer                 ' esto lo cambia cls ElementBuilder durante la construccion

' DXF Read/Export

Public Const DXF_Reading As Boolean = True
Public Const DXF_Export As Boolean = False

' fParam helpers
Public Const TotalParams As Integer = 10
Public Const ipaSolid As Integer = 0
Public Const ipaAsociativity As Integer = 1
Public Const ipaTotalLoops As Integer = 2
Public Const ipaRotation As Integer = 3
Public Const ipaScale As Integer = 4
Public Const ipaParity As Integer = 5
Public Const ipaPatternType As Integer = 6
Public Const ipaBoundaryType As Integer = 7 ' 0=lwpolyine, 1=lines, 2=circular arc, 3=ellipse arc, 4=spline

' stringdata helpers
Public Const sdaTotalParams As Integer = 2
Public Const sdaPattern As Integer = 0
Public Const sdaPaternFile As Integer = 1

'' Creates a new Hatch entity and prepares arrays

Public Function NewEntity() As Entity

  Dim e As New Entity

  e.Gender = Me.Gender
  e.ClassHandler = Me
  e.fParam.Insert([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
  e.P.Insert([0, 0])
  e.StringData.Insert(["", ""])

  ' this may fails on some scopes, but we should Try
  Try e.pLayer = gcd.CurrentDrawing.CurrLayer
  Try e.colour = gcd.CurrentDrawing.CurrColor
  Try e.LineType = gcd.CurrentDrawing.CurrLineType
  Try e.LineWidth = gcd.CurrentDrawing.CurrLineWt

  Return e

End

' Parametros de la entidad:

' P[]:        son los puntos de la polilinea que define el contorno del sombreado
' fParam[0]:  escala del sombreado
' fParam[1]:  angulo
' StringData[0]: nombre del patron del sombreado

Public Sub Draw(oE As Entity)

  Dim iLoop, iStart As Integer
  Dim fBorder As New Float[]

  If Not oE.Visible Then Return

  oE.ColorToPaint = gcd.GetGBColor(oE.colour, oE.pLayer)

  If oe.StringData[1] <> "Solid" Then

    GLplus.Lines(oE.PolyLine, oE.ColorToPaint, oE.LineWidth, oE.LineType.index)
  Else

    ' para solidos, tengo que hacer una llamada para cada loop de borde
    ' tengo q ver cuantos puntos tiene cada loop
    ' Ojo con LibreCAD
    For iLoop = 0 To oe.fParam[cadHatch.ipaTotalLoops] - 1
      ' obtengo el poligono de bordes
      fBorder.Clear
      fBorder.Insert(oe.PolyLine.Copy(iStart, oe.iParam[iLoop]))
      iStart += fBorder.Count

      glPlus.TRIANGLES(puntos.PolygonTriangulation(fBorder), oE.ColorToPaint, oE.ColorToPaint)

    Next

  End If

End

'' A fat version of the line
Public Sub DrawSelected(oE As Entity)

  Dim i As Integer

  GLplus.Lines(oE.PolyLine, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
  GLplus.Lines(oE.PolyLine, gcd.ColorForSelected, oE.LineWidth, oE.LineType.index)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

  If Not oE.Visible Then Return

  GLplus.Lines(oE.PolyLine, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
  GLplus.Lines(oE.PolyLine, oE.ColorToPaint, oE.LineWidth + 2, oe.linetype.index)

End

Public Function Draw2(oE As Entity)

  Dim iLoop, iStart As Integer
  Dim fBorder As New Float[]

  If oe.StringData[1] <> "Solid" Then

    paintPlus.Lines(oE.PolyLine)
  Else
    Paint.Polygon(oe.PolyLine)

  End If

End

'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity, Optional arrIndex As Integer = -1) As Integer

  If arrIndex < 0 Then arrIndex = gcd.CurrentDrawing.arrEntities.Max       ' si este valor no es provisto , estos POI son de la ultima entidad
  Dim i As Integer
  Return
  oe.PoiPoints.Clear
  oe.poiPoints.insert([oE.P[0], oE.P[1]])
  oe.poiType.Add(gcd.poiEndPoint)
  'oe.poiEntities.Add(arrIndex)

  For i = 0 To oE.P.count - 4 Step 2

    oe.poiPoints.insert([(oE.P[i + 0] + oE.P[i + 2]) / 2, (oE.P[i + 1] + oE.P[i + 3]) / 2])   ' mid
    oe.poiType.Add(gcd.poiMidPoint)
    'oe.poiEntities.Add(arrIndex)

    oe.poiPoints.insert([oE.P[i + 2], oE.P[i + 3]])
    oe.poiType.Add(gcd.poiEndPoint)
    'oe.poiEntities.Add(arrIndex)

    ' line
    'gcd.CurrDrawing.poiLines.insert([oE.p[i], oE.p[i + 1], oE.p[i + 2], oE.p[i + 3]])
    'gcd.CurrDrawing.poiLinesEntities.Add(arrIndex)
    ' gcd.CurrDrawing.poiLinesRelPoint.Insert([i / 2, i / 2 + 1])

  Next

End

' This function will return False if the element couldn't be created for some reason: bad or incomple user input
' True means all is good, False will instruct the clsEntityBuilder to delete it
Public Sub Finish(oE As Entity) As Boolean

  'Print "Finish en EntityBase"

  'CreatePolygon(oe)

  '  BuildPOI(oe)

  ' busco el tipo de linea, si hace falta

  ' tareas finales de armado del objeto
  Dim iLoop As Integer

  If LCase(oe.StringData[Me.sdaPattern]) <> "solid" Then
    cadHatchBuilder.FillEntityWithHatch(oe)
  Else
    ' esto es un poco mas complejo
    ' tengo q ver cuantos puntos tiene cada loop
    For iLoop = 0 To oe.fParam[cadHatch.ipaTotalLoops] - 1
      cadHatchBuilder.MakeBorder(oe, iLoop)
      ' en P ahora estan los puntos que definen el borde
      oe.iParam.Add(oe.P.Count)
      oe.PolyLine.insert(oe.P.Copy())
      oe.P.Clear

    Next

  End If

  oE.psel.resize(oE.p.count / 2)

  oE.DrawAble = True
  oE.Selected = False
  oE.Finished = True

End

Public Sub Cancel()

  gcd.clsJobPrevious = Me
  gcd.clsJob = clsDefaultJob
  DrawingAids.CleanTexts
  '''fMain.redraw

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

  cadLWPolyline.Translate(e, dX, dY, OnlySelected)
  puntos.Translate(e.PolyLine, dx, dy)

End

Public Sub Rotate(e As Entity, radians As Float)

  cadLWPolyline.Rotate(e, radians)
  puntos.Rotate(e.PolyLine, radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

  cadLWPolyline.Scale(e, sx, sy)
  puntos.Scale(e.PolyLine, sx, sy)

End

' Public Sub ExportDXF(e As Entity, hFile As File)
'
'     Dim i As Integer
'
'     Print #hFIle, "  0"                       ' Entity type
'     Print #hFIle, "HATCH"
'     clsEntities.DXFExportCommon(e, hFile)
'     Print #hFIle, "100"                     ' Subclass marker
'     Print #hFIle, "AcDbHatch"
'
'     Print #hFIle, " 10"                      ' X0
'     Print #hFIle, "0"
'     Print #hFIle, " 20"                      ' Y0   Elevation point
'     Print #hFIle, "0"
'     Print #hFIle, " 30"                      ' Z0
'     Print #hFIle, "0"                        '
'
'     Print #hFIle, " 210"                     ' X0
'     Print #hFIle, "0"
'     Print #hFIle, " 220"                     ' Y0   Exrusion direction
'     Print #hFIle, "0"
'     Print #hFIle, "230"                      ' Z0
'     Print #hFIle, "1"
'
'     Print #hFIle, "  2"
'     Print #hFIle, e.StringData[Me.sdaPattern]
'
'     Print #hFIle, " 70"                      ' 0 = pattern; 1 = solid
'     If LCase(e.StringData[Me.sdaPattern]) = "solid" Then Print #hFIle, "1" Else Print #hFIle, "0"
'
'     Print #hFIle, " 71" ' Associativity flag(0 = non - associative; 1 = associative); For MPolygon, solid - fill flag(0 = lacks solid fill; 1 = has solid fill)
'     Print #hFIle, "0"
'
'     Print #hFIle, " 91" ' Number Of boundary paths(loops) La cantidad de contornos que se definnen a partir de este punto
'     Print #hFIle, "1"
'
'     Print #hFIle, " 92" ' boundary paths 0=default; 1=external, 2=poly, 4=derivado, 8=textbox, 16=outermost
'     Print #hFIle, "0"
'
'     Print #hFIle, " 93" ' Numero de elementos q forman este borde (si es poly no se pone nada)
'     Print #hFIle, "0"
'
'     ' Gaucho por ahora define el contorno con polilineas unicamente, asi que las dos lineas siguientes se comentan
'     'Print #hFIle, " 72" ' 1 = lines, 2=arc, 3=ellipse, 4=SPline
'     'Print #hFIle, "0"
'
'     For i = 0 To e.p.Max Step 2
'         Print #hFIle, " 10"                      ' Xi
'         Print #hFIle, CStr(e.p[i])
'         Print #hFIle, " 20"                      ' Yi
'         Print #hFIle, CStr(CStr(e.p[i + 1]))
'     Next
'
'     Print #hFIle, " 97" ' puntos secudarios
'     Print #hFIle, "0"
'
'     Print #hFIle, " 75" ' Hatch style: 0 = Hatch “odd parity” area (Normal style), 1 = Hatch outermost area only(Outer style) , 2 = Hatch through entire area(Ignore style)                       ' 0 = pattern; 1 = solid
'     Print #hFIle, "0"
'
'     Print #hFIle, " 76" ' Hatch pattern type: 0 = User - defined , 1 = Predefined, 2 = Custom
'     Print #hFIle, "1"
'
'     Print #hFIle, " 52" ' rotation en RAD
'     Print #hFIle, CStr(e.fParam[Me.ipaRotation])
'
'     Print #hFIle, " 41" ' scale
'     Print #hFIle, CStr(e.fParam[Me.ipaScale])
'
'     Print #hFIle, " 77" ' Hatch pattern double flag (pattern fill only):0 = Not double,1 = double
'     Print #hFIle, "0"
'
'     Print #hFIle, " 78" ' Number of pattern definition lines  (si 76 es user defined)
'     Print #hFIle, "0"
'
'     Print #hFIle, " 98" ' Numero de elementos q forman este borde (si es poly no se pone nada)
'     Print #hFIle, "0"
'
' End

Public Sub setEntity(e As Entity)

  e.fParam.Resize(Me.TotalParams)
  e.StringData.Resize(Me.sdaTotalParams) ' text, style

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

  Dim i, iLoop, iPoints, iBorderObjects, iBoundaryObject As Integer
  Dim LoopToRead As Integer
  Dim LoopType As Integer
  Dim EdgesToRead As Integer
  Dim EdgeType As Integer
  Dim eContour As Entity
  Dim edge As Integer

  'If e.Handle = "60FA9" Then Stop

  ' vamos a agrupar las entidades que forman el contorno en un bloque
  e.pBlock = New Block
  e.pBlock.entities = New Entity[]

  'For i = 0 To sClaves.Max
  i = -1
  Do While i < sClaves.max    ' en este importador usare un do-loop en vez de un for-next por la complejidad del hatch
    Inc i

    If sClaves[i] = "91" Then
      e.fParam[Me.ipaTotalLoops] = CFloat(sValues[i])
      LoopToRead = e.fParam[Me.ipaTotalLoops]
    End If

    If LoopToRead > 0 Then

      Inc i

      ' para Debug
      ' If LoopToRead = 21 Then Stop

      For iLoop = 0 To LoopToRead - 1
        Dec LoopToRead
        ' estas claves definen el borde

        i = dxf.ReadCode(92, sClaves, sValues, ByRef LoopType, i)
        If i = True Then Stop
        If (LoopType And 2) <> 2 Then ' otherwise is a polyline
          Inc i

          i = dxf.ReadCode(93, sClaves, sValues, ByRef EdgesToRead, i)
          If i = True Then Stop
          For edge = 0 To EdgesToRead - 1

            i = dxf.ReadCode(72, sClaves, sValues, ByRef EdgeType, i)
            If i = True Then Stop

            ' segun el tipo de edge, agrego una entidad al bloque que
            ' forma el contorno
            eContour = New Entity
            ' a esta entidad que es un borde le etiquetamos el loop al que pertenece
            eContour.Group = iLoop

            e.pBlock.entities.Add(eContour)
            Select Case EdgeType
              Case 0  ' invalido

                Stop

              Case 1 ' lines
                eContour.ClassHandler = cadLine
                eContour.Gender = eContour.ClassHandler.Gender
                ' leo los dos puntos
                Inc i
                If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "11" Then eContour.P.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "21" Then eContour.P.Add(CFloat(sValues[i]))
              Case 2 ' arc o circle
                eContour.ClassHandler = cadArc
                eContour.Gender = eContour.ClassHandler.Gender
                Inc i
                If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "40" Then eContour.fParam.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "50" Then eContour.fParam.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "51" Then eContour.fParam.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "73" Then eContour.fParam.Add(CFloat(sValues[i]))
              Case 3 ' ellipse
                eContour.ClassHandler = cadEllipse
                eContour.Gender = eContour.ClassHandler.Gender
                Inc i
                If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))     ' centro
                Inc i
                If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "11" Then eContour.P.Add(CFloat(sValues[i]) + eContour.P[0])     ' eje mayor, relativo al centro
                Inc i
                If sClaves[i] = "21" Then eContour.P.Add(CFloat(sValues[i]) + eContour.P[1])
                Inc i
                If sClaves[i] = "40" Then eContour.fParam.Add(CFloat(sValues[i]))
                Inc i
                If sClaves[i] = "50" Then eContour.fParam.Add(CFloat(sValues[i]) * 180 / Pi)

                ' esto soluciona un proble de unidades de LibreCAD
                If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
                  eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
                Endif
                Inc i
                If sClaves[i] = "51" Then eContour.fParam.Add(CFloat(sValues[i]) * 180 / Pi)

                ' esto soluciona un proble de unidades de LibreCAD
                If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
                  eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
                Endif

            End Select
          Next

          ' cuando termino de leer los datos del Edge, puede venir Boundary Object

          Inc i
          If sClaves[i] = "97" Then
            For iBoundaryObject = 1 To CInt(sValues[i])
              Inc i
              eContour = New Entity
              ' a esta entidad que es un borde le etiquetamos el loop al que pertenece
              eContour.Group = iLoop
              i = dxf.ReadCode(330, sClaves, sValues, ByRef eContour.Handle, i)
              e.pBlock.entities.Add(eContour)

            Next
          End If

          Continue

        Else ' read the polyline loop
          ' forma el contorno
          eContour = cadLWPolyline.NewEntity()
          ' a esta entidad que es un borde le etiquetamos el loop al que pertenece
          eContour.Group = iLoop

          e.pBlock.entities.Add(eContour)

          Inc i
          ' leo si tiene bulges
          If sClaves[i] = "72" Then
            If sValues[i] = "1" Then ' tiene bulges
              eContour.iParam[cadLWPolyline.iiiBulged] = 1
            End If
          Else
            'error de DXF
            Stop
          Endif

          Inc i
          ' leo si es abierta o cerrada
          If sClaves[i] = "73" Then
            If sValues[i] = "1" Then ' cerrada
              eContour.iParam[cadLWPolyline.iiiPolylineClosed] = 1
            End If
          Else
            'error de DXF
            Stop
          Endif

          Inc i
          ' numero de vertice
          If sClaves[i] = "93" Then
            eContour.P.Resize(CInt(sValues[i] * 2))
          Else
            'error de DXF

          Endif

          For iPoints = 0 To eContour.P.Count / 2 - 1
            Inc i
            eContour.P[iPoints * 2] = CFloat(sValues[i])
            Inc i
            eContour.P[iPoints * 2 + 1] = CFloat(sValues[i])
            If eContour.iParam[cadLWPolyline.iiiBulged] Then
              Inc i ' ignoro el bulge
            Endif
          Next

        Endif
        ' despues del loop hay un 97
        Inc i
        ' Objetos ecternos de borde
        If sClaves[i] = "97" Then
          For iBorderObjects = 0 To CInt(sValues[i]) - 1 ' los leo
            ' aca viene un Handle a un objeto que tambien es contorno pero no esta definido directamette en la entidad Hatch
            ' pero puede ocurrir que este objeto no este cargado aun en ningun lado porque su lectura no ocurrio
            ' TODO: verificar esto

            Inc i
          Next
        Else
          'error de DXF

        Endif
        Inc i

      Next

    End If
    If sClaves[i] = "2" Then e.StringData[Me.sdaPattern] = sValues[i] ' hach file

    If sClaves[i] = "70" Then e.fParam[Me.ipaSolid] = CFloat(sValues[i])
    If sClaves[i] = "71" Then e.fParam[Me.ipaAsociativity] = CFloat(sValues[i])
    If sClaves[i] = "72" Then e.fParam[Me.ipaBoundaryType] = CFloat(sValues[i])

    If sClaves[i] = "52" Then e.fParam[Me.ipaRotation] = CFloat(sValues[i])
    If sClaves[i] = "41" Then
      e.fParam[Me.ipaScale] = CFloat(sValues[i])

    End If
    If sClaves[i] = "75" Then e.fParam[Me.ipaParity] = CFloat(sValues[i])
    If sClaves[i] = "76" Then e.fParam[Me.ipaPatternType] = CFloat(sValues[i])

  Loop

  If e.fParam[Me.ipaSolid] Then
    e.StringData[Me.sdaPaternFile] = "Solid"
  Else
    e.StringData[Me.sdaPaternFile] = Application.Path &/ "patterns" &/ LCase(e.StringData[Me.sdaPattern]) & ".dxf"
  End If

  ' ' TODO: this is a debug
  ' e.StringData[Me.sdaPaternFile] = "Ansi31"

  Return True

  ' catch

  Return False

LoopImport:

End
