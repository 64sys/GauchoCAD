' Gambas class file

' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
Inherits Caddimension

Public Const Gender As String = "DIMENSION_ANG3PT"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Insert a linear acotation")
Public Const ParamType As String = "PPPP"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = "Center of arc;First point;Secont point;extension"

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

  Dim i As Integer
  Dim AfterSubclassmarker As Boolean
  ' revisamos lo que viene del importador comun
  Me.pointDefPoint0.x = e.P[0]
  Me.pointDefPoint0.y = e.P[1]

  Me.pointTextMidPoint.x = e.P[2]
  Me.pointTextMidPoint.y = e.P[3]

  For i = 0 To sClaves.Max
    If sClaves[i] = "100" And sValues[i] = "AcDb3PointAngularDimension" Then AfterSubclassmarker = True
    If AfterSubclassmarker Then ' lo siguientes codigos

      If sClaves[i] = "13" Then Me.pointDefPoint1.x = CFloat(sValues[i])
      If sClaves[i] = "23" Then Me.pointDefPoint1.y = CFloat(sValues[i])

      If sClaves[i] = "14" Then Me.pointDefPoint2.x = CFloat(sValues[i])
      If sClaves[i] = "24" Then Me.pointDefPoint2.y = CFloat(sValues[i])

      If sClaves[i] = "15" Then Me.pointCenter.x = CFloat(sValues[i])
      If sClaves[i] = "25" Then Me.pointCenter.y = CFloat(sValues[i])

    End If

  Next

  ' ahora recosntruyo el bloque segun mis propios metodos
  e.P[0] = Me.pointCenter.x
  e.P[1] = Me.pointCenter.y

  e.P[2] = Me.pointDefPoint2.x
  e.P[3] = Me.pointDefPoint2.y

  e.P.Add(Me.pointDefPoint1.x)
  e.P.Add(Me.pointDefPoint1.y)

  e.P.Add(Me.pointTextMidPoint.x)
  e.P.Add(Me.pointTextMidPoint.y)

  e.fParam[cadDimension.ipaExtension] = -puntos.distancia(Me.pointDefPoint0.x, Me.pointDefPoint0.y, Me.pointCenter.x, Me.pointCenter.y)

  ' TODO: cuando este terminada la entidad, sacar eso
  e.pBlock.AbsoluteCoords = True

  ' y poner esto
  ' e.pBlock = Me.ReBuildBlock(e)

  Return True

  ' catch

  Return False

End

Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

  ' la linea solo recibe puntos

  If vParam[0] <> "point" Then Return False

  If Me.StepsDone = 0 Then
    Me.DimType = gcd.dimAligned

    Try eBuild.P[0] = vParam[1]
    Try eBuild.P[1] = vParam[2]
    eBuild.P[2] = eBuild.P[0]
    eBuild.P[3] = eBuild.P[1]
    If definitive Then Return True
  Else If Me.StepsDone = 1 Then
    eBuild.DrawAble = True
    eBuild.Finished = True
    Try eBuild.P[2] = vParam[1]
    Try eBuild.P[3] = vParam[2]
    eBuild.P[4] = eBuild.P[2]
    eBuild.P[5] = eBuild.P[3]

    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then Return True
  Else If Me.StepsDone = 2 Then
    eBuild.DrawAble = True
    eBuild.Finished = True
    Try eBuild.P[4] = vParam[1]
    Try eBuild.P[5] = vParam[2]
    eBuild.P[6] = eBuild.P[4]
    eBuild.P[7] = eBuild.P[5]

    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then Return True
  Else If Me.StepsDone = 3 Then
    eBuild.DrawAble = True
    eBuild.Finished = True
    Try eBuild.P[6] = vParam[1]
    Try eBuild.P[7] = vParam[2]

    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then Return True

  Endif

End

Public Sub ReBuildBlock(E As Entity) As Block

  Dim d As Float, flxTextExt As Float[]
  Dim fRotXY As Float[]

  Dim newBlock As New Block
  Dim f1, f2 As New Float[]

  newBlock.entities = New Collection

  ' para definir este bloque necesito 6 entidades
  Dim eLineaPpal As Entity
  Dim eOblique1 As Entity       ' tambien pueden ser flechas Solid
  Dim eOblique2 As Entity
  Dim eExtension1 As Entity
  Dim eExtension2 As Entity
  Dim eDot1 As Entity
  Dim eDot2 As Entity
  Dim eText As Entity
  Dim ePoint2 As Entity

  ' vemos los estilos
  If E.fParam[Me.ipaStyleTextHeigth] > 0 Then Me.DimTextHeight = E.fParam[Me.ipaStyleTextHeigth] Else Me.DimTextHeight = E.pStyle.fTxtHeight_140
  If E.fParam[Me.ipaStyleArrowSize] > 0 Then Me.DimArrowSize = E.fParam[Me.ipaStyleArrowSize] Else Me.DimArrowSize = E.pStyle.fArrowSize_41
  Me.DimArrowWidth = Me.DimArrowSize / 3

  ' la linea principal ahora es un arco
  clsEntities.Addarc(newBlock.entities, [0.0, 0.0], 0, 0, 0, E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eLineaPpal = newBlock.entities.Last

  ' lineas de demarcacion
  clsEntities.AddLine(newBlock.entities, [0, Me.DimExtension, 0, -Me.DimExtension], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eExtension1 = newBlock.entities.Last

  clsEntities.AddLine(newBlock.entities, [0, Me.DimExtension, 0, -Me.DimExtension], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eExtension2 = newBlock.entities.Last

  ' flechas

  clsEntities.Addsolid(newBlock.entities, [0, 0, Me.DimArrowSize, Me.DimArrowWidth, Me.DimArrowSize, -Me.DimArrowWidth, 0, 0], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eOblique1 = newBlock.entities.Last

  clsEntities.Addsolid(newBlock.entities, [0, 0, -Me.DimArrowSize, Me.DimArrowWidth, -Me.DimArrowSize, -Me.DimArrowWidth, 0, 0], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eOblique2 = newBlock.entities.Last

  ' texto
  clsEntities.AddMText(newBlock.entities, [0.0, 0.0, 0.0, 0.0], 0, Me.DimTextHeight, "0.00", E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eText = newBlock.entities.Last

  ' -> el bloque

  E.fParam[cadInsert.ipaEscX] = 1      ' ScaleX del inserto
  E.fParam[cadInsert.ipaEscY] = 1      ' ScaleY del inserto
  E.fParam[cadInsert.ipaEscZ] = 1      ' ScaleY del inserto

  E.Visible = True

  '
  eLineaPpal.fParam[0] = 0          ' radio
  eLineaPpal.fParam[1] = Ang(E.P[2] - E.P[0], E.P[3] - E.P[1]) * 180 / Pi

  '
  ' las lineas de extension (las hago HORIZONTALES y las roto)
  eExtension1.P.Clear
  eExtension1.P.Insert([-Me.DimExtension, 0, Me.DimExtension, 0])
  eExtension2.P.Clear
  eExtension2.P.Insert([-Me.DimExtension, 0, Me.DimExtension, 0])

  ' flechas
  eOblique1.P.Clear
  eOblique1.P.Insert([0, 0, -Me.DimArrowWidth, Me.DimArrowSize, Me.DimArrowWidth, Me.DimArrowSize, 0, 0])

  eOblique2.P.Clear
  eOblique2.P.Insert([0, 0, -Me.DimArrowWidth, -Me.DimArrowSize, Me.DimArrowWidth, -Me.DimArrowSize, 0, 0])
  '

  ' 2========================================================================================

  eLineaPpal.fParam[2] = Ang(E.P[4] - E.P[0], E.P[5] - E.P[1]) * 180 / Pi
  '

  ' ' la sexta es el texto
  If (eLineaPpal.fParam[2] - eLineaPpal.fParam[1]) < 0 Then eLineaPpal.fParam[2] += 360

  E.fParam[cadDimension.ipaRealMeasure] = (eLineaPpal.fParam[2] - eLineaPpal.fParam[1])

  eText.StringData[0] = Format(E.fParam[cadDimension.ipaRealMeasure], Me.DimFormatAng) & "*"
  fRotXY = puntos.RotateFromPointWithAngle(E.P[0], E.P[1], (eLineaPpal.fParam[2] - eLineaPpal.fParam[1]) / 180 * Pi / 2, E.P[2], E.P[3])
  '
  flxTextExt = glPlus.MTextExtends(eText.StringData[cadMText.sdaText], 0, 0, eText.fParam[1])
  '
  eText.P[0] = fRotXY[0] - E.P[0]
  eText.P[1] = fRotXY[1] - E.P[1]
  eText.fParam[cadMText.ipaTextAngle] = (eLineaPpal.fParam[2] + eLineaPpal.fParam[1]) / 2 - 90

  ' 3 ===========================================================================

  ' nuevo radio
  d = puntos.distancia(E.P[0], E.P[1], E.P[6], E.P[7])
  eLineaPpal.fParam[0] = d          ' radio del arco

  ' roto
  eExtension1.ClassHandler.Rotate(eExtension1, eLineaPpal.fParam[1] / 180 * Pi)
  eExtension2.ClassHandler.Rotate(eExtension2, eLineaPpal.fParam[2] / 180 * Pi)
  eOblique1.ClassHandler.Rotate(eOblique1, eLineaPpal.fParam[1] / 180 * Pi)
  eOblique2.ClassHandler.Rotate(eOblique2, eLineaPpal.fParam[2] / 180 * Pi)

  ' muevo
  fRotXY = puntos.RotateFromPointWithAngle(E.P[0], E.P[1], eLineaPpal.fParam[1] / 180 * Pi, d + E.P[0], E.P[1])
  ' traslado una flecha y una linea de extension
  eExtension1.ClassHandler.Translate(eExtension1, fRotXY[0] - E.P[0], fRotXY[1] - E.P[1])
  eOblique1.ClassHandler.Translate(eOblique1, fRotXY[0] - E.P[0], fRotXY[1] - E.P[1])

  ' muevo
  fRotXY = puntos.RotateFromPointWithAngle(E.P[0], E.P[1], eLineaPpal.fParam[2] / 180 * Pi, d + E.P[0], E.P[1])
  ' traslado las otras
  eExtension2.ClassHandler.Translate(eExtension2, fRotXY[0] - E.P[0], fRotXY[1] - E.P[1])
  eOblique2.ClassHandler.Translate(eOblique2, fRotXY[0] - E.P[0], fRotXY[1] - E.P[1])

  ' la sexta es el texto

  fRotXY = puntos.RotateFromPointWithAngle(E.P[0], E.P[1], (eLineaPpal.fParam[2] + eLineaPpal.fParam[1]) / 180 * Pi / 2, d + E.P[0], E.P[1])

  eText.P[0] = fRotXY[0] - E.P[0]
  eText.P[1] = fRotXY[1] - E.P[1]

  ' el largo de la linea principal viene dado por la distancia entre ambos puntos
  d = puntos.distancia(E.P[0], E.P[1], E.P[2], E.P[3])

  ' con este click calculo el angulo
  'elem.fParam[cadInsert.ipaRotacion] = Ang(elem.p[2] - elem.P[0], elem.p[3] - elem.P[1]) * 180 / Pi

  ' X0

  '===========================================
  Return newBlock

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  e.fParam.Resize(Me.TotalParams)

  '    MANEJADO EN clsEntities
  '============================
  '      "entity": "DIMENSION_ANG3PT",
  '      "index": 278,
  '      "type": 23,
  '      "handle": [0, 4504],
  '      "size": 144,
  '      "bitsize": 1010,
  '      "reactors": [
  '        [4, 2, 4506, 4506]
  '      ],
  '      "xdicobjhandle": [3, 2, 4505, 4505],
  '      "_subclass": "AcDbEntity",
  '      "prev_entity": [8, 0, 0, 4503],
  '      "next_entity": [10, 1, 30, 4534],
  '      "layer": [5, 2, 5261, 5261],
  '      "preview_exists": 0,
  '      "entmode": 2,
  '      "nolinks": 0,
  '      "color": 256,
  '      "ltype_scale": 1.0,
  '      "ltype_flags": 0,
  '      "plotstyle_flags": 0,
  '      "invisible": 0,
  '      "linewt": 29,
  '      "_subclass": "AcDbDimension",
  '      "extrusion": [0.0, 0.0, 1.0],
  '      "text_midpt": [348.21138128872752, 114.64222953967749],
  '      "elevation": 0.0,
  '      "flag1": 10,
  '      "user_text": "",
  '      "text_rotation": 0.0,
  '      "horiz_dir": 0.0,
  '      "ins_scale": [1.0, 1.0, 1.0],
  '      "ins_rotation": 0.0,
  '      "attachment": 5,
  '      "lspace_style": 1,
  '      "lspace_factor": 1.0,
  '      "act_measurement": 0.41551576504848,
  '      "clone_ins_pt": [0.0, 0.0],
  '      "flag": 128,
  '      "_subclass": "AcDb3PointAngularDimension",
  '      "def_pt": [349.89251525148757, 115.79813193763354, 0.0],
  '      "xline1_pt": [343.78242223304994, 126.27589894372454, 0.0],
  '      "xline2_pt": [341.32254709690983, 120.90059947299312, 0.0],
  '      "center_pt": [336.34758655818501, 133.69728917520501, 0.0],
  '      "dimstyle": [5, 1, 57, 57],
  '     "block": [5, 2, 4507, 4507]

  e.P.Add(c["center_pt"][0])
  e.P.Add(c["center_pt"][1])

  e.P.Add(c["xline2_pt"][0])
  e.P.Add(c["xline2_pt"][1])

  e.P.Add(c["xline1_pt"][0])
  e.P.Add(c["xline1_pt"][1])

  e.P.Add(c["def_pt"][0])
  e.P.Add(c["def_pt"][1])

  ' "def_pt": [410.0, 85.76276491494264, 0.0],
  ' "oblique_angle": 0.0,

  ' "dim_rotation": 0.0,
  e.fParam[Me.ipaEscX] = 1
  e.fParam[Me.ipaEscY] = 1
  e.fParam[Me.ipaEscZ] = 1

  'e.fParam[Me.ipaRotacion] = CFloat(c["dim_rotation"]) * 180 / Pi
  ' "_subclass": "AcDbRotatedDimension",
  ' "dimstyle": [5, 1, 57, 57],
  Dim hBlock As Integer

  e.Block = gcd.CurrentDrawing.cmodel["BLOCKS"][c["block"][3]]["block_entity"][3]
  e.pBlock = ReBuildBlock(e)
  'e.Block = gcd.CurrentDrawing.arrBlocks[clsEntities.FIndBlockIDbyHandle(hBlock)].name
  ' "block": [5, 2, 3228, 3228] '  esto apunta a cModel["BLOCKS"] , pero hay q buscar otra cosa

  Return True

Catch

  Return False

End
