' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

Public inxBuffersID As New Integer[]

Public Sub DrawArrays()

  Dim iError, vOffset, nOffset, cOffset, tOffset As Integer

  If inxBuffersID.Count = 0 Then Return

  glx.glBindBuffer(glc.ARRAY_BUFFER, inxBuffersID[0])

  iError = glx.glGetError()
  If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)
  glx.glEnableClientState(glc.VERTEX_ARRAY)
  glx.glEnableClientState(glc.NORMAL_ARRAY)
  glx.glEnableClientState(glc.COLOR_ARRAY)

  iError = glx.glGetError()
  If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)

  vOffset = 0
  nOffset = glPlus.VBO_vertex.Count * SizeOf(gb.Single)
  cOffset = nOffset + glPlus.VBO_normals.Count * SizeOf(glPlus.VBO_normals.Type)
  'tOffset = cOffset + sizeof colors

  glx.glVertexPointer(3, glc.FLOAT, 0, vOffset)
  glx.glNormalPointer(glc.FLOAT, 0, nOffset)
  glx.glColorPointer(3, glc.FLOAT, 0, cOffset)

  iError = glx.glGetError()
  If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)

  glx.glDrawArrays(glc.LINES, 0, glPlus.VBO_vertex.Count * 3)

  glx.gldisableClientState(glc.VERTEX_ARRAY)
  glx.gldisableClientState(glc.NORMAL_ARRAY)
  glx.gldisableClientState(glc.COLOR_ARRAY)

  glx.glBindBuffer(glc.ARRAY_BUFFER, 0)

End

Public Function FIndBlockIDbyHandle(BlockHandle As String) As Block

  Dim B As Block

  For Each B In gcd.CurrentDrawing.oBlocks
    If B.handle = BlockHandle Then Return B
  Next
  Return Null

End

Public Function FIndBlock(BlockName As String) As Block

  Dim b As Block

  For Each b In gcd.CurrentDrawing.oBlocks
    If b.name = BlockName Then Return b
  Next
  Return

End

Public Function FindStyle(sName As String) As Style

  Dim b As Style

  For Each b In gcd.CurrentDrawing.oStyles
    If b.name = sName Then Return b
  Next
  Return

End

' Public Sub setEntity(e As Entity)
'
'     Try e.iParam.Resize(e.ClassHandler.iTotalParams)
'     Try e.fParam.Resize(e.ClassHandler.fTotalParams)
'     Try e.StringData.Resize(e.ClassHandler.sdaTotalParams) ' text, style
'     Try e.P.Resize(e.ClassHandler.TotalPoints * 2)
'
' End

Public Function ReconstruirBloques() As Boolean

  ' busco bloques y coloco puntos de referencias
  ' Armamos los bolques, que extraemos de las entidades
  Dim i, i2 As Integer, PartesEncontradas As Boolean, iStart As Integer
  Dim t As Float = Timer

  gcd.debuginfo("Recostruyendo bloques")

  For i = 0 To gcd.CurrentDrawing.oEntities
    DrawingAids.HelperTrabajo = ("Loading blocks ") & Format$(i / gcd.CurrentDrawing.oEntities, "0.00%")
    Wait 0.0001
    If gcd.CurrentDrawing.oEntities[i].gender = "Block" Then
      Dim newBlock As New Block
      newBlock.name = gcd.CurrentDrawing.oEntities[i].block
      newBlock.x = gcd.CurrentDrawing.oEntities[i].p[0]
      newBlock.y = gcd.CurrentDrawing.oEntities[i].p[1]
      newBlock.entities = New Collection
      ' busco los objetos de este bloque y los reconstruyo
      For i2 = iStart To gcd.CurrentDrawing.oEntities
        If gcd.CurrentDrawing.oEntities[i2].block = newBlock.name And gcd.CurrentDrawing.oEntities[i2].gender <> "Block" Then ' sin recursividad en bloques
          If gcd.CurrentDrawing.oEntities[i2].block = newBlock.name And gcd.CurrentDrawing.oEntities[i2].gender <> "Insert" Then 'no quiero insertarme a mi mismo
            PartesEncontradas = True
            Dim o2 As Entity
            o2 = ClonEntity(gcd.CurrentDrawing.oEntities[i2])

            o2.ClassHandler.finish(o2)
            newBlock.entities.Add(o2)
          End If
        Else
          If PartesEncontradas Then ' estaba armando un bloque, pero ya termine porque esta entidad es otra cosa
            PartesEncontradas = False
            iStart = i2
            Break
          End If

        Endif
      Next
      gcd.CurrentDrawing.arrBlocks.Add(newBlock)
    End If
  Next

  Wait 0.001
  Debug "Reconstruccion finalizada en ", Str$(Timer - t)

End

Public Sub _new()

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenBuffers(Optional eEntity As Entity = Null)

  Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
  Dim i, iVbo As Integer, e As Entity

  If eEntity Then

    ' If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
    ' gl.NewList(eEntity.glDrwList, gl.COMPILE)
    ' eEntity.ClassHandler.Draw(eEntity)
    ' gl.EndList
    '
    ' If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
    ' gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
    ' eEntity.ClassHandler.DrawSelected(eEntity)
    ' gl.EndList

  Else

    ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
    Dim t As Float = Timer
    Dim iError As Integer
    ' listas de entidades
    glPlus.VBOFlush
    'glPlus.InmediateMode = False

    If gcd.CurrentDrawing.oEntities.Count = 0 Then Return
    For Each e In gcd.CurrentDrawing.oEntities

      'If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)
      'gl.NewList(e.glDrwList, gl.COMPILE)
      e.ClassHandler.Draw(e)
      'gl.EndList

    Next
    glPlus.InmediateMode = True

    Dim oneBufferID As Integer
    inxBuffersID.Resize(3)

    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & Hex(iError))

    'glx.glGenBuffers(1, VarPtr(oneBufferID))
    glx.glGenBuffers(3, inxBuffersID.Data)                      ' genero un buffer ID
    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & Hex(iError))
    glx.glBindBuffer(glc.ARRAY_BUFFER, inxBuffersID[0])      ' lo conecto como Vertex Buffer
    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & Hex(iError))
    Dim BytesTotales As Integer
    BytesTotales = glPlus.VBO_vertex.Count + glPlus.VBO_normals.Count + glPlus.VBO_colors.Count
    BytesTotales *= SizeOf(gb.Single)

    ' Reservo espacio. 0 significa que despues le mando la data
    glx.glBufferData(glc.ARRAY_BUFFER, BytesTotales, 0, glc.STATIC_DRAW)
    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & Hex(iError))
    ' mando vertices
    glx.glBufferSubData(glc.ARRAY_BUFFER, 0, glPlus.VBO_vertex.Count * SizeOf(gb.Single), glPlus.VBO_vertex.Data)

    ' mando normales
    glx.glBufferSubData(glc.ARRAY_BUFFER, glPlus.VBO_vertex.Count * SizeOf(gb.Single), glPlus.VBO_normals.Count * SizeOf(gb.Single), glPlus.VBO_normals.Data)

    ' mando colores
    glx.glBufferSubData(glc.ARRAY_BUFFER, (glPlus.VBO_vertex.Count + glPlus.VBO_normals.Count) * SizeOf(gb.Single), glPlus.VBO_colors.Count * SizeOf(gb.Single), glPlus.VBO_colors.Data)
    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & Hex(iError))
    glx.glBindBuffer(glc.ARRAY_BUFFER, 0)      ' finlizo transferencia de datos a la GPU

    ' ' lista de entidaes seleccionadas
    ' For Each e In gcd.CurrentDrawing.oEntities
    '     If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
    '     gl.NewList(e.glDrwListSel, gl.COMPILE)
    '     e.ClassHandler.DrawSelected(e)
    '     gl.EndList
    ' Next
    '
    ' ' lista de todas las entidades
    ' t = Timer
    ' glGenDrawListLAyers
    '
    ' Debug "GLlista de todas generada en  ", Timer - t
  End If

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenDrawList(Optional eEntity As Entity = Null)

  Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
  Dim i As Integer, e As Entity

  If eEntity Then

    If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
    gl.NewList(eEntity.glDrwList, gl.COMPILE)
    eEntity.ClassHandler.Draw(eEntity)
    gl.EndList

    If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
    gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
    eEntity.ClassHandler.DrawSelected(eEntity)
    gl.EndList

  Else

    ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
    Dim t As Float = Timer
    ' listas de entidades
    For Each e In gcd.CurrentDrawing.oEntities

      If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)
      gl.NewList(e.glDrwList, gl.COMPILE)
      e.ClassHandler.Draw(e)
      gl.EndList

    Next

    ' lista de entidaes seleccionadas
    For Each e In gcd.CurrentDrawing.oEntities
      If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
      gl.NewList(e.glDrwListSel, gl.COMPILE)
      e.ClassHandler.DrawSelected(e)
      gl.EndList
    Next

    ' lista de todas las entidades
    t = Timer
    glGenDrawListLAyers

    Debug "GLlista de todas generada en  ", Timer - t
  End If

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListSel(Optional mode As Integer = 0)

  Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
  Dim i As Integer, e As Entity

  If Not gl.islist(gcd.CurrentDrawing.GlListSelectedEntities) Then gcd.CurrentDrawing.GlListSelectedEntities = gl.GenLists(1)

  gl.NewList(gcd.CurrentDrawing.GlListSelectedEntities, gl.COMPILE)

  For Each e In gcd.CurrentDrawing.oSelected

    'If gcd.CurrentDrawing.arrEntities[i].Selected Then
    If mode = 0 Then gl.CallList(e.glDrwListSel)
    If mode = 1 Then gl.CallList(e.glDrwList)
    'End If
  Next

  gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListAll(Optional ExcludeSelected As Boolean = False)

  Dim i As Integer, e As Entity

  gl.NewList(gcd.CurrentDrawing.GlListAllEntities, gl.COMPILE)

  For Each e In gcd.CurrentDrawing.oEntities
    If Not (e.Selected And ExcludeSelected) Then gl.CallList(e.glDrwList)

  Next

  gl.EndList

  For Each L As Layer In gcd.CurrentDrawing.oLayers
    If Not gl.islist(L.glList) Then L.glList = gl.GenLists(1)
    gl.NewList(L.glList, gl.COMPILE)
  Next
  For Each e In gcd.CurrentDrawing.oEntities
    If Not (e.Selected And ExcludeSelected) Then gl.CallList(e.glDrwList)

  Next

  gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers(Optional aLayer As Layer)

  Dim i As Integer
  Dim e As Entity

  If aLayer Then

    If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
    gl.NewList(aLayer.glList, gl.COMPILE)
    For Each e In gcd.CurrentDrawing.oEntities

      If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

    Next
    gl.EndList

  Else

    For Each aLayer In gcd.CurrentDrawing.oLayers
      If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
      gl.NewList(aLayer.glList, gl.COMPILE)
      For Each e In gcd.CurrentDrawing.oEntities

        If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

      Next
      gl.EndList

    Next

  Endif

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers2(Optional aLayer As Layer)

  Dim i As Integer
  Dim e As Entity

  If aLayer Then

    If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
    gl.NewList(aLayer.glList, gl.COMPILE)
    For Each e In gcd.CurrentDrawing.oEntities

      If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

    Next
    gl.EndList

  Else

    For Each aLayer In gcd.CurrentDrawing.oLayers
      If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
      gl.NewList(aLayer.glList, gl.COMPILE)
      For Each e In aLayer.Entities
        gl.CallList(e.glDrwList)

      Next
      gl.EndList

    Next

  Endif

End

Public Sub DrawPoiSymbolsAll()

  Dim i, total As Integer

  For Each e As Entity In gcd.CurrentDrawing.oEntities

    If e.Selected Then

      If (e.Gender = "Insert") Then
        DrawPoiSymbols(e)
        Inc total
      End If
    End If
    If total = 100 Then Break                           ' limitamos la cantidad de enganches a un numero sensato
  Next

End

Public Sub DrawPoiSymbols(oE As Entity)

  Dim i As Integer

  For i = 0 To oe.PoiPoints.Max Step 2
    Select Case oe.PoiType[i / 2]
      Case gcd.poiEndPoint
        glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1, 1)

      Case gcd.poiMidPoint
        glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

      Case gcd.poiCenter
        glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

      Case gcd.poiQuadrant
        glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1, 1)

      Case gcd.poiBasePoint
        glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

    End Select

  Next

End

Public Sub Finish(Optional selected As Boolean = True)

  ' creo copias de cada elemento seleccionado
  Dim m As Integer, E As Entity

  For Each E In gcd.CurrentDrawing.oEntities
    If selected Then                                                    ' apply to only the selected ones
      If E.Selected Then E.ClassHandler.Finish(E)
    Else                                                                ' apply to all
      E.ClassHandler.Finish(E)
    End If

  Next

End

Public Sub ClonElements(Optional selected As Boolean = True)

  ' creo copias de cada elemento seleccionado
  Dim E As Entity
  Dim eClon As Entity

  For Each E In gcd.CurrentDrawing.oSelected
    eClon = Me.ClonEntity(e, True)
    gcd.CurrentDrawing.oEntities.Add(eClon, eClon.Handle)
    eClon.ClassHandler.finish(eClon)
    gcd.CurrentDrawing.CurrLayer.Entities.Add(eClon)

  Next

End

Public Sub ClonEntity(e As Entity, Optional GetNewHandle As Boolean = True) As Entity
  ' clona una entidad
  ' copia todos sus elementos
  ' llama a las rutinas de reconstruccion del contorno y de los POI

  Dim o As Entity

  o = e.ClassHandler.newEntity()
  CopyElemData(e, o)                              ' copy all values
  o.ClassHandler.BuildPoi(o)
  If GetNewHandle Then o.Handle = gcd.NewHandle()
  Return o

End

'' Busca elementos seleccionados y arma un array nuevo con ellos, eliminandolos del anterior
Public Function SelectArrayMake() As Integer

End

Public Function DeSelection(Optional elementos As String = "todo", Accion As String = "deseleccionar") As Integer
  ' Esta rutina analiza si los elemento seleccionados para alguna accion pueden realizarla, caso contrario los deselecciona
  ' se basa en los puntos que tengan la propiedad .Selected = True
  ' tambien puede deseleccionar todo
  ' Devuelve la cantidad de elementos que quedaron seleccionados despues de filtrar

  Dim i As Integer, c As Integer, Clase As String, iii As Integer

  ' por las dudas vengan alguna letra mayuscula
  If Accion = "" Then accion = "deseleccionar"
  accion = LCase(accion)
  elementos = LCase(elementos)

  '   primero vacio la seleccion anterior
  gcd.CurrentDrawing.oSelected.Clear

  For Each eTesting As Entity In gcd.CurrentDrawing.oEntities

    clase = eTesting.Gender

    Select Case accion

      Case "mover", "copiar", "borrar", "escalar" ' necesito que todos los puntos esten seleccionados

        If SelFull() And (elementos = "todo" Or elementos = clase) Then

          gcd.CurrentDrawing.oSelected.Add(eTesting, eTesting.handle)
          SelectElem(eTesting)
          Inc i

        Else

          DeSelectElem(eTesting)

        End If

      Case "estirar" ' necesito que dos puntos contiguos esten seleccionados

        If SelPArtial() And (elementos = "todo" Or elementos = clase) Then
          gcd.CurrentDrawing.oSelected.Add(eTesting, eTesting.handle)
          SelectElem(eTesting, False) ' dont touch the points
          Inc i

        Else

          DeSelectElem(eTesting)

        End If

      Case "deseleccionar" ' todas las acciones

        If (elementos = "todo" Or elementos = clase) Then

          Inc i
          DeSelectElem(eTesting)

        End If

    End Select

  Next

  Return i

End

Public Function GetSelectionCount() As Integer

  Dim e As Entity

  gcd.CurrentDrawing.oSelected.Clear
  For Each e In gcd.CurrentDrawing.oEntities
    If e.Selected Then

      gcd.CurrentDrawing.oSelected.Add(e, e.handle)
    End If
  Next
  Return gcd.CurrentDrawing.oSelected.Count

End Function

Public Function DeleteSelected() As Integer

  Dim E As Entity, c As Integer
  Dim lay As Layer

  '  Purgue will also delete those with .ForDeletion = true

  For Each E In gcd.CurrentDrawing.oEntities

    If E.Selected Then
      gcd.CurrentDrawing.oEntities.Remove(gcd.CurrentDrawing.oEntities.Key)
      Inc c
    End If

  Next

  '   we also need to regenerate the drawing list
  For Each lay In gcd.CurrentDrawing.oLayers
    If lay.Visible Then glGenDrawListLayers(lay)
  Next

  ' we also need too recalculate visible items
  Me.CollectVisibleEntities()

  ' TODO: put something in UNDO collection

  Return c

End Function

Public Function SelectFromPoint(Xr As Float, Zr As Float, Optional Autoselect As Boolean = True) As Entity

  Dim i As Integer

  For i = gcd.CurrentDrawing.oEntities To 0 Step -1
    ' last elements are drawn last so the click belongs to them
    If gcd.CurrentDrawing.oEntities[i].pointClick(Xr, Zr) Then
      If Autoselect Then
        If Not gcd.CurrentDrawing.oEntities[i].Selected Then
          SelectElem(gcd.CurrentDrawing.oEntities[i])
        Else
          DeSelectElem(gcd.CurrentDrawing.oEntities[i])
        End If
      End If
      Return gcd.CurrentDrawing.oEntities[i]
    End If

  Next

End

Public Sub DrawPoint(x As Float, y As Float, Optional colour As Integer = -1, Optional LargoReal As Float = 0.4)

  If colour <> -1 Then
    paint.brush = Paint.Color(colour)
  Else
    paint.brush = Paint.Color(Color.Blue)
  End If
  paint.LineWidth = 1
  paint.MoveTo(x - LargoReal / 2, y)
  paint.RelLineTo(LargoReal, 0)

  paint.MoveTo(x, y - LargoReal / 2)
  paint.RelLineTo(0, -LargoReal)
  paint.Stroke

End

Public Sub SelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

  Dim i, ii As Integer

  eEntity.selected = True
  If AndItsPoints Then
    For i = 0 To eEntity.Psel.Max
      eEntity.Psel[i] = True
    Next

  End If
  'End If

  ' Endif

End

Public Sub DeSelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

  ' deselect all points and myself

  Dim i, ii As Integer

  eEntity.selected = False
  If AndItsPoints Then
    For i = 0 To eEntity.Psel.Max
      eEntity.Psel[i] = False
    Next

  End If
  ' End If

  ' Endif

End

Public Sub CopyElemData(origen As Entity, destino As Entity)

  ' when adding stuff to the elements, it must be added here
  Dim i As Integer
  ' arrays
  destino.p.resize(origen.p.count)
  destino.fparam.resize(origen.fparam.count)
  destino.iparam.resize(origen.iparam.count)
  destino.psel.resize(origen.psel.count)
  destino.StringData.resize(origen.StringData.count)
  For i = 0 To origen.p.Max
    destino.P[i] = origen.P[i]
  Next
  For i = 0 To origen.fparam.Max
    destino.fparam[i] = origen.fparam[i]
  Next
  For i = 0 To origen.iparam.Max
    destino.iparam[i] = origen.iparam[i]
  Next
  For i = 0 To origen.StringData.Max
    destino.StringData[i] = origen.StringData[i]
  Next

  destino.Gender = origen.Gender
  destino.ClassHandler = origen.ClassHandler
  destino.pLayer = origen.pLayer
  destino.pBlock = origen.pBlock
  destino.Group = origen.Group
  destino.colour = origen.colour
  destino.LineType = origen.LineType
  destino.LineWidth = origen.LineWidth
  destino.Handle = origen.Handle
  destino.HandleOwner = origen.HandleOwner
  destino.pStyle = origen.pStyle

End

Public Sub Move(dX As Float, dY As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

  ' crea un backup de todos los puntos
  Dim e As Entity, i As Integer

  For Each e In gcd.CurrentDrawing.oEntities
    If (e.selected And OnlySelected) Or Not OnlySelected Then

      e.ClassHandler.Translate(e, dX, dY, OnlyPointSelected)

    Endif

  Next

End

Public Sub Rotate(degAngle As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

  ' crea un backup de todos los puntos
  Dim e As Entity, i As Integer

  For Each e In gcd.CurrentDrawing.oEntities
    If (e.selected And OnlySelected) Or Not OnlySelected Then

      e.ClassHandler.Rotate(e, degAngle)

    Endif

  Next

End

Public Sub Scale(sX As Float, sY As Float, Optional sZ As Float = 1, OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

  ' crea un backup de todos los puntos
  Dim e As Entity, i As Integer

  For Each e In gcd.CurrentDrawing.oEntities
    If (e.selected And OnlySelected) Or Not OnlySelected Then

      e.ClassHandler.Scale(e, sX, sY)

    Endif

  Next

End

Public Function SelectionSquare(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional NuevaSumaResta As String = "nueva", crossing As Boolean) As Integer

  ' Veo que accion estoy tomando
  Dim e As Entity, i, i2, TotalSeleccionados As Integer

  NuevaSumaResta = LCase$(NuevaSumaResta)

  If NuevaSumaResta = "nueva" Then ' nueva seleccion
    For Each e In gcd.CurrentDrawing.oEntities
      e.selected = False
      For i2 = 0 To e.Psel.max
        e.Psel[i2] = False
      Next
    Next
    TotalSeleccionados = 0
  End If

  For Each e In gcd.CurrentDrawing.oEntities
    ' cada entidad debe decidir si esta seleccionada o no
    If crossing Then
      If SelPArtial(e, X1real, Y1real, X2real, Y2real) Then
        ' el punto esta en el recuadro
        If NuevaSumaResta <> "resta" Then
          Inc TotalSeleccionados
          Me.SelectElem(e, False)

        Else If NuevaSumaResta = "resta" Then
          Dec TotalSeleccionados
          Me.DeSelectElem(e, False)

        End If

      Endif
    Else
      If SelFull(e, X1real, Y1real, X2real, Y2real) Then
        ' el punto esta en el recuadro
        If NuevaSumaResta <> "resta" Then
          Inc TotalSeleccionados
          Me.SelectElem(e, False)

        Else If NuevaSumaResta = "resta" Then
          Dec TotalSeleccionados
          Me.DeSelectElem(e, False)

        End If

      Endif

    End If
  Next
  GetSelectionCount()

  ' deprecada
  ' GetSelectionHandles(gcd.CurrentDrawing.hSelection)

  Return TotalSeleccionados

End

'' Put all visible entity refs in arrVisibleEntities[]
Public Function CollectVisibleEntities()

  Dim x0, y0, x1, y1 As Float
  Dim lay As Layer
  Dim e As Entity
  Dim i, tot As Integer

  x0 = gcd.Xreal(0)
  y1 = gcd.Yreal(0)                     ' el eje Y esta invertido en OpenGL
  x1 = gcd.Xreal(gcd.ScreenWidth())
  y0 = gcd.Yreal(gcd.ScreenHeight())

  'If gcd.CurrentDrawing.oEntities > gcd.CurrentDrawing.arrVisibleEntities.Max Then gcd.CurrentDrawing.arrVisibleEntities.Resize(gcd.CurrentDrawing.oEntities.Count)
  gcd.CurrentDrawing.oVisibleEntities.Clear
  For Each e In gcd.CurrentDrawing.oEntities
    If e.pLayer.Visible Then

      If SelPArtial(e, x0, y0, x1, y1) Then

        gcd.CurrentDrawing.oVisibleEntities.Add(e, e.Handle)

      End If
    End If
  Next

End

Public Function GetSelectionHandles(sHandles As String[]) As Integer

  Dim i As Integer
  Dim itotal As Integer

  Dim t As Float = Timer

  sHandles.Clear
  'sHandles.Resize
  For i = 0 To gcd.CurrentDrawing.oEntities
    If gcd.CurrentDrawing.oEntities[i].Selected Then
      sHandles.Add(gcd.CurrentDrawing.oEntities[i].Handle)
      Inc itotal
    End If
  Next
  Debug itotal, " en ", t - Timer, " seg"
  Return itotal

End

'Return bound limits for all verices in the array of entities
Public Sub BuildPoi(Optional entities As Collection, OnlyVisibles As Boolean = True)

  Dim e As Entity, i As Integer
  Dim entGroup As Collection

  If Not entities Then entGroup = gcd.CurrentDrawing.oEntities Else entGroup = Entities

  If entGroup.Count = 0 Then Return

  For Each e In entGroup
    If (OnlyVisibles And e.pLayer.Visible) Or Not OnlyVisibles Then
      e.ClassHandler.BuildPoi(e)
    End If
  Next

End
'Return bound limits for all verices in the array of entities

Public Function ComputeLimits(Optional entities As Collection, OnlyVisibles As Boolean = True) As Float[]

  Dim e As Entity, i As Integer
  Dim entGroup As Collection
  Dim Xmenor As Float = 1e10, Ymenor As Float = 1e10, Xmayor As Float = -1e10, Ymayor As Float = -1e10
  Dim newLimits As New Float[]
  Dim IsVisible As Boolean

  If Not entities Then entGroup = gcd.CurrentDrawing.oEntities Else entGroup = Entities

  If entGroup.Count = 0 Then Return Null

  For Each e In entGroup
    If OnlyVisibles Then
      If IsNull(e.pLayer) Then
        IsVisible = True
      Else
        IsVisible = e.pLayer.Visible
      End If

    Endif

    If IsVisible Then

      If e.Gender = "Insert" Then
        If IsNull(e.pBlock) Then Continue
        newLimits = ComputeLimits(e.pBlock.entities)
        If IsNull(newLimits) Then Continue
        puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
        puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
        puntos.Translate(newLimits, e.P[0], e.P[1])
        If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
        If ymenor > newLimits[1] Then ymenor = newLimits[1]
        If Xmayor < newLimits[2] Then Xmayor = newLimits[2]
        If Ymayor < newLimits[3] Then Ymayor = newLimits[3]
        'End If

      Else If e.Gender Like "DIM*" Then

        If IsNull(e.pBlock) Then Continue
        newLimits = ComputeLimits(e.pBlock.entities)
        If IsNull(newLimits) Then Continue
        'puntos.Translate(newLimits, e.P[0], e.P[1])
        'puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
        'puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
        If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
        If ymenor > newLimits[1] Then ymenor = newLimits[1]
        If Xmayor < newLimits[2] Then Xmayor = newLimits[2]
        If Ymayor < newLimits[3] Then Ymayor = newLimits[3]
        ' End If

      Else If e.Polygon.Count > 0 Then

        For i = 0 To e.Polygon.max Step 2
          'If e.p[i] > 0 Then Debug e.gender

          If e.Polygon[i] < Xmenor Then Xmenor = e.Polygon[i]

          If e.Polygon[i + 1] < Ymenor Then Ymenor = e.Polygon[i + 1]

          If e.Polygon[i] > Xmayor Then Xmayor = e.Polygon[i]

          If e.Polygon[i + 1] > Ymayor Then Ymayor = e.Polygon[i + 1]

        Next
      Else If e.PolyLine.Count > 0 Then

        For i = 0 To e.PolyLine.max Step 2
          'If e.p[i] > 0 Then Debug e.gender

          If e.PolyLine[i] < Xmenor Then Xmenor = e.PolyLine[i]

          If e.PolyLine[i + 1] < Ymenor Then Ymenor = e.PolyLine[i + 1]

          If e.PolyLine[i] > Xmayor Then Xmayor = e.PolyLine[i]

          If e.PolyLine[i + 1] > Ymayor Then Ymayor = e.PolyLine[i + 1]

        Next
      Else

        For i = 0 To e.p.max Step 2

          If i > e.P.Max - 1 Then Break
          'If e.p[i] > 0 Then Debug e.gender

          If e.p[i] < Xmenor Then Xmenor = e.p[i]

          If e.p[i + 1] < Ymenor Then Ymenor = e.p[i + 1]

          If e.p[i] > Xmayor Then Xmayor = e.p[i]

          If e.p[i + 1] > Ymayor Then Ymayor = e.p[i + 1]

        Next
      End If
    End If
    'If Xmenor < -60 Then Stop
    ' If Xmayor > 425 Then Stop

  Next

  Return [Xmenor, Ymenor, Xmayor, Ymayor]

End

'' Determines if the entity was selected by a rectanle surrounding al points
'' by default, if ALL points are selected, it can.
Public Function SelFull(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

  Dim ii As Integer, puedo As Boolean

  Select Case eTesting.Gender

    Case Else

      ' Si tengo un bounding poligon, entonces verifico que todos los puntos esten dentro
      If eTesting.Polygon.Count > 0 Then

        Return puntos.IsPoligonInsideRect(eTesting.Polygon, X1real, Y1real, X2real, Y2real)

      Else    ' no tengo un poligono, entonces verifico que todos los puntos definitorios de al entidad esten dentro

        puedo = True                     ' supongamos que puedo, por ahora
        For ii = 0 To eTesting.p.max Step 2
          If ii + 1 > eTesting.p.max Then Break
          If Not (eTesting.p[ii] >= X1real And eTesting.p[ii] <= X2real) And (eTesting.p[ii + 1] >= Y1real And eTesting.p[ii + 1] <= Y2real) Then
            puedo = False
          End If
        Next

        If puedo Then
          For ii = 0 To eTesting.PSel.Max
            eTesting.PSel[ii] = True
          Next

          Return True
        Else
          For ii = 0 To eTesting.PSel.Max
            eTesting.PSel[ii] = False
          Next

          Return False
        End If
      Endif
  End Select

End
'
' '' Determines if the entity
' '' by default, if ANY point is selected, it can.

Public Function SelPartial(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

  Dim ii As Integer, puedo As Boolean = False
  Dim oLoop As Boundary

  Select Case eTesting.Gender

    Case "Hatch"

      For Each oLoop In eTesting.pBlock.oBoundaryPath

        puedo = puntos.IsPoligonInsideRect(oLoop.Polyline, X1real, Y1real, X2real, Y2real)
        If puedo Then Break

        puedo = puntos.IsPoligonCrossingRect(oLoop.Polyline, X1real, Y1real, X2real, Y2real)
        If puedo Then Break
      Next

    Case Else

      ' Si tengo un bounding poligon, entonces verifico que alguna linea lo cruce
      puedo = puntos.IsPoligonCrossingRect(eTesting.Polygon, X1real, Y1real, X2real, Y2real)

      For Ii = 0 To eTesting.p.max Step 2
        If ii + 1 > eTesting.p.max Then Break
        If ii / 2 > eTesting.Psel.Max Then Break
        If (eTesting.p[iI] >= X1real And eTesting.p[Ii] <= X2real) And (eTesting.p[iI + 1] >= Y1real And eTesting.p[iI + 1] <= Y2real) Then
          eTesting.PSel[iI / 2] = True
          puedo = True
        End If
      Next

  End Select

  If puedo Then

    Return True
  Else
    Return False
  End If

End

' Public Function GetParentBlock(iEntity As Integer) As Integer
'
'     Dim iParent As Integer
'
'     iParent = iEntity
'     Do
'
'         If gcd.CurrDrawing.arrEntities[iParent].iInsert >= 0 Then
'             If iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert Then Break
'             iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert
'         Else
'             Break
'         End If
'
'     Loop
'
'     Return iParent
'
' End

'' Imports data from a collection to an entity. True if the entity is handled by m-designer at this version,
'' False if entity couldn't be created for some reason.
Public Function DXFImportToEntity(c As Collection, Optional IsDummy As Boolean = False) As Entity

  Dim clsHandler As Object
  Dim sClave As New String[]
  Dim sValue As New String[]
  Dim lpValue, lpclave As String
  Dim i As Integer
  Dim GotEntity As Boolean
  Dim e As Entity
  Dim LT As LType

  ' If Not c.Exist("entity") Then Return False
  ' If Not c "entity") Then Return False
  If IsDummy Then
    clsHandler = cadDummy
  Else
    clsHandler = Object.New("cad" & c[dxf.codEntity])  ' obtenemos el tipo de entidad y buscamos su clase. Si no manjemos esa entidad, esto de error.

  End If
  'GotEntity = True

  'Finally

  'If Not GotEntity Then Return False

  For Each lpValue In c
    lpclave = c.Key
    I = InStr(lpclave, "_")
    If i > 0 Then lpclave = Left(lpclave, i - 1)
    sClave.Add(lpclave)           ' el codigo es el tipo de variable
    sValue.Add(lpValue)

  Next
  e = clsHandler.newEntity()
  ' llenamos Common data:
  e.pLayer = GetLayerByName(c[dxf.codLayer])
  e.Handle = c[dxf.codHandle]

  ' for testing FIXME: ojo con esto!!!
  ' If e.handle <> "804AC" Then Return Null

  e.HandleOwner = c[dxf.codHandleOwner]
  Try e.colour = c[dxf.codColor]            ' no es obligatorio
  Try e.LineWidth = c[dxf.codLWht] / 100    ' por eso el try
  If e.LineWidth < 1 Then e.LineWidth = 1
  If c.Exist(dxf.codLType) Then
    LT = GetLTypeByName(c[dxf.codLType])
    If LT Then
      e.LineType = LT
    Else
      e.LineType = gcd.CurrentDrawing.oLTypes[gcd.CurrentDrawing.oLTypes.First]
    End If
  Else
    e.LineType = gcd.CurrentDrawing.oLTypes[gcd.CurrentDrawing.oLTypes.First]

  End If
  If clsHandler.ImportDXF(e, sClave, sValue) Then

    'If e.ClassHandler.gender <> "Hatch" Then e.ClassHandler.Finish(e)
    e.ClassHandler.Finish(e)

    Return e

  Else

    Return Null

  End If

  ' Catch
  'e.ClassHandler = cadDummy
  Return Null

End

Public Function GetEntityIndex(dDrawing As Drawing, sHandle As String, Optional iStart As Integer = 0) As Integer

  Dim i As Integer

  For i = iStart To dDrawing.oEntities

    If dDrawing.oEntities[i].Handle = sHandle Then Return i

  Next

  Return -1           ' no hay handle asociada a esa entidad

End

Public Sub DXFExportCommonCol(e As Entity, ByRef cExported As Collection)

  cExported.Add(UCase(e.Gender), dxf.codEntity)
  cExported.add(e.Handle, dxf.codHandle)
  cExported.add(e.HandleOwner, dxf.codHandleOwner)
  cExported.Add("AcDbEntity", "100_1")
  cExported.Add(e.pLayer.Name, dxf.codLayer)
  Try cExported.Add(e.LineType.Name, dxf.codLType)
  cExported.Add(e.colour, dxf.codColor)
  cExported.Add(CStr(e.LineWidth), dxf.codLWht)

End

'' Imports data from a collection to an entity. True if the entity is handled by GauchoCAD at this version,
'' False if entity couldn't be created for some reason.
Public Function ImportJsonToEntity(c As JSONCollection, Optional IsDummy As Boolean = False) As Entity

  Dim clsHandler As Object
  Dim e As Entity

  ' If Not c.Exist("entity") Then Return False
  ' If Not c "entity") Then Return False
  If IsDummy Then
    clsHandler = cadDummy
  Else
    clsHandler = Object.New("cad" & c["entity"])  ' obtenemos el tipo de entidad y buscamos su clase. Si no manjemos esa entidad, esto de error.

  End If

  e = clsHandler.newEntity() ' le pedimos a la clase que arme un objeto Entity para agregar al Drawing actual
  If clsHandler.ImportJSONCol(c, e) Then
    ' llenamos Common data:
    e.player = GetLayerByHandle(c["layer"][3])  ' busco el layer por nombre
    e.Handle = c["handle"][1]
    If e.pLayer = Null Then Stop

    ' =================================Color===========================
    ' el manejo del color no esta bien estandarizado por parte de libredwg y puede venir de diversas formas
    e.Colour = -1
    Try e.Colour = c["color"]
    If e.Colour = -1 Then
      If c["color"].Exist("index") Then
        e.Colour = c["color"]["index"]
      Else If c["color"].Exist("rgb") Then
        e.colour = e.pLayer.Colour
      Else
        e.Colour = 256  'by layer
      Endif
    End If
    '======================================================================
    e.LineWidth = c["linewt"] / 100
    If e.LineWidth < 1 Then e.LineWidth = 1
    e.LineType = GetLTypeByIndex(c["ltype_flags"])
    If Not e.LineType Then
      e.LineType = gcd.CurrentDrawing.oLTypes[gcd.CurrentDrawing.oLTypes.First]
    End If

    clsHandler.Finish(e)

    Return e

  Else

    Return Null

  End If

  'Catch
  'e.ClassHandler = cadDummy
  Return False

End

Public Function GetLTypeByName(sName As String) As LType

  Dim LT As LType

  For Each LT In gcd.currentDrawing.oLTYpes

    If LCase(LT.Name) = LCase(sname) Then Return LT

  Next

  Return Null

End

Public Function GetLTypeByIndex(sName As String) As LType

  Dim lt As LType

  For Each lt In gcd.CurrentDrawing.oLTypes

    If LCase(lt.Name) = LCase(sname) Then Return lt

  Next

  Return Null

End

Public Function GetLayerByHandle(sHandle As String) As Layer

  Dim Lay As Layer

  For Each Lay In gcd.CurrentDrawing.oLayers

    If Lay.handle = sHandle Then Return Lay
  Next
  Return Null

End

Public Function GetLayerByName(LayerName As String) As Layer

  Dim Lay As Layer

  For Each Lay In gcd.CurrentDrawing.oLayers

    If Lay.Name = LayerName Then Return Lay
  Next
  Return Null

End

'' Reads entities and fill arrLayers
Public Sub FillLayersWithEntities(oDrawing As Drawing)

  Dim hLay As Layer
  Dim e As Entity

  ' primero eliminamos lo q haya
  For Each hLay In oDrawing.oLayers
    hLay.Entities.Clear
  Next

  For Each e In oDrawing.oEntities
    'e.pLayer = CurrDrawing.arrLayers[gcd.FindLaIndex(e.pLayer)]
    e.pLayer.Entities.Add(e)
  Next
  ' Esto ya no es posible con Colecciones
  'currentDrawing.oVisibleEntities.Resize(CurrentDrawing.oEntities.Count)

End
