' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

Public Struct arrBlockSt
    name As String
    x As Float
    y As Float
    layer As String
    entities As Entity[]
End Struct

Public flgSearchingPOI As Boolean

Public Function FIndBlockID(BlockName As String) As Integer

    Dim i As Integer

    For i = 0 To APPMain.hFCAD.arrBlocks.Max
        If APPMain.hFCAD.arrBlocks[i].name = BlockName Then Return i
    Next
    Return -1

End

Public Function ReconstruirBloques() As Boolean

    ' busco bloques y coloco puntos de referencias

    ' Armamos los bolques, que extraemos de las entidades
    Dim i, i2 As Integer, PartesEncontradas As Boolean, iStart As Integer
    Dim t As Float = Timer

    Print "Recostruyendo bloques"

    For i = 0 To APPMain.hFCAD.arrEntities.Max
        clsDrawingAids.HelperTrabajo = ("Loading blocks ") & Format$(i / APPMain.hFCAD.arrEntities.Max, "0.00%")
        Wait 0.0001
        If APPMain.hFCAD.arrEntities[i].gender = "Block" Then
            Dim newBlock As New ArrBlockst
            newBlock.name = APPMain.hFCAD.arrEntities[i].block
            newBlock.x = APPMain.hFCAD.arrEntities[i].p[0]
            newBlock.y = APPMain.hFCAD.arrEntities[i].p[1]
            newBlock.entities = New Entity[]
            ' busco los objetos de este bloque y los reconstruyo
            For i2 = iStart To APPMain.hFCAD.arrEntities.max
                If APPMain.hFCAD.arrEntities[i2].block = newBlock.name And APPMain.hFCAD.arrEntities[i2].gender <> "Block" Then ' sin recursividad en bloques
                    If APPMain.hFCAD.arrEntities[i2].block = newBlock.name And APPMain.hFCAD.arrEntities[i2].gender <> "Insert" Then 'no quiero insertarme a mi mismo
                        PartesEncontradas = True
                        Dim o2 As Entity
                        o2 = ClonEntity(APPMain.hFCAD.arrEntities[i2])
                        CopyElemData(APPMain.hFCAD.arrEntities[i2], o2)
                        o2.finish(-1)
                        newBlock.entities.Add(o2)
                    End If
                Else
                    If PartesEncontradas Then ' estaba armando un bloque, pero ya termine porque esta entidad es otra cosa
                        PartesEncontradas = False
                        iStart = i2
                        Break
                    End If

                Endif
            Next
            APPMain.hFCAD.arrBlocks.Add(newBlock)
        End If
    Next

    Wait 0.001
    Debug "Reconstruccion finalizada en ", Str$(Timer - t)

End

Public Sub _new()

End

'' Busca un numero de bloque que no haya sido usado
'' Looks for a free block number
Public Sub GetFreeBlockNumber() As Integer

    Dim i, n As Integer = 1

    For i = 0 To APPMain.hFCAD.arrEntities.Max

        If APPMain.hFCAD.arrEntities[i].BlockNumber > n Then n = APPMain.hFCAD.arrEntities[i].BlockNumber + 1

    Next
    Return n

End

Public Sub FillEntity(o As Entity)

    '  ' lets add the points, if number of points is not determined (like a poli-line) at least we need one
    '  ' make all arrays acording to param list
    Dim n As Integer

    For n = 1 To Len(o.ClassHandler.ParamType)
        Select Case UCase(Mid(o.ClassHandler.ParamType, n, 1))
            Case "P"
                o.p.add(0)
                o.p.add(0)
                o.level.add(0)
                o.b.add(0)
                o.b.add(0)
                o.psel.add(0)
            Case "F", "A", "M", "L"
                o.fParam.Add(0)

            Case "T"

            Case "C"

        End Select

    Next

End

'' Creo el array de POI
'' son los puntos que van a enganchar el mouse

Public Sub ReBuildPOI()

    Dim i, ii, n As Integer, EPoi As New Integer[], nPois As Integer

    APPMain.hFCAD.poiEntities.Clear
    APPMain.hFCAD.poiLines.Clear
    APPMain.hFCAD.poiLinesEntities.Clear
    APPMain.hFCAD.poiPoints.Clear
    APPMain.hFCAD.poiPoligonElements.Clear
    APPMain.hFCAD.poiPoligonEntities.Clear
    APPMain.hFCAD.poiPoligons.Clear
    APPMain.hFCAD.poiPoligonStartIndex.Clear
    APPMain.hFCAD.poiType.Clear

    For i = 0 To APPMain.hFCAD.arrEntities.Max

        APPMain.hFCAD.arrEntities[i].ClassHandler.buildpoi(APPMain.hFCAD.arrEntities[i])

    Next

End

'' Veo si estoy sobre una entidad y la devuelvo
Fast Unsafe Public Function CheckAboveEntity(xr As Float, Yr As Float, tolerance As Float) As Entity

Dim rData As New Float[]
Dim e, i, iPoligon, iLine, iPoint As Integer

APPMain.hFCAD.iEntity.Clear

' For Each e In APPMain.hFCAD.arrEntities
For e = 0 To APPMain.hFCAD.arrEntities.Max      ' for each es 10 veces mas lento que recorrer el array
    ' Text, MText, Solid y otros
    If puntos.isInside(APPMain.hFCAD.arrEntities[e].Polygon, xr, yr) Then Return APPMain.hFCAD.arrEntities[e]

    Select Case APPMain.hFCAD.arrEntities[e].Gender

        Case "Line"

            If puntos.doIntersect(xr - tolerance, yr, xr + tolerance, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1], APPMain.hFCAD.arrEntities[e].P[2], APPMain.hFCAD.arrEntities[e].P[3]) Or puntos.doIntersect(xr, yr - tolerance, xr, yr + tolerance, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1], APPMain.hFCAD.arrEntities[e].P[2], APPMain.hFCAD.arrEntities[e].P[3]) Then Return APPMain.hFCAD.arrEntities[e]

        Case "PLine"

            For i = 0 To APPMain.hFCAD.arrEntities[e].P.count - 4 Step 2
                If puntos.doIntersect(xr - tolerance, Yr, Xr + tolerance, Yr, APPMain.hFCAD.arrEntities[e].P[i + 0], APPMain.hFCAD.arrEntities[e].P[i + 1], APPMain.hFCAD.arrEntities[e].P[i + 2], APPMain.hFCAD.arrEntities[e].P[i + 3]) Or puntos.doIntersect(xr, Yr - tolerance, Xr, Yr + tolerance, APPMain.hFCAD.arrEntities[e].P[i + 0], APPMain.hFCAD.arrEntities[e].P[i + 1], APPMain.hFCAD.arrEntities[e].P[i + 2], APPMain.hFCAD.arrEntities[e].P[i + 3]) Then Return APPMain.hFCAD.arrEntities[e]
            Next

        Case "Circle"

    End Select

Next

End

'' This is called by MouseMove events, so make sure its fast
'' and its called form there
Public Sub CheckPOI(xr As Float, Yr As Float)

    Dim rData As New Float[], e As Entity
    Dim i, iPoligon, iLine, iPoint As Integer
    Dim pend1, base1, pend2, base2 As Float ' vars para las ecuacionesde las rectas
    Dim puntoB, puntoA As New Float[]

    ' distancias  los enganches, para determinar cual es el mas cercano al puntero
    Dim DistPer As Float = 1e6
    Dim DistEnd1 As Float = 1e6
    Dim DistEnd2 As Float = 1e6
    Dim DistMid As Float = 1e6
    Dim DistBase As Float = 1e6
    Dim DistTang As Float = 1e6
    Dim DistQuad As Float = 1e6
    Dim DistCenter As Float = 1e6
    Dim Dist As Float = 1e7  ' el menor

    If Me.flgSearchingPOI Then Return   ' no nesting this
    Me.flgSearchingPOI = True

    APPMain.hFCAD.iEntity.Clear
    Dim t As Float = Timer
    'iPoligon = puntos.FindPOIPoligon(xr, yr, APPMain.hFCAD.poiPoligons, APPMain.hFCAD.poiPoligonStartIndex, APPMain.hFCAD.poiPoligonElements)
    'iLine = puntos.FindPOILines(xr, yr, APPMain.hFCAD.poiLines, APPMain.hFCAD.Metros(16))
    rdata = puntos.FindPOI(xr, yr, APPMain.hFCAD.poiPoints, APPMain.hFCAD.Metros(16))
    'Debug "total poi check time ", Timer - t, APPMain.hFCAD.poiPoligons.Count + APPMain.hFCAD.poiLines.Count + APPMain.hFCAD.poiPoints.Count, " points parsed"

    t = Timer
    e = CheckAboveEntity(xr, yr, APPMain.hFCAD.Metros(16))
    If e Then                                               ' ofrezco opciones de enganche

        If APPMain.hFCAD.LastPoint Then                     ' tengo un punto anterior

            Select Case e.Gender

                Case "Line"

                    ' perpendicular

                    If e.P[2] - e.P[0] <> 0 Then
                        pend1 = (e.P[3] - e.P[1]) / (e.P[2] - e.P[0])
                        base1 = e.P[1] - pend1 * e.P[0]                 ' Y = pend1 X + base1

                        ' ecuacion de la recta perpendicular que pasa por el punto anterior
                        pend2 = -1 / pend1
                        base2 = APPMain.hFCAD.LastPoint[1] - pend2 * APPMain.hFCAD.LastPoint[0]

                        ' necesito otro punto
                        If APPMain.hFCAD.LastPoint[0] <> 0 Then
                            puntoA.Add(0)
                            puntoA.Add(base2)
                        Else
                            puntoA.Add(1)
                            puntoA.Add(pend2 + base2)

                        End If

                        ' determino la interseccion de ambas
                        puntoB = puntos.lineLineIntersection(APPMain.hFCAD.LastPoint, puntoA, [e.P[0], e.P[1]], [e.P[2], e.P[3]])

                    Else        ' la recta es vertical

                        puntoB.Add(e.P[0])
                        puntoB.Add(APPMain.hFCAD.LastPoint[1])

                    End If

                    ' veo si el punto b esta entre los extremos de la linea , aunque deberia estarlo!!!
                    If puntos.onSegment(e.P[0], e.P[1], puntoB[0], puntoB[1], e.P[2], e.P[3]) Then

                        ' determino la distancia al puntero para ofrecerlo como opcion de enganche
                        DistPer = puntos.distancia(puntoB[0], puntoB[1], xr, yr)

                    Endif
            End Select
        End If

        Select Case e.Gender
            Case "Line"
                ' otros puntos
                DistEnd1 = puntos.distancia(e.P[0], e.P[1], xr, yr)

                DistEnd2 = puntos.distancia(e.P[2], e.P[3], xr, yr)

                DistMid = puntos.distancia((e.P[2] + e.P[0]) / 2, (e.P[3] + e.P[1]) / 2, xr, yr)

            Case "Text", "MText"

                DistBase = puntos.distancia(e.P[0], e.P[1], xr, yr)

            Case "Circle", "Ellipse", "Arc"

                DistCenter = puntos.distancia(e.P[0], e.P[1], xr, yr)

        End Select

        ' veo cual es la opcion mas cercana al puntero

        ' dist = Min(DistBase, DistCenter, DistEnd1, DistEnd2, DistMid, DistPer, DistQuad) ' NO FUNCIONA

        If Dist > DistBase Then dist = DistBase
        If Dist > DistCenter Then dist = DistCenter
        If Dist > DistEnd1 Then dist = DistEnd1
        If Dist > DistEnd2 Then dist = DistEnd2
        If Dist > DistMid Then dist = DistMid
        If Dist > DistPer Then dist = DistPer
        If Dist > DistQuad Then dist = DistQuad
        If Dist > DistTang Then dist = DistTang

        ' ofrezco ese punto
        If dist = DistEnd1 Then
            APPMain.hFCAD.iEntity.Insert([e.P[0], e.P[1], gcd.poiEndPoint])
            clsDrawingAids.Helper.texto = "EndPoint"
        End If

        ' ofrezco ese punto
        If dist = DistEnd2 Then
            APPMain.hFCAD.iEntity.Insert([e.P[2], e.P[3], gcd.poiEndPoint])
            clsDrawingAids.Helper.texto = "EndPoint"
        End If

        ' ofrezco ese punto
        If dist = DistMid Then
            APPMain.hFCAD.iEntity.Insert([(e.P[2] + e.P[0]) / 2, (e.P[3] + e.P[1]) / 2, gcd.poiMidPoint])
            clsDrawingAids.Helper.texto = "MidPoint"
        End If

        ' ofrezco ese punto
        If dist = DistPer Then
            APPMain.hFCAD.iEntity.Insert([puntoB[0], puntoB[1], gcd.poiPerpendicular])
            clsDrawingAids.Helper.texto = "Perpendicular"
        End If

        APPMain.hFCAD.oEntity = e
        If APPMain.hFCAD.iEntity.Count = 0 Then ' situacion no prevista aun
            clsDrawingAids.Helper.texto = ""
            APPMain.hFCAD.iEntity.Insert([0, 0, -1])
        End If

    Else
        clsDrawingAids.Helper.texto = ""
        APPMain.hFCAD.iEntity.Insert([0, 0, -1])

    End If
    Me.flgSearchingPOI = False

End

'' Borra la lista anterior y genera una nueva

Public Sub GLGenDrawList()

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer

    ' si esxite esta lista, la borro
    If Not gl.islist(APPMain.hFCAD.GlListAllEntities) Then APPMain.hFCAD.GlListAllEntities = gl.GenLists(1)
    modCAD.drwDrawingClass = modCAD.drwOpenGLClass
    gl.NewList(APPMain.hFCAD.GlListAllEntities, gl.COMPILE)

    For i = 0 To APPMain.hFCAD.arrEntities.Max

        APPMain.hFCAD.arrEntities[i].ClassHandler.Draw(APPMain.hFCAD.arrEntities[i])

    Next

    gl.EndList

End

'' Borra la lista anterior y genera una nueva

Public Sub GLGenDrawList2()

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer

    ' si esxite esta lista, la borro
    If Not gl.islist(APPMain.hFCAD.GlListAllEntities) Then APPMain.hFCAD.GlListAllEntities = gl.GenLists(1)
    Dim t As Float = Timer
    ' listas de entidades
    For i = 0 To APPMain.hFCAD.arrEntities.Max
        If Not gl.islist(APPMain.hFCAD.arrEntities[i].glDrwList) Then APPMain.hFCAD.arrEntities[i].glDrwList = gl.GenLists(1)
        gl.NewList(APPMain.hFCAD.arrEntities[i].glDrwList, gl.COMPILE)
        APPMain.hFCAD.arrEntities[i].ClassHandler.Draw(APPMain.hFCAD.arrEntities[i])
        gl.EndList

    Next
    Debug "GLlista de entidades generada en  ", Timer - t

    ' lista de entidaes seleccionadas
    For i = 0 To APPMain.hFCAD.arrEntities.Max
        If Not gl.islist(APPMain.hFCAD.arrEntities[i].glDrwListSel) Then APPMain.hFCAD.arrEntities[i].glDrwListSel = gl.GenLists(1)
        gl.NewList(APPMain.hFCAD.arrEntities[i].glDrwListSel, gl.COMPILE)
        APPMain.hFCAD.arrEntities[i].Selected = True
        APPMain.hFCAD.arrEntities[i].ClassHandler.Draw(APPMain.hFCAD.arrEntities[i])
        APPMain.hFCAD.arrEntities[i].Selected = False
        gl.EndList

    Next

    ' lista de todas las entidades
    t = Timer
    gl.NewList(APPMain.hFCAD.GlListAllEntities, gl.COMPILE)

    For i = 0 To APPMain.hFCAD.arrEntities.max

        gl.CallList(APPMain.hFCAD.arrEntities[i].glDrwList)

    Next

    gl.EndList
    Debug "GLlista de todas generada en  ", Timer - t

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub GLGenDrawListSel(Optional mode As Integer = 0)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer

    If Not gl.islist(APPMain.hFCAD.GlListSelectedEntities) Then APPMain.hFCAD.GlListSelectedEntities = gl.GenLists(1)

    gl.NewList(APPMain.hFCAD.GlListSelectedEntities, gl.COMPILE)

    For i = 0 To APPMain.hFCAD.arrEntities.Max

        If APPMain.hFCAD.arrEntities[i].Selected Then
            If mode = 0 Then gl.CallList(APPMain.hFCAD.arrEntities[i].glDrwListSel)
            If mode = 1 Then gl.CallList(APPMain.hFCAD.arrEntities[i].glDrwList)
        End If
    Next

    gl.EndList

End

Public Sub Finish(Optional selected As Boolean = True)

    ' creo copias de cada elemento seleccionado
    Dim m As Integer, i As Integer

    m = APPMain.hFCAD.arrEntities.Max
    For i = 0 To m
        If selected Then                                                    ' apply to only the selected ones
            If APPMain.hFCAD.arrEntities[i].Selected Then APPMain.hFCAD.arrEntities[i].ClassHandler.Finish(APPMain.hFCAD.arrEntities[i], -1)
        Else                                                                ' apply to all
            APPMain.hFCAD.arrEntities[i].ClassHandler.Finish(APPMain.hFCAD.arrEntities[i], -1)
        End If

    Next

End

Public Sub ClonElements(Optional selected As Boolean = True)

    ' creo copias de cada elemento seleccionado
    Dim m As Integer, i As Integer

    m = APPMain.hFCAD.arrEntities.Max
    For i = 0 To m
        If APPMain.hFCAD.arrEntities[i].Selected Then
            APPMain.hFCAD.arrEntities.Add(ClonEntity(APPMain.hFCAD.arrEntities[i]))

        End If
    Next

End

Public Sub ClonEntity(e As Entity) As Entity
    ' clona una entidad
    ' copia todos sus elementos
    ' llama a las rutinas de reconstruccion del contorno y de los POI

    Dim o As New Entity

    CopyElemData(e, o)                              ' copy important values
    o.ClassHandler.Finish(o, -1)                       ' do all good stuff, -1 means self check
    BackUpPosition(o)                               ' backup vertices

    Return o

End

'' Busca elementos seleccionados y arma un array nuevo con ellos, eliminandolos del anterior
Public Function SelectArrayMake() As Integer

End

Public Function DeSelection(Optional elementos As String = "todo", Accion As String = "deseleccionar") As Integer
    ' Esta rutina analiza si los elemento seleccionados para alguna accion pueden realizarla, caso contrario los deselecciona
    ' se basa en los puntos que tengan la propiedad .Selected = True
    ' tambien puede deseleccionar todo
    ' Devuelve la cantidad de elementos que quedaron seleccionados despues de filtrar

    Dim i As Integer, c As Integer, Clase As String, iii As Integer

    ' por las dudas vengan alguna letra mayuscula
    If Accion = "" Then accion = "deseleccionar"
    accion = LCase(accion)
    elementos = LCase(elementos)

    '   primero vacio la seleccion anterior
    APPMain.hFCAD.arrSelecIndex.Clear

    For iii = 0 To APPMain.hFCAD.arrEntities.Max

        clase = APPMain.hFCAD.arrEntities[iii].Gender

        Select Case accion

            Case "mover", "copiar", "borrar", "escalar" ' necesito que todos los puntos esten seleccionados

                If SelFull() And (elementos = "todo" Or elementos = clase) Then

                    APPMain.hFCAD.arrSelecIndex.Add(iii)
                    SelectElem(APPMain.hFCAD.arrEntities[iii])
                    Inc i

                Else

                    DeSelectElem(APPMain.hFCAD.arrEntities[iii])

                End If

            Case "estirar" ' necesito que dos puntos contiguos esten seleccionados

                If SelPArtial() And (elementos = "todo" Or elementos = clase) Then
                    APPMain.hFCAD.arrSelecIndex.Add(iii)
                    SelectElem(APPMain.hFCAD.arrEntities[iii], False) ' dont touch the points
                    Inc i

                Else

                    DeSelectElem(APPMain.hFCAD.arrEntities[iii])

                End If

            Case "deseleccionar" ' todas las acciones

                If (elementos = "todo" Or elementos = clase) Then

                    Inc i
                    DeSelectElem(APPMain.hFCAD.arrEntities[iii])

                End If

        End Select

    Next

    Return i

End

Public Function GetSelectionCount() As Integer

    Dim i, ii As Integer

    For i = 0 To APPMain.hFCAD.arrEntities.Max
        If APPMain.hFCAD.arrEntities[i].Selected Then Inc ii
    Next

    Return ii

End Function

Public Function DeleteSelected(Optional Purge As Boolean = True) As Integer

    Dim i As Integer, c As Integer

    '  Purgue will also delete those with .ForDeletion = true

    For i = APPMain.hFCAD.arrEntities.Max To 0 Step -1
        If APPMain.hFCAD.arrEntities[i].ForDeletion Or APPMain.hFCAD.arrEntities[i].Selected Then
            APPMain.hFCAD.arrEntities.Remove(i)
            Inc c
        End If
    Next

    Return c

End Function

Public Function SelectFromPoint(Xr As Float, Zr As Float, Optional Autoselect As Boolean = True) As Entity

    Dim i As Integer

    For i = APPMain.hFCAD.arrEntities.Max To 0 Step -1
        ' last elements are drawn last so the click belongs to them
        If APPMain.hFCAD.arrEntities[i].PointClick(Xr, Zr) Then
            If Autoselect Then
                If Not APPMain.hFCAD.arrEntities[i].Selected Then
                    SelectElem(APPMain.hFCAD.arrEntities[i])
                Else
                    DeSelectElem(APPMain.hFCAD.arrEntities[i])
                End If
            End If
            Return APPMain.hFCAD.arrEntities[i]
        End If

    Next

End

Public Sub DrawPoint(x As Float, y As Float, Optional colour As Integer = -1, Optional LargoReal As Float = 0.4)

    If colour <> -1 Then
        paint.brush = Paint.Color(colour)
    Else
        paint.brush = Paint.Color(Color.Blue)
    End If
    paint.LineWidth = 1
    paint.MoveTo(x - LargoReal / 2, y)
    paint.RelLineTo(LargoReal, 0)

    paint.MoveTo(x, y - LargoReal / 2)
    paint.RelLineTo(0, -LargoReal)
    paint.Stroke

End

Public Sub BackUpPosition(elem As Entity)

    Dim i As Integer

    For i = 0 To elem.P.Max
        elem.B[i] = elem.P[i]

    Next

End

Public Sub RestorePosition(elem As Entity)

    Dim i As Integer

    For i = 0 To elem.P.Max

        elem.P[i] = elem.B[i]
    Next

End

Public Sub SelectElem(elem As Entity, Optional AndItsPoints As Boolean = True)

    ' select all points and myself

    Dim i As Integer

    If AndItsPoints Then
        For i = 0 To elem.Psel.Max
            elem.Psel[i] = True
        Next

    End If
    elem.selected = True

    ' but, its part of a block?

    ' If elem.Block <> "" Then
    '
    '     SelectAllElemFromBlock(elem.Block)
    '
    ' Endif

End

Public Sub SelectAllElemFromBlock(iBlock As String, Optional AndItsPoints As Boolean = True)

    ' select all elements from a block

    Dim e As Entity

    For Each e In APPMain.hFCAD.arrEntities
        If e.Selected Then Continue

        If e.Block = iBlock Then
            SelectElem(e)
            If e.gender = "Block" Then

                ' FIXME: esto no funciona
                'SelectAllElemFromBlock(e.fParam[0]) ' recursively call up

            Endif

        End If

    Next

End

Public Sub DeSelectAllElemFromBlock(iBlock As String, Optional AndItsPoints As Boolean = True)

    ' select all elements from a block

    Dim e As Entity

    For Each e In APPMain.hFCAD.arrEntities
        If Not e.Selected Then Continue

        If e.Block = iBlock Then
            DeSelectElem(e)
            If e.gender = "Block" Then

                ' FIXME: esto no funciona
                'DeSelectAllElemFromBlock(e.fParam[0]) ' recursively call up

            Endif

        End If

    Next

End

Public Sub DeSelectElem(elem As Entity, Optional AndItsPoints As Boolean = True)

    Dim i As Integer

    If AndItsPoints Then
        For i = 0 To elem.Psel.Max
            elem.Psel[i] = False
        Next
    End If

    elem.selected = False
    ' but, its part of a block?
    ' FIXME: this works bad

    ' If elem.Block <> "" Then
    '
    '     DeSelectAllElemFromBlock(elem.Block)
    '
    ' Endif

End

Public Sub CopyElemData(origen As Entity, destino As Entity)

    ' when adding stuff to the elements, it must be added here
    Dim i As Integer

    destino.p.resize(origen.p.count)
    destino.fparam.resize(origen.fparam.count)
    destino.level.resize(origen.level.count)
    destino.b.resize(origen.b.count)
    destino.psel.resize(origen.psel.count)

    For i = 0 To origen.p.Max
        destino.P[i] = origen.P[i]
    Next
    For i = 0 To origen.level.Max
        destino.Level[i] = origen.Level[i]
    Next
    For i = 0 To origen.fparam.Max
        destino.fparam[i] = origen.fparam[i]
    Next
    destino.ClassHandler = origen.ClassHandler
    destino.layerID = origen.LayerID
    destino.RefPointX = origen.refpointX
    destino.RefPointY = origen.refpointY
    destino.stringdata = origen.Stringdata
    destino.Layer = origen.Layer
    destino.Group = origen.Group
    destino.colour = origen.colour
    destino.LineType = origen.LineType
    destino.LineWidth = origen.LineWidth

End

Public Function BackUp(Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False) As Integer

    Dim e As Entity, c, i As Integer

    For Each e In APPMain.hFCAD.arrEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then
            BackUpPosition(e)
        Endif

    Next
    Return c

End

Public Function Restore(Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False) As Integer

    ' restores to the position backups
    Dim e As Entity, c, i As Integer

    For Each e In APPMain.hFCAD.arrEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then
            RestorePosition(e)
        Endif

    Next
    Return c

End

Public Sub Move(dX As Float, dZ As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In APPMain.hFCAD.arrEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then
            For i = 0 To e.p.max Step 2

                If (e.Psel[i / 2] And OnlyPointSelected) Or Not OnlyPointSelected Then

                    e.P[i] += dx
                    e.p[i + 1] += dZ

                End If
            Next
        Endif

    Next

End

Public Sub MoveFromBackUp(dX As Float, dZ As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In APPMain.hFCAD.arrEntities
        If e.visible Then
            If (e.selected And OnlySelected) Or Not OnlySelected Then
                For i = 0 To e.p.max Step 2
                    If (e.Psel[i / 2] And OnlyPointSelected) Or Not OnlyPointSelected Then

                        e.P[i] = e.B[i] + dX
                        e.P[i + 1] = e.B[i + 1] + dZ

                    End If
                Next
            Endif
        End If
    Next

End

Public Function SelectionSquare(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional NuevaSumaResta As String = "nueva", crossing As Boolean) As Integer

    ' Veo que accion estoy tomando
    Dim e As Entity, i, i2, TotalSeleccionados As Integer

    NuevaSumaResta = LCase$(NuevaSumaResta)

    If NuevaSumaResta = "nueva" Then ' nueva seleccion
        For i = 0 To APPMain.hFCAD.arrEntities.Max
            APPMain.hFCAD.arrEntities[i].selected = False
            For i2 = 0 To APPMain.hFCAD.arrEntities[i].Psel.max
                APPMain.hFCAD.arrEntities[i].Psel[i2] = False
            Next
        Next
        TotalSeleccionados = 0
    End If

    For Each e In APPMain.hFCAD.arrEntities
        ' cada entidad debe decidir si esta seleccionada o no
        If crossing Then
            If SelPArtial(e, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(e, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(e, False)

                End If

            Endif
        Else
            If SelFull(e, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(e, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(e, False)

                End If

            Endif

        End If
    Next

    Return TotalSeleccionados

End

' Public Function SelectionSquare2(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional NuevaSumaResta As String = "nueva", crossing As Boolean) As Integer
'
'     ' Veo que accion estoy tomando
'     Dim e As Entity, i, i2, CurrentEntityIndex, TotalSeleccionados As Integer, Todos As Boolean
'     Dim t As Float = Timer
'
'     NuevaSumaResta = LCase$(NuevaSumaResta)
'
'     If NuevaSumaResta = "nueva" Then
'         For i = 0 To APPMain.hFCAD.arrEntities.Max
'             APPMain.hFCAD.arrEntities[i].selected = False
'             For i2 = 0 To APPMain.hFCAD.arrEntities[i].Psel.max
'                 APPMain.hFCAD.arrEntities[i].Psel[i2] = False
'             Next
'         Next
'     End If
'     Debug "Deselect time ", Timer - t
'
'     ' reviso los poligonos
'     For i = 0 To APPMain.hFCAD.poiPoligonEntities.Max
'
'         If crossing Then
'             If puntos.IsPoligonCrossingRect(APPMain.hFCAD.poiPoligons, X1real, Y1real, X2real, Y2real, APPMain.hFCAD.poiPoligonStartIndex[i], APPMain.hFCAD.poiPoligonElements[i]) Then
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[i].selected = True
'
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[i].selected = False
'
'                 End If
'
'             Endif
'         Else
'             If puntos.IsPoligonInsideRect(APPMain.hFCAD.poiPoligons, X1real, Y1real, X2real, Y2real, APPMain.hFCAD.poiPoligonStartIndex[i], APPMain.hFCAD.poiPoligonElements[i]) Then
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[i].selected = True
'
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[i].selected = False
'
'                 End If
'
'             Endif
'
'         End If
'     Next
'
'     ' reviso las lineas
'     If crossing Then
'         For i = 0 To APPMain.hFCAD.poiLines.Max Step 2                                                                                                  ' para cada punto
'             If puntos.InBetween(APPMain.hFCAD.poiLines[i], X1real, X2real) And puntos.InBetween(APPMain.hFCAD.poiLines[i + 1], Y1real, Y2real) Then     ' esta dentro
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].selected = True
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].Psel[APPMain.hFCAD.poiLinesRelPoint[i / 2]] = True
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].selected = False
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].Psel[APPMain.hFCAD.poiLinesRelPoint[i / 2]] = False
'
'                 End If
'
'             Endif
'
'         Next
'
'     Else    ' full selection
'         ' hago un crossing primero y luego me fijo si estan todos
'         For i = 0 To APPMain.hFCAD.poiLines.Max Step 2                                                                                                  ' para cada punto
'             If puntos.InBetween(APPMain.hFCAD.poiLines[i], X1real, X2real) And puntos.InBetween(APPMain.hFCAD.poiLines[i + 1], Y1real, Y2real) Then     ' esta dentro
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].selected = True
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].Psel[APPMain.hFCAD.poiLinesRelPoint[i / 2]] = True
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].selected = False
'                     APPMain.hFCAD.arrEntities[APPMain.hFCAD.poiLinesEntities[i / 4]].Psel[APPMain.hFCAD.poiLinesRelPoint[i / 2]] = False
'
'                 End If
'
'             Endif
'
'         Next
'
'         CurrentEntityIndex = 0
'         For i = 0 To APPMain.hFCAD.arrEntities.Max
'
'             If APPMain.hFCAD.arrEntities[i].Selected Then 'chequeo si todos estan seleccionados
'                 todos = True
'                 For i2 = 0 To APPMain.hFCAD.arrEntities[i].Psel.Max
'                     If APPMain.hFCAD.arrEntities[i].Psel = False Then
'                         todos = False
'                         Break
'                     Endif
'                 Next
'
'                 If (todos And NuevaSumaResta = "resta") Or Not todos Then
'                     Dec TotalSeleccionados
'                     APPMain.hFCAD.arrEntities[i].selected = False
'                     For i2 = 0 To APPMain.hFCAD.arrEntities[i].Psel.Max
'                         APPMain.hFCAD.arrEntities[i].Psel = False
'
'                     Next
'
'                 End If
'
'             Endif
'
'         Next
'
'     Endif
'
'     Return TotalSeleccionados
'
' End

Public Sub ComputeLimits()
    ' bound limits for all verices in current plant

    Dim e As Entity, i As Integer

    For Each e In APPMain.hFCAD.arrEntities
        If e.block = "" And e.visible Then
            For i = 0 To e.p.max Step 2
                'If e.p[i] > 0 Then Debug e.gender

                If e.p[i] < APPMain.hFCAD.Xmenor Then APPMain.hFCAD.Xmenor = e.p[i]

                If e.p[i + 1] < APPMain.hFCAD.Ymenor Then APPMain.hFCAD.Ymenor = e.p[i + 1]

                If e.p[i] > APPMain.hFCAD.Xmayor Then APPMain.hFCAD.Xmayor = e.p[i]

                If e.p[i + 1] > APPMain.hFCAD.Ymayor Then APPMain.hFCAD.Ymayor = e.p[i + 1]

            Next
            For i = 0 To e.Polygon.max Step 2
                'If e.p[i] > 0 Then Debug e.gender

                If e.Polygon[i] < APPMain.hFCAD.Xmenor Then APPMain.hFCAD.Xmenor = e.Polygon[i]

                If e.Polygon[i + 1] < APPMain.hFCAD.Ymenor Then APPMain.hFCAD.Ymenor = e.Polygon[i + 1]

                If e.Polygon[i] > APPMain.hFCAD.Xmayor Then APPMain.hFCAD.Xmayor = e.Polygon[i]

                If e.Polygon[i + 1] > APPMain.hFCAD.Ymayor Then APPMain.hFCAD.Ymayor = e.Polygon[i + 1]

            Next
        End If
    Next

End

'' Determines if the entity was selected by a rectanle surrounding al points
'' by default, if ALL points are selected, it can.
Public Function SelFull(oE As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim i As Integer, puedo As Boolean

    Select Case oe.Gender

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que todos los puntos esten dentro
            If oE.Polygon.Count > 0 Then

                Return puntos.IsPoligonInsideRect(oE.Polygon, X1real, Y1real, X2real, Y2real)

            Else    ' no tengo un poligono, entonces verifico que todos los puntos definitorios de al entidad esten dentro

                puedo = True                     ' supongamos que puedo, por ahora
                For i = 0 To oE.p.max Step 2
                    If Not (oE.p[i] >= X1real And oE.p[i] <= X2real) And (oE.p[i + 1] >= Y1real And oE.p[i + 1] <= Y2real) Then
                        puedo = False
                    End If
                Next

                If puedo Then
                    For i = 0 To oE.PSel.Max
                        oE.PSel[i] = True
                    Next

                    Return True
                Else
                    For i = 0 To oE.PSel.Max
                        oE.PSel[i] = False
                    Next

                    Return False
                End If
            Endif
    End Select

End
'
' '' Determines if the entity
' '' by default, if ANY point is selected, it can.

Public Function SelPartial(oE As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim i As Integer, puedo As Boolean

    Select Case oe.Gender

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que alguna linea lo cruce
            If oE.Polygon.Count > 0 Then

                Return puntos.IsPoligonCrossingRect(oE.Polygon, X1real, Y1real, X2real, Y2real)

            Else    ' no tengo un poligono, entonces verifico que todos los puntos definitorios de al entidad esten dentro

                puedo = False
                For i = 0 To oE.p.max Step 2
                    If (oE.p[i] >= X1real And oE.p[i] <= X2real) And (oE.p[i + 1] >= Y1real And oE.p[i + 1] <= Y2real) Then
                        oE.PSel[i / 2] = True
                        puedo = True
                    End If
                Next

                If puedo Then

                    Return True
                Else
                    Return False
                End If
            End If

    End Select

End
