' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
Inherits Caddimension

Public Const Gender As String = "Dimension_Aligned"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Insert a linear acotation")
Public Const ParamType As String = "PPR"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = "Start point;End point;extension"

Public Sub ExportDXFCol(e As Entity, ByRef cExport As Collection) As Boolean

  cadDimension.ExportDXFCol(e, cExport)

  ' sobreescribo el nombre de la entidad

  cExport.Add("AcDbAlignedDimension", "100")
  ' ===========================================================================
  cExport.Add(CStr(e.p[4]), dxf.codX3)                ' first def point
  cExport.Add(CStr(e.p[5]), dxf.codY3)
  cExport.Add("0", dxf.codz0)

  cExport.Add(CStr(e.p[6]), "14")                ' text att point
  cExport.Add(CStr(e.p[7]), "24")
  cExport.Add("0", "34")

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

  Dim i As Integer
  Dim AfterSubclassmarker As Boolean
  ' revisamos lo que viene del importador comun
  Me.pointDefPoint0.x = e.P[0]
  Me.pointDefPoint0.y = e.P[1]

  Me.pointTextMidPoint.x = e.P[2]
  Me.pointTextMidPoint.y = e.P[3]

  For i = 0 To sClaves.Max
    If sClaves[i] = "100" And sValues[i] = "AcDbAlignedDimension" Then AfterSubclassmarker = True
    If AfterSubclassmarker Then ' lo siguientes codigos
      ' If sClaves[i] = "12" Then pointBaselinePoint.x = CFloat(sValues[i])
      ' If sClaves[i] = "22" Then pointBaselinePoint.y = CFloat(sValues[i])

      If sClaves[i] = "13" Then Me.pointDefPoint1.x = CFloat(sValues[i])
      If sClaves[i] = "23" Then Me.pointDefPoint1.y = CFloat(sValues[i])

      If sClaves[i] = "14" Then Me.pointDefPoint2.x = CFloat(sValues[i])
      If sClaves[i] = "24" Then Me.pointDefPoint2.y = CFloat(sValues[i])

    End If

  Next

  ' ahora recosntruyo el bloque segun mis propios metodos
  e.P[0] = Me.pointDefPoint1.x
  e.P[1] = Me.pointDefPoint1.y

  e.P[2] = Me.pointDefPoint2.x
  e.P[3] = Me.pointDefPoint2.y

  e.P.Add(Me.pointTextMidPoint.x)
  e.P.Add(Me.pointTextMidPoint.y)

  e.fParam[cadDimension.ipaExtension] = -puntos.distancia(Me.pointDefPoint0.x, Me.pointDefPoint0.y, Me.pointDefPoint2.x, Me.pointDefPoint2.y)

  e.pBlock = Me.ReBuildBlock(e)

  Return True

  ' catch

  Return False

End

Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

  ' la linea solo recibe puntos

  If vParam[0] <> "point" Then Return False

  If Me.StepsDone = 0 Then
    Me.DimType = gcd.dimAligned

    eBuild.iParam.Resize(cadDimension.iTotalParams)
    eBuild.fParam.Resize(cadDimension.TotalParams)
    eBuild.StringData.Resize(cadDimension.sdaTotalParams) ' text, style
    eBuild.pStyle = gcd.CurrentDrawing.CurrDimStyle

    Try eBuild.P[0] = vParam[1]
    Try eBuild.P[1] = vParam[2]
    eBuild.P[2] = eBuild.P[0]
    eBuild.P[3] = eBuild.P[1]
    If definitive Then Return True
  Else If Me.StepsDone = 1 Then
    eBuild.DrawAble = True
    eBuild.Finished = True
    Try eBuild.P[2] = vParam[1]
    Try eBuild.P[3] = vParam[2]
    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then Return True
  Else If Me.StepsDone = 2 Then
    If vParam[0] = "point" Then  ' vino como un punto, entonces la calculo de otra manera

      ' return the angle from horizontal to us
      eBuild.fParam[cadDimension.ipaExtension] = -puntos.PointToLineDistance([vParam[1], vParam[2]], [eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]]) ' / puntos.distancia(eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]

    Else If vParam[0] = "float" Then  ' vino como un punto, entonces la calculo de otra manera
      eBuild.fParam[Me.ipaExtension] = vParam[1]

    End If

    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then
      'Stop
      Return True
    End If
  Endif

End

Public Sub ReBuildBlock(E As Entity, Optional Stage As Integer) As Block

  ' Stage lo uso para cuando estoy creando la dimension

  Dim d As Float, flxTextExt As Float[]
  Dim fRotXY As Float[]

  Dim newBlock As New Block
  Dim f1, f2 As New Float[]

  newBlock.entities = New Collection

  ' para definir este bloque necesito 6 entidades
  Dim eLineaPpal As Entity
  Dim eOblique1 As Entity       ' tambien pueden ser flechas Solid
  Dim eOblique2 As Entity
  Dim eExtension1 As Entity
  Dim eExtension2 As Entity
  Dim eDot1 As Entity
  Dim eDot2 As Entity
  Dim eText As Entity
  Dim ePoint2 As Entity

  ' vemos los estilos
  If E.fParam[Me.ipaStyleTextHeigth] > 0 Then Me.DimTextHeight = E.fParam[Me.ipaStyleTextHeigth] Else Me.DimTextHeight = E.pStyle.fTxtHeight_140
  If E.fParam[Me.ipaStyleArrowSize] > 0 Then Me.DimArrowSize = E.fParam[Me.ipaStyleArrowSize] Else Me.DimArrowSize = E.pStyle.fArrowSize_41
  Me.DimArrowWidth = Me.DimArrowSize / 3

  ' linea principal
  clsEntities.AddLine(newBlock.entities, [E.P[0], E.P[1], E.P[0] + E.P[6] - E.P[4], E.P[1] + E.P[5] - E.P[7]], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eLineaPpal = newBlock.entities.Last

  ' lineas de demarcacion
  clsEntities.AddLine(newBlock.entities, [0, Me.DimExtension, 0, -Me.DimExtension], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eExtension1 = newBlock.entities.Last

  clsEntities.AddLine(newBlock.entities, [0, Me.DimExtension, 0, -Me.DimExtension], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)

  eExtension2 = newBlock.entities.Last

  ' puntos base

  clsEntities.AddPoint(newBlock.entities, [E.P[6], E.P[7]], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)

  clsEntities.AddPoint(newBlock.entities, [E.P[8], E.P[9]], E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  ePoint2 = newBlock.entities.Last

  ' flechas

  f1.Insert([0, 0, Me.DimArrowSize, Me.DimArrowWidth, Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])
  f2.Insert([0, 0, -Me.DimArrowSize, Me.DimArrowWidth, -Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])

  clsEntities.Addsolid(newBlock.entities, f1, E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eOblique1 = newBlock.entities.Last

  clsEntities.Addsolid(newBlock.entities, f2, E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eOblique2 = newBlock.entities.Last

  ' texto

  clsEntities.AddMText(newBlock.entities, [0.0, 0.0, 0.0, 0.0], 0, Me.DimTextHeight, "0.00", E.colour, E.LineWidth, E.LineType.Index, E.pLayer)
  eText = newBlock.entities.Last
  eText.fParam[cadMText.ipaAttchmPoint] = E.iParam[cadDimension.iiiAtatchPoint]

  ' -> el bloque

  E.fParam[cadInsert.ipaEscX] = 1      ' ScaleX del inserto
  E.fParam[cadInsert.ipaEscY] = 1      ' ScaleY del inserto
  E.fParam[cadInsert.ipaEscZ] = 1      ' ScaleY del inserto

  E.Visible = True

  Return newBlock

  ' el largo de la linea principal viene dado por la distancia entre ambos puntos
  d = puntos.distancia(Me.pointDefPoint1.x, Me.pointDefPoint1.y, Me.pointDefPoint2.x, Me.pointDefPoint2.y)

  ' con este click calculo el angulo
  E.fParam[cadInsert.ipaRotacion] = Ang(Me.pointDefPoint2.x - Me.pointDefPoint1.x, Me.pointDefPoint2.y - Me.pointDefPoint1.y) * 180 / Pi

  ' la primer entidad del bloque es la linea principal
  eLineaPpal.P[0] = 0           ' X0
  eLineaPpal.P[1] = 0           ' Y0

  eLineaPpal.P[2] = d           ' X1
  eLineaPpal.P[3] = 0           ' Y1

  ePoint2.P[0] = d

  ' la segunda es la primer linea de demarcacion (sin cambios)
  ' eExtension1.P[0] = 0           ' X0
  ' eExtension1.P[1] = 0           ' Y0
  '
  ' eExtension1.P[2] = 0           ' X1
  ' eExtension1.P[3] = 0           ' Y1

  ' la tercera es la segunda linea de demarcacion
  eExtension2.P[0] = d           ' X0
  'eExtension2.P[1] = 0           ' Y0

  eExtension2.P[2] = d           ' X1
  'eExtension2.P[3] = 0           ' Y1

  ' el texto
  eText.StringData[cadMText.sdaText] = "\\A1;" & Format(d, Me.DimFormat)

  E.fParam[cadDimension.ipaRealMeasure] = d

  flxTextExt = glPlus.MTextExtends(eText.StringData[0], 0, 0, eText.fParam[1])

  ' la cuarta y quinta son las flechas , tengo que verificar si entran, o el texto
  If flxTextExt[2] * 1.1 > d Then                      ' no entra

    eOblique1.P[0] = d           ' X0
    eOblique1.P[2] = Me.DimArrowSize + d           ' X0
    eOblique1.P[4] = Me.DimArrowSize + d           ' X0
    eOblique1.P[6] = d           ' X0

    eOblique2.P[0] = 0           ' X0
    eOblique2.P[2] = -Me.DimArrowSize
    eOblique2.P[4] = -Me.DimArrowSize
    eOblique2.P[6] = 0           ' X0

    ' el texto va afuera
    eText.P[0] = d + Me.DimArrowSize / 2
    eText.P[1] = Me.DimArrowWidth

  Else                                                                ' entra
    eOblique1.P[0] = 0           ' X0
    eOblique1.P[2] = Me.DimArrowSize
    eOblique1.P[4] = Me.DimArrowSize
    eOblique1.P[6] = 0           ' X0

    eOblique2.P[0] = d           ' X0
    eOblique2.P[2] = -Me.DimArrowSize + d           ' X0
    eOblique2.P[4] = -Me.DimArrowSize + d           ' X0
    eOblique2.P[6] = d           ' X0

    ' el texto va adentro
    eText.P[0] = d / 2 - flxTextExt[2] / 2
    eText.P[1] = Me.DimArrowWidth

  End If

  Me.extension = E.fParam[cadDimension.ipaExtension]
  ' linea principal
  eLineaPpal.P[1] = Me.extension           ' Y0
  eLineaPpal.P[3] = Me.extension           ' Y1

  ' linea de demarcacion
  eExtension1.P[1] = Me.DimExtension + Me.extension           ' Y0
  eExtension1.P[3] = -Me.DimExtension + Me.extension           ' Y1

  ' segunda linea de demarcacion
  eExtension2.P[1] = Me.DimExtension + Me.extension           ' Y0
  eExtension2.P[3] = -Me.DimExtension + Me.extension           ' Y1

  ' texto
  eText.P[1] = Me.DimArrowWidth + Me.extension

  ' flechas
  eOblique1.P[1] = Me.extension           ' X0
  eOblique1.P[3] = Me.extension + Me.DimArrowWidth
  eOblique1.P[5] = Me.extension - Me.DimArrowWidth
  eOblique1.P[7] = Me.extension           ' X0

  eOblique2.P[1] = Me.extension           ' X0
  eOblique2.P[3] = Me.extension + Me.DimArrowWidth
  eOblique2.P[5] = Me.extension - Me.DimArrowWidth
  eOblique2.P[7] = Me.extension           ' X0

  ' End If
  Return newBlock

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  '    MANEJADO EN clsEntities
  '============================
  ' "entity": "DIMENSION_LINEAR",
  ' "index": 262,
  ' "type": 21,
  ' "handle": [0, 3226],
  ' "size": 123,
  ' "bitsize": 872,
  ' "_subclass": "AcDbEntity",
  ' "prev_entity": [12, 1, 164, 3062],
  ' "next_entity": [10, 2, 577, 3803],
  ' "layer": [5, 2, 1883, 1883],
  ' "preview_exists": 0,
  ' "entmode": 2,
  ' "nolinks": 0,
  ' "color": 256,
  ' "ltype_scale": 1.0,
  ' "ltype_flags": 0,
  ' "plotstyle_flags": 0,
  ' "invisible": 0,
  ' "linewt": 29,

  ' ===========================================================================================

  ' "_subclass": "AcDbDimension",
  ' "extrusion": [0.0, 0.0, 1.0],
  ' "text_midpt": [217.50000000000006, 85.76276491494264],
  ' "elevation": 0.0,
  ' "flag1": 10,
  ' "user_text": "",
  ' "text_rotation": 0.0,
  ' "horiz_dir": 0.0,
  ' "ins_scale": [1.0, 1.0, 1.0],
  ' "ins_rotation": 0.0,
  ' "attachment": 5,
  ' "lspace_style": 1,
  ' "lspace_factor": 1.0,
  ' "act_measurement": 384.99999999999989,
  ' "clone_ins_pt": [0.0, 0.0],
  ' "flag": 128,
  ' "_subclass": "AcDbAlignedDimension",
  ' "xline1_pt": [25.0000000000001, 10.0, 0.0],
  'e.P.Add(0)
  'e.P.Add(0)
  e.P.Add(c["xline1_pt"][0])
  e.P.Add(c["xline1_pt"][1])
  ' "xline2_pt": [410.0, 10.0, 0.0],
  e.P.Add(c["xline2_pt"][0])
  e.P.Add(c["xline2_pt"][1])

  ' "def_pt": [410.0, 85.76276491494264, 0.0],
  ' "oblique_angle": 0.0,

  ' "dim_rotation": 0.0,
  e.fParam[Me.ipaEscX] = 1
  e.fParam[Me.ipaEscY] = 1
  e.fParam[Me.ipaEscZ] = 1

  'e.fParam[Me.ipaRotacion] = CFloat(c["dim_rotation"]) * 180 / Pi
  ' "_subclass": "AcDbRotatedDimension",
  ' "dimstyle": [5, 1, 57, 57],
  Dim hBlock As Integer

  Try e.Block = gcd.CurrentDrawing.cmodel["BLOCKS"][c["block"][3]]["block_entity"][3]
  e.pBlock = ReBuildBlock(e)
  'e.Block = gcd.CurrentDrawing.arrBlocks[clsEntities.FIndBlockIDbyHandle(hBlock)].name
  ' "block": [5, 2, 3228, 3228] '  esto apunta a cModel["BLOCKS"] , pero hay q buscar otra cosa

  Return True

Catch

  Return False

End
