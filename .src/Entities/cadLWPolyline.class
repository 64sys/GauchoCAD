' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
' Fast
Inherits EntityBase

Public Const Gender As String = "LWPolyline"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("LWPolyline")
Public Const ParamType As String = "P+"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = ("Next Point")      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = "Close/Undo"

Public Const totalpoints As Integer = 1
' iParam helpers
Public Const iTotalParams As Integer = 2
Public Const iiiPolylineClosed As Integer = 0
Public Const iiiBulged As Integer = 1

' The entity handler receives a user action, and returns the number of expected parameter
' If definitive = true, means the parameter is set
Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

  If vParam[0] = "point" Then

    eBuild.P[eBuild.P.Max - 1] = vParam[1]
    eBuild.P[eBuild.P.Max] = vParam[2]

    If definitive Then
      eBuild.P.Insert(eBuild.P.Copy(eBuild.P.Max - 1, 2))
      Return True
    End If
  Else If vParam[0] = "close" Then
    If eBuild.P.Count > 4 Then eBuild.P.Remove(eBuild.P.Max - 1, 2)
    eBuild.iParam[0] = 1
    Return True

  Else If vParam[0] = "undo" Then
    If eBuild.P.Count > 4 Then eBuild.P.Remove(eBuild.P.Max - 1, 2)
    eBuild.iParam[0] = 0
    Return True

  Endif

End

Public Sub Draw(oE As Entity)

  If Not oE.Visible Then Return

  ' version con bulges
  Dim ang1, mx, my, B, bx, by, Lt As Float
  Dim i As Integer
  Dim fArcParams As Float[]

  If oe.iParam[Me.iiiBulged] Then
    For i = 0 To oe.P.Count / 2 - 2

      ' no todos los tramos pueden tener bulges
      If Abs(oe.fParam[i]) > 0.001 Then
        ang1 = Ang(oe.P[(i + 1) * 2] - oe.P[i * 2], oe.P[(i + 1) * 2 + 1] - oe.P[i * 2 + 1])    ' angulo del tramo
        Lt = puntos.distancia(oe.P[i * 2], oe.P[i * 2 + 1], oe.P[(i + 1) * 2], oe.P[(i + 1) * 2 + 1])
        If Lt = 0 Then Continue
        mx = (oe.P[(i + 1) * 2] + oe.P[i * 2]) / 2          ' punto medio del tramo
        my = (oe.P[(i + 1) * 2 + 1] + oe.P[i * 2 + 1]) / 2
        B = oe.fParam[i] * Lt / 2
        bx = mx + B * Sin(ang1)                             ' Tercer punto del Bulge
        by = my - B * Cos(ang1)

        ' gl.PointSize(2)
        ' gl.Begin(gl.POINTS)
        ' gl.Vertex2f(oe.P[i * 2], oe.P[i * 2 + 1])
        ' gl.Vertex2f(bx, by)
        ' gl.Vertex2f(oe.P[(i + 1) * 2], oe.P[(i + 1) * 2 + 1])

        ' aqui podria usar una rutina de arco entre 3 puntos
        fArcParams = puntos.Arc3Point(oe.P[i * 2], oe.P[i * 2 + 1], bx, by, oe.P[(i + 1) * 2], oe.P[(i + 1) * 2 + 1])
        ' traslado el centro

        ' gl.Vertex2f(fArcParams[0], fArcParams[1])
        ' gl.End
        gl.Translatef(fArcParams[0], fArcParams[1], 0)

        ' verifico Start_Angle y End_Angle (esta parte esta intimamente ligada a Arc3Point)
        ' las combinaciones de angulos son diversas, Arc3Point puede no funcionar bien en otra circunstancia

        If fArcParams[3] > 0 And fArcParams[4] > 0 Then

        Else If fArcParams[3] > 0 And fArcParams[4] < 0 Then

          Swap fArcParams[3], fArcParams[4]
          ' fArcParams[4] += 2 * Pi
          '
          ' fArcParams[3] = 0
          ' fArcParams[4] = 0

        Else If fArcParams[3] < 0 And fArcParams[4] < 0 Then
          fArcParams[3] += 2 * Pi
          fArcParams[4] += 2 * Pi

        Else If fArcParams[3] < 0 And fArcParams[4] > 0 Then
          fArcParams[3] += 2 * Pi

        Endif

        If fArcParams[3] > fArcParams[4] Then Swap fArcParams[3], fArcParams[4]

        'Debug fArcParams[3], fArcParams[4]
        'If fArcParams[3] > fArcParams[4] Then Stop
        glPlus.Arc(fArcParams[2], fArcParams[3], fArcParams[4] - fArcParams[3], gcd.GetGBColor(oE.Colour, oe.pLayer), oE.LineWidth, oe.linetype.Index)
        gl.Translatef(-fArcParams[0], -fArcParams[1], 0)
        fArcParams = Null

      Else    ' dibujo la linea normalmente

        glPlus.Lines([oe.P[i * 2], oe.P[i * 2 + 1], oe.P[(i + 1) * 2], oe.P[(i + 1) * 2 + 1]], gcd.GetGBColor(oE.Colour, oe.pLayer), oE.LineWidth, oe.linetype.Index)
      End If

    Next
  Else

    GLplus.PolyLines(oE.p, gcd.GetGBColor(oE.Colour, oe.pLayer), oE.LineWidth, oe.linetype.Index, oe.iParam[Me.iiiPolylineClosed])

  End If

End

Public Sub DrawSelected(oE As Entity)

  GLplus.PolyLines(oE.P, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed, oe.iParam[Me.iiiPolylineClosed])
  GLplus.PolyLines(oE.P, gcd.ColorForSelected, oE.LineWidth, oE.LineType.Index, oe.iParam[Me.iiiPolylineClosed])

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

  If Not oE.Visible Then Return

  '  GLplus.PolyLines(oE.p, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
  '  GLplus.PolyLines(oE.p, gcd.GetGBColor(oE.Colour, oe.pLayer),oE.LineWidth + 2, oE.LineType)
  If oe.Selected Then
    GLplus.PolyLines(oE.P, gcd.flgWindowBackColor, oE.LineWidth + 2, gcd.stiDashed)
    GLplus.PolyLines(oE.P, gcd.ColorForSelected, oE.LineWidth + 2, oe.linetype.index)
  Else
    GLplus.PolyLines(oE.P, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
    GLplus.PolyLines(oE.P, gcd.GetGBColor(oE.Colour, oe.pLayer), oE.LineWidth + 2, oe.linetype.index)
  Endif

End

Public Function Draw2(oE As Entity)

  Dim i As Integer

  If gcd.UseCairo Then

    cairo.moveto(oe.P[0], oe.P[1])
    For i = 2 To oe.P.Max Step 2
      Cairo.lineto(oe.P[i], oe.P[i + 1])

    Next

    cairo.Stroke
  Else

    paintPlus.Lines(oE.p)
  End If

End
'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity) As Integer

  ' si este valor no es provisto , estos POI son de la ultima entidad
  Dim i As Integer

  oe.PoiPoints.Clear
  oe.PoiType.Clear

  oe.poiPoints.insert([oE.P[0], oE.P[1]])
  oe.poiType.Add(gcd.poiEndPoint)
  'oe.poiEntities.Add(arrIndex)

  For i = 0 To oE.P.count - 4 Step 2

    oe.poiPoints.insert([(oE.P[i + 0] + oE.P[i + 2]) / 2, (oE.P[i + 1] + oE.P[i + 3]) / 2])   ' mid
    oe.poiType.Add(gcd.poiMidPoint)
    'oe.poiEntities.Add(arrIndex)

    oe.poiPoints.insert([oE.P[i + 2], oE.P[i + 3]])
    oe.poiType.Add(gcd.poiEndPoint)
    'oe.poiEntities.Add(arrIndex)

    ' line
    'gcd.CurrDrawing.poiLines.insert([oE.p[i], oE.p[i + 1], oE.p[i + 2], oE.p[i + 3]])
    'gcd.CurrDrawing.poiLinesEntities.Add(arrIndex)
    ' gcd.CurrDrawing.poiLinesRelPoint.Insert([i / 2, i / 2 + 1])

  Next

End

' This function will return False if the element couldn't be created for some reason: bad or incomple user input
' True means all is good, False will instruct the clsEntityBuilder to delete it
Public Sub Finish(oE As Entity) As Boolean

  'Print "Finish en EntityBase"
  'CreatePolygon(oe)

  If oe.fParam.Count = 0 Then oe.fParam.Add(0)
  '  BuildPOI(oe)

  ' busco el tipo de linea, si hace falta

  ' tareas finales de armado del objeto

  oE.psel.resize(oE.p.count / 2)

  oE.Selected = False

End

Public Sub ExportDXFCol(e As Entity, ByRef cExport As Collection) As Boolean

  Dim i, IMAX As Integer

  cExport.Add("LWPOLYLINE", dxf.codEntity)
  clsEntities.DXFExportCommonCol(e, cExport)
  cExport.Add("AcDbPolyline", "100")
  cExport.Add(e.P.Count / 2, "90")              ' n puntos
  cExport.Add(CStr(e.iParam[Me.iiiPolylineClosed]), "70")      ' abierta =1 o cerrada =0
  cExport.Add("0", "43")
  imax = e.P.max
  If e.iParam[Me.iiiPolylineClosed] Then imax -= 2
  For i = 0 To e.p.Max Step 2
    cExport.Add(CStr(e.p[i]), dxf.codX0 & "_" & CStr(i / 2))
    cExport.Add(CStr(e.p[i + 1]), dxf.codY0 & "_" & CStr(i / 2))

    If i / 2 <= e.fParam.max Then cExport.Add(CStr(e.fParam[i / 2]), "42" & "_" & CStr(i / 2))
  Next

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

  Dim i As Integer
  Dim FirstBulge As Boolean
  Dim NewTrame As Boolean
  Dim BulgeAdded As Boolean

  e.P.Clear
  For i = 0 To sClaves.Max

    'If sClaves[i] = "90" Then mPolyLine.vertexcount = Val(sValues[i])
    'If sClaves[i] = "70" Then e.fParam[Me.ipaPolylineClosed] = CInt(sValues[i])       ' 0 = abierta, 1 = cerrada
    If sClaves[i] = "70" Then e.iParam[Me.iiiPolylineClosed] = CInt(sValues[i])        ' 0 = abierta, 1 = cerrada
    If sClaves[i] = "10" Then
      e.p.Add(CFloat(sValues[i]))

      e.fParam.Add(0) ' faux bulge

    End If
    If sClaves[i] = "20" Then e.p.Add(CFloat(sValues[i]))

    If sClaves[i] = "42" Then
      e.iParam[Me.iiiBulged] = 1
      e.fParam[E.fParam.Max] = CFloat(sValues[i])

    End If
  Next

  If e.iParam[Me.iiiPolylineClosed] And e.p.Count > 0 Then ' agrego el primer punto de nuevo
    e.p.Add(e.p[0])
    e.p.Add(e.p[1])
  End If

  Return True

  ' catch

  Return False

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  Dim i As Integer

  e.P.Clear
  For i = 0 To c["points"].Max
    e.P.Add(c["points"][i][0])
    e.P.Add(c["points"][i][1])
  Next

  e.fParam.Clear
  For i = 0 To c["bulges"].Max
    e.fParam.Add(c["bulges"][i])

  Next

  ' FIXME: esto indica si es abierta o cerrada
  If c["flag"] > 0 Then e.iParam[Me.iiiPolylineClosed] = 1

  If e.iParam[Me.iiiPolylineClosed] And e.p.Count > 0 Then ' agrego el primer punto de nuevo
    e.p.Add(e.p[0])
    e.p.Add(e.p[1])
  End If

  If e.fParam.Count > 0 Then e.iParam[Me.iiiBulged] = 1

  Return True

  'Catch

  Return False

End
' "entity": "LWPOLYLINE",
' "index": 400,
' "type": 77,
' "handle": [0, 254701],
' "size": 58,
' "bitsize": 414,
' "ownerhandle": [12, 1, 8, 254693],
' "_subclass": "AcDbEntity",
' "layer": [5, 2, 16846, 16846],
' "preview_exists": 0,
' "entmode": 0,
' "nolinks": 1,
' "color": 256,
' "ltype_scale": 1.0,
' "ltype_flags": 0,
' "plotstyle_flags": 0,
' "invisible": 0,
' "linewt": 29,
' "_subclass": "AcDbPolyline",
' "flag": 4,
' "const_width": 0.00545454545455,
' "points": [
'   [2914.77910786460507, 1640.5656862246592],
'   [2914.81866147450319, 1640.5261326147629]
' ],
' "bulges": [ el panceado de la polilinea, se usan en las nubes de revision por ejemplo,
' es una lista de valores Float, uno por vertice
