' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

' Pixeles
Public Const Gender As String = "Builder"
Public LastMouseDownX As Integer    ' change in MouseDown
Public LastMouseDownY As Integer
Public SelStartX As Integer         ' change in MouseDown
Public SelStartY As Integer
Public SelEndX As Integer           ' change in MouseMove/MouseUp
Public SelEndY As Integer

' Metros
Public SelStartXr As Float          ' Seleccion libre rectangular
Public SelStartZr As Float          ' en metros
Public SelEndXr As Float            ' aca Y es Z
Public SelEndZr As Float

' indicadores
'Public elem.ClassHandler.StepsDone As Integer = 0          ' La cantidad de puntos que marco para el trabajo actual--->Gurdado en la entidad
Public StepsTotal As Integer = 0          ' Tomado de la lista de tipo de paramtros
Public PointsTotal As Integer = 0          ' Tomado de la lista de tipo de paramtros
Public NextParamType As String          ' What kind of input the element expects P=point, F=float, C=color, S=string, M=mixed either Point, or Float that is taken from Max(Px-Px', Pz-Pz')
Public ParamHelperList As String[]
Public ParamDefault As String[]

' indices de valores ingresados
Public iPoints As Integer
Public iFloat As Integer
Public iString As Integer

' conserva los ultimos valores del mouse
Public CursorX As Integer
Public CursorY As Integer

Public elem As Entity
Public PoiChecking As Boolean = True
Public EntityChecking As Boolean = False
Public LastEntity As Entity

Public XYreal As Float[]

Public Function Start(Optional ElemToBuild As Variant, Optional Mode As Integer = 0)

  ' Parameters that we can process

  ' P point x,y
  ' + add a point every time, used like this "P+"
  ' F float, text entered (mouse is ignored)
  ' T text
  ' A angle, can be given by mouse or text
  ' L distance, idem
  ' R Float or distance to a perpendicular to a line from las 2 points
  ' M Mixed data

  ' TODO: implement
  ' C color, can be given by typing the color

  ' B boolean yes/no si/no
  ' D date

  ' limpiamos la seleccion
  clsEntities.DeSelection()

  clsEntities.GLGenDrawListSel(0)

  ' Verify if its a valid class to build
  If TypeOf(ElemToBuild) <> gb.Object Then                                            ' not Entity class given

    If LastEntity Then                                            ' we know the last element, try to create a new one
      elem = New Entity
      elem.ClassHandler = LastEntity.ClassHandler
      elem.Gender = elem.ClassHandler.Gender

    Else                                                                            ' the is no way to know what element was done last

      clsDrawingAids.ErrorMessage = ("Can't create entity")
      gcd.clsJob = clsDefaultJob                                               ' back to select mode
      gcd.clsJobPrevious = clsDefaultJob
      Return

    End If

  Else                                                                                ' Valid entity
    ' start building the element
    elem = New Entity
    elem.ClassHandler = elemtobuild
    elem.Gender = elem.ClassHandler.Gender
  End If

  clsEntities.FillEntity(elem)
  ' reset from previous element
  elem.ClassHandler.StepsDone = 0

  'elem.gbcolor = appmain.CurrentColor

  iPoints = 0
  iFloat = 0
  iString = 0

  Pointstotal = elem.p.count / 2                                          ' at this point P is either set or 0 if non determined
  StepsTotal = Len(elem.ClassHandler.ParamType)

  ' get the helper list, and parameter types from the element
  Try Paramhelperlist = Split(elem.ClassHandler.ParamHelper, ";")                      ' optional
  Try Paramdefault = Split(elem.ClassHandler.ParamDefault, ";")                        ' optional

  NextParamType = UCase(Mid(elem.ClassHandler.ParamType, elem.ClassHandler.StepsDone + 1, 1))
  clsDrawingAids.HelperTrabajoNext = ParamHelperList[0]

  ' instructions to FCAD
  gcd.OrthogonalIgnored = elem.ClassHandler.OrthogonalIgnored
  gcd.OrthogonalForced = elem.ClassHandler.OrthogonalForced

  elem.layerid = appmain.CurrentLayer ' gcd.GetLayerID(appmain.CurrentLayer)

  elem.colour = appmain.CurrentColor
  elem.ColorToPaint = Starter.gColor[elem.colour]

  elem.LineType = appmain.CurrentLtype

  elem.LineWidth = appmain.CurrentWidth

  clsDrawingAids.HelperTrabajo = elem.ClassHandler.HelperTrabajo

End

Public Function KeyText(EnteredText As String) ' esta rutina es llamada por FCAD en el evento FCAD_KeyPress cuando recibe una texto + <Enter>


  ' Lets see what are we expecting
  Dim Xt, Zt As Float, ErrTxt As String, Relative As Boolean

  Select NextParamType

    Case "P", "+"
      errtxt = ", expected a valid point like 12.4,9.5  or @12.34,10.5"
      ' lets filter
      EnteredText = Trim$(UCase$(EnteredText))
      ' So we expect a position x,y , but in some cases it can be
      ' C = close
      ' U = undo, delete last segment
      ' and others

      If Left(EnteredText, 1) = "C" Then          ' close the element
        ' got othe first point and exit
        elem.P[iPoints * 2] = elem.P[0]
        elem.P[iPoints * 2 + 1] = elem.P[1]
        Me.Finish

      Else If Left(EnteredText, 1) = "U" Then     ' undo last command and go

        elem.P.remove(elem.P.max)
        elem.P.remove(elem.P.max)
        Me.Finish
      Else                                        ' an X,Y or @X,Y

        If InStr(EnteredText, "@") > 0 Then    ' may be a point
          Relative = True
          EnteredText = Replace(EnteredText, "@", "")
        Endif
        Xt = CFloat(Split(EnteredText, ",")[0])
        Zt = CFloat(Split(EnteredText, ",")[1])

        ' if we are stll here, input was good
        elem.P[iPoints * 2] = Xt
        elem.P[iPoints * 2 + 1] = Zt

        If Relative And (elem.P.count > 2) Then
          elem.P[iPoints * 2] += elem.P[(iPoints - 1) * 2]
          elem.P[iPoints * 2 + 1] += elem.P[(iPoints - 1) * 2 + 1]

        Endif
        Inc iPoints
        AdvanceStep

      End If

    Case "T"
      errtxt = ", expected text, not a point"
      ' its a valid input?
      If EnteredText = "" Then

        'elem.stringdata[0] = EnteredText
        elem.stringdata[0] &= ParamDefault[elem.ClassHandler.StepsDone]
      Else If elem.stringdata[0] <> "" Then                      ' we have a previous entry

        elem.stringdata[0] &= "|" & EnteredText  ' split if necessary

      Else

        elem.stringdata[0] &= EnteredText                      ' first entry

      End If

      AdvanceStep

    Case "F", "M", "A", "L"                 ' Float, Mixed, Angle, Longitud
      errtxt = "enter a valid text size"

      If EnteredText = "" Then

        Try elem.fParam[iFloat] = ParamDefault[elem.ClassHandler.StepsDone]

      Else

        elem.fParam[iFloat] = CFloat(EnteredText)

      Endif

      Inc iFloat
      AdvanceStep

    Case "R"

      If EnteredText = "" Then

        Try elem.fParam[iFloat] = ParamDefault[elem.ClassHandler.StepsDone]

      Else

        elem.fParam[iFloat] = CFloat(EnteredText)

      Endif

      Inc iFloat
      AdvanceStep

    Case "C"                                ' color
      If Dialog.SelectColor() Then
        elem.fParam[iFloat] = CFloat(Dialog.Color)
        Inc iFloat
        AdvanceStep

      Endif
      Key.Cod

  End Select

Finally

  Return

Catch

  ' unexpected input
  clsDrawingAids.ErrorMessage = ("Bad input" & ErrTxt)

End

Public Sub AdvanceStep()

  Inc elem.ClassHandler.StepsDone
  If elem.ClassHandler.StepsDone = StepsTotal Then

    Me.Finish
  Else

    ' prepare next stuff
    '
    NextParamType = UCase(Mid(elem.ClassHandler.ParamType, elem.ClassHandler.StepsDone + 1, 1))
    If NextParamType = "+" Then ' add another point
      elem.p.add(0)
      elem.p.add(0)

      Debug "P vs iPoints", elem.P.Count / 2, iPoints

      ' ' la SPLine requiere
      ' If elem.p.Count / 2 - 1 = iPoints Then Inc iPoints

      elem.Psel.add(0)
      Dec elem.ClassHandler.StepsDone
    Endif

    Try clsDrawingAids.HelperTrabajoNext = ParamHelperList[elem.ClassHandler.StepsDone]          ' try in case of lack of desciption or keep last
    If ParamDefault.Count > elem.ClassHandler.StepsDone Then                            ' not null
      ParamDefault[elem.ClassHandler.StepsDone] = Trim$(ParamDefault[elem.ClassHandler.StepsDone])
      If ParamDefault[elem.ClassHandler.StepsDone] <> "" Then clsDrawingAids.HelperTrabajoNext &= "[" & ParamDefault[elem.ClassHandler.StepsDone] & "]"           ' try in case of lack of desciption or keep last
    End If

    ' last point
    gcd.CurrentDrawing.LastPoint.Clear
    Try gcd.CurrentDrawing.LastPoint.Insert([elem.P[(iPoints - 1) * 2], elem.P[(iPoints - 1) * 2 + 1]])

    ' we set the next point in the same position of this
    Try elem.P[iPoints * 2] = elem.P[(iPoints - 1) * 2]
    Try elem.P[iPoints * 2 + 1] = elem.P[(iPoints - 1) * 2 + 1]

  Endif

  appmain.redraw

End

Public Function MouseMove(mouseX As Integer, mouseY As Integer) ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseMove

  Dim X, Y As Float

  If (Me.iPoints > elem.P.Count / 2) And InStr("LAP", NextParamType) = 0 Then Return ' we are expecting a parameter

  ' a very special case
  If elem.Gender = "SPLine" And (Me.iPoints <> elem.P.Count / 2 - 1) Then Inc iPoints

  ' if we expect a parameter, it will be passed
  If NextParamType = "A" Then

    ' return the angle from horizontal to us
    elem.fParam[iFloat] = Ang(appmain.Xreal(mouseX) - elem.p[elem.p.max - 1], appmain.Yreal(mouseY) - elem.p[elem.p.max])
    elem.fParam[iFloat] *= 180 / Pi

    Return              ' nothing more to do here
  End If

  If NextParamType = "R" Then

    ' return the angle from horizontal to us
    elem.fParam[iFloat] = Abs(puntos.PointToLineDistance([appmain.Xreal(mouseX), appmain.Yreal(mouseY)], [elem.p[elem.p.max - 3], elem.p[elem.p.max - 2], elem.p[elem.p.max - 1], elem.p[elem.p.max]]))
    'elem.fParam[iFloat] *= 180 / Pi
    'appmain.redraw
    Return              ' nothing more to do here
  End If

  If NextParamType = "L" Then

    ' return the angle from horizontal to us
    elem.fParam[iFloat] = puntos.distancia(puntos.Near(appmain.Xreal(mouseX)), puntos.Near(appmain.Yreal(mouseY)), elem.p[elem.p.max - 1], elem.p[elem.p.max])

    appmain.redraw
    Return              ' nothing more to do here
  End If

  If Me.iPoints >= elem.P.Count / 2 Then Return

  elem.P[iPoints * 2] = puntos.Near(appmain.Xreal(mouseX))
  elem.P[iPoints * 2 + 1] = puntos.Near(appmain.Yreal(mouseY))

  ' y si tengo enganche?

  If (gcd.CurrentDrawing.iEntity[2] >= 0) And (gcd.OrthogonalForced = False) Then

    ' esto re enganchado

    elem.p[iPoints * 2] = gcd.CurrentDrawing.iEntity[0]
    elem.p[iPoints * 2 + 1] = gcd.CurrentDrawing.iEntity[1]

    ' aca tengo que verificar el ortogonal

  Else If Me.iPoints > 0 Then                                                                          ' puedo hacer ortogonal
    If gcd.OrthogonalForced Or (Not gcd.OrthogonalIgnored And gcd.Orthogonal) Then          ' hablame de operadores logicos

      If Abs(elem.p[iPoints * 2] - elem.P[(iPoints - 1) * 2]) > Abs(elem.p[iPoints * 2 + 1] - elem.P[(iPoints - 1) * 2 + 1]) Then ' prevalece X
        elem.p[iPoints * 2 + 1] = elem.P[(iPoints - 1) * 2 + 1]
      Else
        elem.p[iPoints * 2] = elem.P[(iPoints - 1) * 2]
      Endif

    End If

  End If

  appmain.redraw

End

Public Function MouseDown(mouseX As Integer, mouseY As Integer) ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseDown

  clsDrawingAids.ErrorMessage = ""
  If (Me.iPoints > elem.P.Count / 2) And InStr("LAP", NextParamType) = 0 Then Return ' we are expecting a parameter

  ' if we expect a parameter, it will be passed
  If NextParamType = "A" Then

    ' return the angle from horizontal to us
    elem.fParam[iFloat] = Ang(appmain.Xreal(mouseX) - elem.p[elem.p.max - 1], appmain.Yreal(mouseY) - elem.p[elem.p.max])
    elem.fParam[iFloat] *= 180 / Pi

    Inc iFloat
    AdvanceStep
    Return              ' nothing more to do here
  End If

  If NextParamType = "R" Then

    ' return the angle from horizontal to us
    elem.fParam[iFloat] = Abs(puntos.PointToLineDistance([appmain.Xreal(mouseX), appmain.Yreal(mouseY)], [elem.p[elem.p.max - 3], elem.p[elem.p.max - 2], elem.p[elem.p.max - 1], elem.p[elem.p.max]]))
    Inc iFloat
    AdvanceStep
    Return              ' nothing more to do here
  End If


  If NextParamType = "L" Then

    ' return the angle from horizontal to us
    elem.fParam[iFloat] = puntos.distancia(puntos.Near(appmain.Xreal(mouseX)), puntos.Near(appmain.Yreal(mouseY)), elem.p[elem.p.max - 1], elem.p[elem.p.max])
    Inc iFloat
    AdvanceStep
    Return              ' nothing more to do here
  End If

  If iPoints >= elem.P.Count / 2 Then Return

  ' we are waiting for a point

  elem.P[iPoints * 2] = puntos.Near(appmain.Xreal(mouseX))
  elem.P[iPoints * 2 + 1] = puntos.Near(appmain.Yreal(mouseY))

  ' y si tengo enganche?

  If (gcd.CurrentDrawing.iEntity[2] >= 0) And (gcd.OrthogonalForced = False) Then

    ' esto re enganchado

    elem.p[iPoints * 2] = gcd.CurrentDrawing.iEntity[0]
    elem.p[iPoints * 2 + 1] = gcd.CurrentDrawing.iEntity[1]

    ' aca tengo que verificar el ortogonal

  Else If Me.iPoints > 0 Then                                                                          ' puedo hacer ortogonal
    If gcd.OrthogonalForced Or (Not gcd.OrthogonalIgnored And gcd.Orthogonal) Then          ' hablame de operadores logicos

      If Abs(elem.p[iPoints * 2] - elem.P[(iPoints - 1) * 2]) > Abs(elem.p[iPoints * 2 + 1] - elem.P[(iPoints - 1) * 2 + 1]) Then ' prevalece X
        elem.p[iPoints * 2 + 1] = elem.P[(iPoints - 1) * 2 + 1]
      Else
        elem.p[iPoints * 2] = elem.P[(iPoints - 1) * 2]
      Endif

    End If

  End If
  Inc iPoints
  AdvanceStep

End

Public Function MouseUp(mouseX As Integer, mouseY As Integer) ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseUp

  'Debug elem.P.Count

End


Public Sub Draw()               ' called bygcd.CurrentDrawing.drwArea_Draw

  If Me.iPoints < elem.ClassHandler.pointstodraw Then Return

  elem.ClassHandler.draw(elem)

End

Public Sub Finish()

  gcd.CurrentDrawing.arrEntities.Add(elem)

  elem.ClassHandler.Finish(elem, elem.ClassHandler.StepsDone)

  LastEntity = elem                                       ' save it to repeat on rigth click

  gcd.UpdateModel

  gcd.clsJobPrevious = Me
  gcd.clsJob = clsDefaultJob
  clsDefaultJob.PoiChecking = True
  clsDrawingAids.CleanTexts

  clsEntities.GLGenDrawList

  appmain.redraw

End

Public Sub Cancel()

  elem = Null
  gcd.clsJobPrevious = Me
  gcd.clsJob = clsDefaultJob
  clsDrawingAids.CleanTexts
  appmain.redraw

End

Public Sub MoveOn()

  Inc Me.iPoints
  Inc Me.iPoints

End
