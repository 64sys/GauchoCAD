' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

' Pixeles
Public Const GENDER As String = "Builder"
Public LastMouseDownX As Integer    ' change in MouseDown
Public LastMouseDownY As Integer
Public SelStartX As Integer         ' change in MouseDown
Public SelStartY As Integer
Public SelEndX As Integer           ' change in MouseMove/MouseUp
Public SelEndY As Integer

' Metros
Public SelStartXr As Float          ' Seleccion libre rectangular
Public SelStartZr As Float          ' en metros
Public SelEndXr As Float            ' aca Y es Z
Public SelEndZr As Float

' indicadores
'Public elem.StepsDone As Integer = 0          ' La cantidad de puntos que marco para el trabajo actual--->Gurdado en la entidad
Public StepsTotal As Integer = 0          ' Tomado de la lista de tipo de paramtros
Public PointsTotal As Integer = 0          ' Tomado de la lista de tipo de paramtros
Public NextParamType As String          ' What kind of input the element expects P=point, F=float, C=color, S=string, M=mixed either Point, or Float that is taken from Max(Px-Px', Pz-Pz')
Public ParamHelperList As String[]
Public ParamDefault As String[]

' indices de valores ingresados
Public iPoints As Integer
Public iFloat As Integer
Public iString As Integer

' conserva los ultimos valores del mouse
Public CursorX As Integer
Public CursorY As Integer

Public elem As Object

Public LastEntity As Object

Public XYreal As Float[]

Public Function Start(ElemToBuild As Variant, Optional Mode As Integer = 0)

    ' Parameters that we can process

    ' P point x,y
    ' + add a point every time, used like this "P+"
    ' F float, text entered (mouse is ignored)
    ' T text
    ' A angle, can be given by mouse or text
    ' L distance, idem

    ' TODO: implement
    ' C color, can be given by typing the color

    ' B boolean yes/no si/no
    ' D date

    ' Verify if its a valid class to build
    If TypeOf(ElemToBuild) <> gb.Object Then                                            ' not Entity class given

        If LastEntity Then                                            ' we know the last element, try to create a new one
            elem = Object.New(Object.Class(LastEntity).Name)           ' create the New Class

        Else                                                                            ' the is no way to know what element was done last

            clsDrawingAids.ErrorMessage = ("Can create entity")
            modCAD.clsJob = clsDefaultJob                                               ' back to select mode
            modCAD.clsJobPrevious = clsDefaultJob
            Return

        End If

    Else                                                                                ' Valid entity
        ' start building the element
        elem = elemtobuild

    End If

    clsEntities.FillEntity(elem)
    ' reset from previous element
    elem.StepsDone = 0

    elem.gbcolor = appmain.CurrentColor

    iPoints = 0
    iFloat = 0
    iString = 0

    Pointstotal = elem.p.count / 2                                          ' at this point P is either set or 0 if non determined
    StepsTotal = Len(elem.ParamType)

    ' get the helper list, and parameter types from the element
    Try Paramhelperlist = Split(elem.ParamHelper, ";")                      ' optional
    Try Paramdefault = Split(elem.ParamDefault, ";")                        ' optional

    NextParamType = UCase(Mid(elem.ParamType, elem.StepsDone + 1, 1))
    clsDrawingAids.HelperTrabajoNext = ParamHelperList[0]

    ' instructions to FCAD
    modCAD.OrtogonalIgnorado = elem.OrtogonalIgnorado
    modCAD.OrtogonalForzado = elem.OrtogonalForzado
    elem.gbcolor = appmain.CurrentColor
    clsDrawingAids.HelperTrabajo = elem.HelperTrabajo

End

Public Function KeyText(EnteredText As String) ' esta rutina es llamada por FCAD en el evento FCAD_KeyPress cuando recibe una texto + <Enter>

    ' this could be many things, but lets concentrate in what to expect and check if its correct

    ' The element provides a constant called ParamType wich is a string like "PPFCTB"

    ' P = point in X,Y format with decimal point as dot "."
    '     it can also be @X,Y wich means that the coordinates are relative to the last point

    ' F = float, thats any number

    ' T = a text or a single character too

    ' C = color input

    ' B = boolean, Yes/Si or No

    ' Lets see what are we expecting
    Dim Xt, Zt As Float, ErrTxt As String, Relative As Boolean

    Select Case NextParamType

        Case "P", "+"
            errtxt = ", expected a valid point like 12.4,9.5  or @12.34,10.5"
            ' lets filter
            EnteredText = Trim$(UCase$(EnteredText))
            ' So we expect a position x,y , but in some cases it can be
            ' C = close
            ' U = undo, delete last segment
            ' and others

            If Left(EnteredText, 1) = "C" Then          ' close the element
                ' got othe first point and exit
                elem.P[iPoints * 2] = elem.P[0]
                elem.P[iPoints * 2 + 1] = elem.P[1]
                Me.Finish

            Else If Left(EnteredText, 1) = "U" Then     ' undo last command and go

                elem.P.remove(elem.P.max)
                elem.P.remove(elem.P.max)
                Me.Finish
            Else                                        ' an X,Y or @X,Y

                If InStr(EnteredText, "@") > 0 Then    ' may be a point
                    Relative = True
                    EnteredText = Replace(EnteredText, "@", "")
                Endif
                Xt = CFloat(Split(EnteredText, ",")[0])
                Zt = CFloat(Split(EnteredText, ",")[1])

                ' if we are stll here, input was good
                elem.P[iPoints * 2] = Xt
                elem.P[iPoints * 2 + 1] = Zt

                If Relative And elem.StepsDone > 0 Then
                    elem.P[iPoints * 2] += elem.P[(iPoints - 1) * 2]
                    elem.P[iPoints * 2 + 1] += elem.P[(iPoints - 1) * 2 + 1]

                Endif
                Inc iPoints
                AdvanceStep

            End If

        Case "T"
            errtxt = ", expected text, not a point"
            ' its a valid input?
            If EnteredText = "" Then

                'elem.stringdata = EnteredText
                elem.stringdata &= ParamDefault[elem.StepsDone]
            Else If elem.stringdata <> "" Then                      ' we have a previous entry

                elem.stringdata &= "|" & EnteredText  ' split if necessary

            Else

                elem.stringdata &= EnteredText                      ' first entry

            End If

            AdvanceStep

        Case "F", "M", "A", "L"                 ' Float, Mixed, Angle, Longitud
            errtxt = "enter a valid text size"

            If EnteredText = "" Then

                Try elem.fParam[iFloat] = ParamDefault[elem.StepsDone]

            Else

                elem.fParam[iFloat] = CFloat(EnteredText)

            Endif

            Inc iFloat
            AdvanceStep

        Case "C"                                ' color
            If Dialog.SelectColor() Then
                elem.fParam[iFloat] = CFloat(Dialog.Color)
                Inc iFloat
                AdvanceStep

            Endif
            Key.Cod

    End Select

Finally

    Return

Catch

    ' unexpected input
    clsDrawingAids.ErrorMessage = ("Bad input" & ErrTxt)

End

Public Sub AdvanceStep()

    Inc elem.StepsDone
    If elem.StepsDone = StepsTotal Then

        Me.Finish
    Else

        ' prepare next stuff
        '
        NextParamType = UCase(Mid(elem.ParamType, elem.StepsDone + 1, 1))
        If NextParamType = "+" Then ' add another point
            elem.p.add(0)
            elem.p.add(0)
            elem.level.add(0)
            elem.b.add(0)
            elem.b.add(0)
            elem.Psel.add(0)
            Dec elem.StepsDone
        Endif

        Try clsDrawingAids.HelperTrabajoNext = ParamHelperList[elem.StepsDone]          ' try in case of lack of desciption or keep last
        If ParamDefault.Count > elem.StepsDone Then                            ' not null
            ParamDefault[elem.StepsDone] = Trim$(ParamDefault[elem.StepsDone])
            If ParamDefault[elem.StepsDone] <> "" Then clsDrawingAids.HelperTrabajoNext &= "[" & ParamDefault[elem.StepsDone] & "]"           ' try in case of lack of desciption or keep last
        End If

        ' we set the next point in the same position of this
        Try elem.P[iPoints * 2] = elem.P[(iPoints - 1) * 2]
        Try elem.P[iPoints * 2 + 1] = elem.P[(iPoints - 1) * 2 + 1]

        ' check if it can be drawn

        If elem.StepsDone >= elem.PointsToDraw Then elem.DrawAble = True

    Endif

    appmain.hFCAD.redraw

End

Public Function MouseMove() ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseMove

    If (Me.iPoints > elem.P.Count / 2) And InStr("LAP", NextParamType) = 0 Then Return ' we are expecting a parameter

    ' if we expect a parameter, it will be passed
    If NextParamType = "A" Then

        ' return the angle from horizontal to us
        elem.fParam[iFloat] = Ang(appmain.hFcad.Xreal(mouse.x) - elem.p[elem.p.max - 1], appmain.hFcad.Yreal(mouse.y) - elem.p[elem.p.max])
        elem.fParam[iFloat] *= 180 / Pi
        appmain.hFCAD.redraw
        Return              ' nothing more to do here
    End If

    If NextParamType = "L" Then

        ' return the angle from horizontal to us
        elem.fParam[iFloat] = puntos.distancia(puntos.Near(appmain.hFcad.Xreal(mouse.x)), puntos.Near(appmain.hFcad.Yreal(mouse.y)), elem.p[elem.p.max - 1], elem.p[elem.p.max])

        appmain.hFCAD.redraw
        Return              ' nothing more to do here
    End If

    If Me.iPoints >= elem.P.Count / 2 Then Return

    elem.P[iPoints * 2] = puntos.Near(appmain.hFcad.Xreal(mouse.x))
    elem.P[iPoints * 2 + 1] = puntos.Near(appmain.hFcad.Yreal(mouse.y))

    ' y si tengo enganche?

    If (appmain.hFcad.iEntity[2] >= 0) And (modCAD.OrtogonalForzado = False) Then

        ' esto re enganchado

        elem.p[iPoints * 2] = appmain.hFcad.iEntity[0]
        elem.p[iPoints * 2 + 1] = appmain.hFcad.iEntity[1]

        ' aca tengo que verificar el ortogonal

    Else If elem.StepsDone > 0 Then                                                                          ' puedo hacer ortogonal
        If modCAD.OrtogonalForzado Or (Not modCAD.OrtogonalIgnorado And modCAD.Ortogonal) Then          ' hablame de operadores logicos

            If Abs(elem.p[iPoints * 2] - elem.P[(iPoints - 1) * 2]) > Abs(elem.p[iPoints * 2 + 1] - elem.P[(iPoints - 1) * 2 + 1]) Then ' prevalece X
                elem.p[iPoints * 2 + 1] = elem.P[(iPoints - 1) * 2 + 1]
            Else
                elem.p[iPoints * 2] = elem.P[(iPoints - 1) * 2]
            Endif

        End If

    End If

    appmain.hFCAD.redraw

End

Public Function MouseDown() ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseDown

    clsDrawingAids.ErrorMessage = ""
    If (Me.iPoints > elem.P.Count / 2) And InStr("LAP", NextParamType) = 0 Then Return ' we are expecting a parameter

    ' if we expect a parameter, it will be passed
    If NextParamType = "A" Then

        ' return the angle from horizontal to us
        elem.fParam[iFloat] = Ang(appmain.hFcad.Xreal(mouse.x) - elem.p[elem.p.max - 1], appmain.hFcad.Yreal(mouse.y) - elem.p[elem.p.max])
        elem.fParam[iFloat] *= 180 / Pi

        Inc iFloat
        AdvanceStep
        Return              ' nothing more to do here
    End If

    If NextParamType = "L" Then

        ' return the angle from horizontal to us
        elem.fParam[iFloat] = puntos.distancia(puntos.Near(appmain.hFcad.Xreal(mouse.x)), puntos.Near(appmain.hFcad.Yreal(mouse.y)), elem.p[elem.p.max - 1], elem.p[elem.p.max])
        Inc iFloat
        AdvanceStep
        Return              ' nothing more to do here
    End If

    If iPoints >= elem.P.Count / 2 Then Return

    ' we are waiting for a point

    elem.P[iPoints * 2] = puntos.Near(appmain.hFcad.Xreal(mouse.x))
    elem.P[iPoints * 2 + 1] = puntos.Near(appmain.hFcad.Yreal(mouse.y))

    ' y si tengo enganche?

    If (appmain.hFcad.iEntity[2] >= 0) And (modCAD.OrtogonalForzado = False) Then

        ' esto re enganchado

        elem.p[iPoints * 2] = appmain.hFcad.iEntity[0]
        elem.p[iPoints * 2 + 1] = appmain.hFcad.iEntity[1]

        ' aca tengo que verificar el ortogonal

    Else If elem.StepsDone > 0 Then                                                                          ' puedo hacer ortogonal
        If modCAD.OrtogonalForzado Or (Not modCAD.OrtogonalIgnorado And modCAD.Ortogonal) Then          ' hablame de operadores logicos

            If Abs(elem.p[iPoints * 2] - elem.P[(iPoints - 1) * 2]) > Abs(elem.p[iPoints * 2 + 1] - elem.P[(iPoints - 1) * 2 + 1]) Then ' prevalece X
                elem.p[iPoints * 2 + 1] = elem.P[(iPoints - 1) * 2 + 1]
            Else
                elem.p[iPoints * 2] = elem.P[(iPoints - 1) * 2]
            Endif

        End If

    End If
    Inc iPoints
    AdvanceStep

End

Public Function MouseUp() ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseUp

End

Public Sub CancelarConstruccion()

    elem.ForDeletion = True       ' it will be removed later
    elem.DrawAble = False         ' don't draw me anymore

End

Public Sub Draw()               ' called byappmain.hFCAD.drwArea_Draw

    elem.draw

End

Public Sub Finish()

    elem.Finish(elem.StepsDone)
    elem.buildPOI
    clsEntities.BackUpPosition(elem)
    APPMain.hFCAD.arrEntities.Add(elem)

    LastEntity = elem                                       ' save it to repeat on rigth click

    modCAD.clsJobPrevious = Me
    modCAD.clsJob = clsDefaultJob
    clsDrawingAids.CleanTexts

    ' sort them
    APPMain.hFCAD.arrEntities.Sort()
    clsEntities.GLGenDrawList

    appmain.hFCAD.redraw

End
