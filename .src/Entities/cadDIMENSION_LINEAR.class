' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
Inherits CadDimension

Public Const Gender As String = "Dimension_Linear"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Insert a linear acotation")
Public Const ParamType As String = "PPP"
Public Const ParamHelper As String = "Start point;End point;extension"
Public Const ParamDefault As String = " "

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

  Dim i As Integer
  Dim AfterSubclassmarker As Boolean
  ' ' revisamos lo que viene del importador comun
  e.P[4] = e.P[0]
  e.P[5] = e.P[1]
  '
  e.P[6] = e.P[2]
  e.P[7] = e.P[3]

  For i = 0 To sClaves.Max
    If sClaves[i] = "100" And sValues[i] = "AcDbAlignedDimension" Then AfterSubclassmarker = True
    If AfterSubclassmarker Then ' los siguientes codigos
      If sClaves[i] = "12" Then e.P[8] = CFloat(sValues[i])
      If sClaves[i] = "22" Then e.P[9] = CFloat(sValues[i])

      If sClaves[i] = "13" Then e.P[0] = CFloat(sValues[i])
      If sClaves[i] = "23" Then e.P[1] = CFloat(sValues[i])

      If sClaves[i] = "14" Then e.P[2] = CFloat(sValues[i])
      If sClaves[i] = "24" Then e.P[3] = CFloat(sValues[i])

      ' este parametro determina el angulo de la dimension, y no los puntos
      If sClaves[i] = "50" Then e.iParam[cadDimension.iiiMode] = 1000 * CFloat(sValues[i])

      If sClaves[i] = "52" Then e.fParam[cadDimension.ipaObliqueExtension] = CFloat(sValues[i])

    End If

  Next

  ' Equivalencias
  ' DXF       Entity P[]
  ' 10-20     4-5
  ' 11-21     6-7
  ' 12-22     no se usa
  ' 13-23     0-1
  ' 14-24     2-3

  e.fParam[cadDimension.ipaExtension] = -puntos.distancia(Me.pointDefPoint0.x, Me.pointDefPoint0.y, Me.pointDefPoint2.x, Me.pointDefPoint2.y)

  ' TODO: cuando este terminada la entidad, sacar eso
  ' tengo q presuponer que las escalas son = 1
  e.fParam[Me.ipaEscX] = 1    ' esc X
  e.fParam[Me.ipaEscY] = 1    ' esc Y
  e.fParam[Me.ipaEscZ] = 1    ' esc Z
  e.pBlock.AbsoluteCoords = True

  ' y poner esto
  ' e.pBlock = Me.ReBuildBlock(e)

  Return True

  ' catch

  Return False

End

Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

  ' la linea solo recibe puntos

  If vParam[0] <> "point" Then Return False

  If Me.StepsDone = 0 Then
    Me.DimType = gcd.dimAligned
    ' supongo que marca el punto de derecha a izq
    ' el primero es P3 o P67
    Try eBuild.p[0] = vParam[1]
    Try eBuild.p[1] = vParam[2]
    eBuild.p[2] = eBuild.P[0]
    eBuild.p[3] = eBuild.P[1]
    eBuild.p[4] = eBuild.p[2]
    eBuild.p[5] = eBuild.P[3]
    ' Me.pointDefPoint2.x = Me.pointDefPoint1.x
    ' Me.pointDefPoint2.y = Me.pointDefPoint1.y
    If definitive Then Return True
  Else If Me.StepsDone = 1 Then
    eBuild.DrawAble = True
    eBuild.Finished = True
    Try eBuild.p[2] = vParam[1]
    Try eBuild.p[3] = vParam[2]
    eBuild.p[4] = eBuild.p[2]
    eBuild.p[5] = eBuild.P[3]

    ' Try Me.pointDefPoint2.x = vParam[1]
    ' Try Me.pointDefPoint2.y = vParam[2]
    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then Return True
  Else If Me.StepsDone = 2 Then   ' el tercer punto sera la posicion del texto

    ' return the angle from horizontal to us
    'eBuild.fParam[Me.ipaExtension] = -puntos.PointToLineDistance([vParam[1], vParam[2]], [eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]]) ' / puntos.distancia(eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]
    Try eBuild.p[4] = vParam[1]
    Try eBuild.p[5] = vParam[2]

    ' Try Me.pointDefPoint0.x = vParam[1]
    ' Try Me.pointDefPoint0.y = vParam[2]
    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then
      'Stop
      Return True
    End If
  Endif

End

Public Sub ReBuildBlock(E As Entity) As Block

  ' esta rutina no sabe si el bloque a reconstruir es desde EntityBuilder o desde
  ' DXF o JSON

  Dim d As Float, flxTextExt As Float[]
  Dim fRotXY As Float[]

  Dim newBlock As New Block
  Dim f1, f2 As New Float[]
  Dim a1 As Float
  Dim sDim As String
  Dim invertida As Integer = 1

  newBlock.entities = New Collection

  ' ' verifico el armado
  ' If E.P[2] < E.P[0] Then
  '   ' Swap elem.P[2], elem.P[0]
  '   ' Swap elem.p[3], elem.P[1]
  '   invertida = -1
  '
  ' Endif
  '
  ' If E.P[2] = E.P[0] Then
  '   If E.P[1] > E.P[3] Then
  '     ' Swap elem.P[2], elem.P[0]
  '     ' Swap elem.p[3], elem.P[1]
  '     invertida = -1
  '
  '   End If
  ' Endif

  ' para definir este bloque necesito 6 entidades
  Dim eLineaPpal As Entity
  Dim eOblique1 As Entity       ' tambien pueden ser flechas Solid
  Dim eOblique2 As Entity
  Dim eExtension1 As Entity
  Dim eExtension2 As Entity
  Dim eText As Entity
  Dim ePoint1 As Entity
  Dim ePoint2 As Entity

  ' vemos los estilos
  If E.fParam[Me.ipaStyleTextHeigth] > 0 Then Me.DimTextHeight = E.fParam[Me.ipaStyleTextHeigth] Else Me.DimTextHeight = E.pStyle.fTxtHeight_140
  If E.fParam[Me.ipaStyleArrowSize] > 0 Then Me.DimArrowSize = E.fParam[Me.ipaStyleArrowSize] Else Me.DimArrowSize = E.pStyle.fArrowSize_41
  Me.DimArrowWidth = Me.DimArrowSize / 3

  'newBlock.AbsoluteCoords = True

  ' linea principal
  eLineaPpal = cadLine.NewEntity([e.P[0], e.P[1], 0.0, 0.0])  ' el 2do punto lo tengo que determinar, el primero esta en la posicion final

  ' lineas de demarcacion
  eExtension1 = cadLine.NewEntity([0, Me.DimExtension, 0, -Me.DimExtension])
  eExtension2 = cadLine.NewEntity([0, Me.DimExtension, 0, -Me.DimExtension])

  ' puntos base, ya en las ubicaciones finales (coinciden con los clicks)
  ePoint1 = cadPoint.NewEntity([e.P[6], e.P[7]])
  ePoint2 = cadPoint.NewEntity([e.P[8], e.P[9]])

  ' flechas
  eOblique1 = cadSolid.NewEntity([0, 0, Me.DimArrowSize, Me.DimArrowWidth, Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])
  eOblique2 = cadSolid.NewEntity([0, 0, -Me.DimArrowSize, Me.DimArrowWidth, -Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])

  ' texto
  eText = cadMText.NewEntity([e.P[2], e.P[3]])  ' si leo un archivo, esta es la posicion final
  eText.fParam[cadMText.ipaAttchmPoint] = 8

  ' agrego todo al bloque
  newBlock.entities.Add(eLineaPpal, gcd.NewHandle())
  newBlock.entities.Add(eExtension1, gcd.NewHandle())
  newBlock.entities.Add(eExtension2, gcd.NewHandle())
  newBlock.entities.Add(ePoint1, gcd.NewHandle())
  newBlock.entities.Add(ePoint2, gcd.NewHandle())
  newBlock.entities.Add(eText, gcd.NewHandle())

  ' -> el bloque
  E.fParam[cadInsert.ipaEscX] = 1      ' ScaleX del inserto
  E.fParam[cadInsert.ipaEscY] = 1      ' ScaleY del inserto
  E.fParam[cadInsert.ipaEscZ] = 1      ' ScaleY del inserto
  E.Visible = True

  E.fParam[cadInsert.ipaRotacion] = CFloat(E.iParam[Me.iiiMode]) / 1000

  ' el largo de la linea principal viene dado por la distancia entre ambos puntos
  ' pero como es una dimension alineada, se multiplica por la diferencia de angulos
  ' entre P1-P2 y el angulo de la dimension a medir
  a1 = Ang(E.p[2] - E.P[0], E.p[3] - E.P[1]) * 180 / Pi
  a1 -= E.fParam[cadInsert.ipaRotacion]  ' esto viene en grados *1000
  a1 = Abs(a1) / 180 * Pi
  d = Cos(a1) * puntos.distancia(E.P[0], E.P[1], E.P[2], E.P[3])

  ' ' verifico el armado
  ' If E.P[2] < E.P[0] Then
  '   ' Swap elem.P[2], elem.P[0]
  '   ' Swap elem.p[3], elem.P[1]
  '   invertida = -1
  '
  ' Endif
  '
  ' If E.P[2] = E.P[0] Then
  '   If E.P[1] > E.P[3] Then
  '     ' Swap elem.P[2], elem.P[0]
  '     ' Swap elem.p[3], elem.P[1]
  '     invertida = -1
  '
  '   End If
  ' Endif
  '
  ' la primer entidad del bloque es la linea principal
  eLineaPpal.P[2] = d '* invertida           ' X1
  eLineaPpal.P[3] = 0           ' Y1

  ePoint2.P[0] = d '* invertida

  ' la segunda es la primer linea de demarcacion (sin cambios)
  ' eExtension1.P[0] = 0           ' X0
  ' eExtension1.P[1] = 0           ' Y0
  '
  ' eExtension1.P[2] = 0           ' X1
  ' eExtension1.P[3] = 0           ' Y1

  ' la tercera es la segunda linea de demarcacion
  eExtension2.P[0] = d '* invertida           ' X0

  eExtension2.P[2] = d '* invertida          ' X1

  E.fParam[cadDimension.ipaRealMeasure] = Abs(d)
  If E.StringData[Me.sdaTextOverride] <> "" Then
    sDim = E.StringData[Me.sdaTextOverride]
  Else
    sDim = Format(Abs(d), Me.DimFormat)
  Endif
  ' el texto
  eText.StringData[cadMText.sdaText] = "\\A1;" & sDim
  flxTextExt = glPlus.MTextExtends(sDim, 0, 0, eText.fParam[cadMText.ipaTextHeight])

  ' la cuarta y quinta son las flechas , tengo que verificar si entran, o el texto
  If flxTextExt[2] * 1.1 > Abs(d) Then                      ' no entra

    eOblique1.P[0] = d '* invertida           ' X0
    eOblique1.P[2] = (Me.DimArrowSize + d) '* invertida            ' X0
    eOblique1.P[4] = (Me.DimArrowSize + d) '* invertida           ' X0
    eOblique1.P[6] = d '* invertida    ' X0

    eOblique2.P[0] = 0           ' X0
    eOblique2.P[2] = -Me.DimArrowSize '* invertida
    eOblique2.P[4] = -Me.DimArrowSize '* invertida
    eOblique2.P[6] = 0           ' X0

    ' el texto va afuera
    eText.P[0] = (d + Me.DimArrowSize / 2) '* invertida
    eText.P[1] = Me.DimArrowWidth

  Else                                                                ' entra
    eOblique1.P[0] = 0 * invertida ' X0
    eOblique1.P[2] = Me.DimArrowSize * invertida
    eOblique1.P[4] = Me.DimArrowSize * invertida
    eOblique1.P[6] = 0 * invertida ' X0

    eOblique2.P[0] = d '* invertida ' X0
    eOblique2.P[2] = -Me.DimArrowSize * invertida + d            ' X0
    eOblique2.P[4] = -Me.DimArrowSize * invertida + d            ' X0
    eOblique2.P[6] = d '* invertida            ' X0

    ' el texto va adentro
    eText.P[0] = (d / 2 - flxTextExt[2] / 2) '* invertida
    eText.P[1] = Me.DimArrowWidth

  End If

  ' En esta parte ubico las cosas segun la extension, o sea la distancia a los puntos de demarcacion
  E.fParam[Me.ipaExtension] = puntos.PointToLineDistance([E.P[4], E.P[5]], [E.p[0], E.p[1], E.p[2], E.p[3]]) ' / puntos.distancia(eBuild.p[0],
  'Me.extension = puntos.distancia(elem.P[2], elem.P[3], elem.P[4], elem.P[5])
  Me.extension = E.fParam[cadDimension.ipaExtension]
  Me.extension *= Sin(puntos.Angle2([E.P[2] - E.P[0], E.P[3] - E.P[1]], [E.P[4] - E.P[2], E.P[5] - E.P[3]]))

  ' linea principal
  eLineaPpal.P[1] = Me.extension           ' Y0
  eLineaPpal.P[3] = Me.extension           ' Y1

  ' linea de demarcacion
  eExtension1.P[1] = Me.DimExtension + Me.extension           ' Y0
  eExtension1.P[3] = -Me.DimExtension + Me.extension           ' Y1

  ' segunda linea de demarcacion
  eExtension2.P[1] = Me.DimExtension + Me.extension           ' Y0
  eExtension2.P[3] = -Me.DimExtension + Me.extension           ' Y1

  ' texto
  eText.P[1] = Me.DimArrowWidth + Me.extension

  ' flechas
  eOblique1.P[1] = Me.extension           ' X0
  eOblique1.P[3] = Me.extension + Me.DimArrowWidth
  eOblique1.P[5] = Me.extension - Me.DimArrowWidth
  eOblique1.P[7] = Me.extension           ' X0

  eOblique2.P[1] = Me.extension           ' X0
  eOblique2.P[3] = Me.extension + Me.DimArrowWidth
  eOblique2.P[5] = Me.extension - Me.DimArrowWidth
  eOblique2.P[7] = Me.extension           ' X0

  ' End If

  ' ' Traslado todo
  ' For Each e As Entity In newBlock.entities
  '     e.classhandler.translate(dX, dY)
  ' Next

  Return newBlock

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  '    MANEJADO EN clsEntities
  '============================
  ' "entity": "DIMENSION_LINEAR",
  ' "index": 262,
  ' "type": 21,
  ' "handle": [0, 3226],
  ' "size": 123,
  ' "bitsize": 872,
  ' "_subclass": "AcDbEntity",
  ' "prev_entity": [12, 1, 164, 3062],
  ' "next_entity": [10, 2, 577, 3803],
  ' "layer": [5, 2, 1883, 1883],
  ' "preview_exists": 0,
  ' "entmode": 2,
  ' "nolinks": 0,
  ' "color": 256,
  ' "ltype_scale": 1.0,
  ' "ltype_flags": 0,
  ' "plotstyle_flags": 0,
  ' "invisible": 0,
  ' "linewt": 29,

  ' ===========================================================================================

  ' "_subclass": "AcDbDimension",
  ' "extrusion": [0.0, 0.0, 1.0],
  ' "text_midpt": [217.50000000000006, 85.76276491494264],
  ' "elevation": 0.0,
  ' "flag1": 10,
  ' "user_text": "",
  ' "text_rotation": 0.0,
  ' "horiz_dir": 0.0,
  ' "ins_scale": [1.0, 1.0, 1.0],
  ' "ins_rotation": 0.0,
  ' "attachment": 5,
  ' "lspace_style": 1,
  ' "lspace_factor": 1.0,
  ' "act_measurement": 384.99999999999989,
  ' "clone_ins_pt": [0.0, 0.0],
  ' "flag": 128,
  ' "_subclass": "AcDbAlignedDimension",
  ' "xline1_pt": [25.0000000000001, 10.0, 0.0],
  'e.P.Add(0)
  'e.P.Add(0)
  e.P.Add(c["xline1_pt"][0])
  e.P.Add(c["xline1_pt"][1])
  ' "xline2_pt": [410.0, 10.0, 0.0],
  e.P.Add(c["xline2_pt"][0])
  e.P.Add(c["xline2_pt"][1])

  ' "def_pt": [410.0, 85.76276491494264, 0.0],
  ' "oblique_angle": 0.0,

  ' "dim_rotation": 0.0,
  e.fParam[Me.ipaEscX] = 1
  e.fParam[Me.ipaEscY] = 1
  e.fParam[Me.ipaEscZ] = 1

  'e.fParam[Me.ipaRotacion] = CFloat(c["dim_rotation"]) * 180 / Pi
  ' "_subclass": "AcDbRotatedDimension",
  ' "dimstyle": [5, 1, 57, 57],
  Try e.pBlock = gcd.CurrentDrawing.oBlocks[gcd.CurrentDrawing.cmodel["BLOCKS"][c["block"][3]]["block_entity"][3]]
  Return True

Catch

  Return False

End
