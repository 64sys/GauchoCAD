' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static

Public Const Gender As String = "Dimension_Linear"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Insert a linear acotation")
Public ParamType As String = "PP"                             ' that is Point, Point, Float; could be Color Text, etc
Public ParamHelper As String = "Start point;End point"
Public Const USEWITH As String = ""
Public Const OrthogonalIgnored As Boolean = False
Public Const OrthogonalForced As Boolean = False
Public Const ParamDefault As String = " "
Public Const StretchAble As Boolean = True           ' Si lo puedo deformar

Public StepsDone As Integer                 ' esto lo cambia cls ElementBuilder durante la construccion

Public TotalDimensions As Integer           ' the total dimensions present in this drawing

' dimstyle: Todas las variables numericas Float estaran multiplicadas por DimScale
Public DimType As Integer = 0            ' = fParam[0] and &X1111
Public DimAtatchPoint As Integer = 2     ' = fParam[1]
Public DimScale As Integer = 1           ' = fParam[2]
Public DimFormat As String = "0.00"      '
Public DimFormatAng As String = "0.0"    '
Public DimArrowSize As Float = 0.3       ' el largo de la flecha
Public DimArrowWidth As Float = 0.1      ' ancho de la flecha
Public DimTickSize As Float = 0.3        ' el tamaÃ±o de la diagonal
Public DimArrowOrThick As Boolean = True ' flecha (True) o diagonal (False)
Public DimTextHeight As Float = 0.3      '
Public DimSeparation As Float = 0.5      ' la separacion entre el punto que define la cota y el inicio de la linea q marca inicio y fin
Public DimExtension As Float = 0.5       ' la continuacion de esas lineas

Public extension As Float
Public iBloque As Integer

' JSON and DXF Read/Export
Public Const JSON_Reading As Boolean = True
Public Const JSON_Export As Boolean = False
Public Const DXF_Reading As Boolean = True
Public Const DXF_Export As Boolean = True

' fParam helpers
Public Const TotalParams As Integer = 7
Public Const ipaEscX As Integer = 0
Public Const ipaEscY As Integer = 1
Public Const ipaEscZ As Integer = 2
Public Const ipaRotacion As Integer = 3
Public Const ipaVertJustif As Integer = 4
Public Const ipaRelativeFactor As Integer = 5
Public Const ipaObliqueAngle As Integer = 6

' stringdata helpers
Public Const sdaTotalParams As Integer = 2
Public Const sdaText As Integer = 0
Public Const sdaStyle As Integer = 1

' Para mejor generalidad y para compatibilidad futura usaremos los P[] asi con los CODE del DXF
' P[] = DXF CODE
' 0 = 10
' 1 = 20
' 2 = 30    Definition points
' 3 = 11
' 4 = 12
' ......
' 20 = 36

' 21 = 210
' 22 = 220	Extrusion direction(Optional ; Default = 0, 0, 1)
' 23 = 230

' fParam[] = DXF CODE
' se usara asi
' 0 =  70, Dimension type:  Values 0 - 6 are integer values that represent the dimension type.Values 32, 64, And 128 are bit values, which are added To the integer values(value 32 Is Always set In R13 And later releases)
'       0 = Rotated; 1 = Aligned; 2 = Angular; 3 = Diameter; 4 = Radius; 5 = Angular3point; 6 = Ordinate
'       32 = Indicates that the block reference(group code 2) Is Referenced by this dimension only
'       64 = Ordinate type.This Is A bit value(bit 7)used only With integer value 6. If set, ordinate Is X - type; If Not set, ordinate Is Y - type
'       128 = This Is A bit value(bit 8)added To the other group 70 values If the dimension text has been positioned at a user - defined location rather than at the Default location
'
' 1 =  71 Attachment point:
'       1 = Top left ; 2 = Top center; 3 = Top right; 4 = Middle left; 5 = Middle center; 6 = Middle right; 7 = Bottom left; 8 = Bottom center; 9 = Bottom right

' 2 = DimScale

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

  cadInsert.Translate(e, dx, dy, OnlySelected)

End

Public Sub Rotate(e As Entity, radians As Float)

  cadInsert.Rotate(e, radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

  cadInsert.Scale(e, sx, sy)

End

Public Sub Draw(Optional e As Entity)

  cadInsert.Draw(e)

End

'' A fat version of the entity
Public Sub DrawRemark(oE As Entity)

  cadInsert.DrawRemark(oe)

End

'' A fat version of the entity
Public Sub DrawSelected(oE As Entity)

  cadInsert.DrawSelected(oe)

End

Public Sub ReBuildBlock(ELEM As Entity)

  Dim d As Float, flxTextExt As Float[]
  Dim fRotXY As Float[]

  ' -> el bloque
  iBloque = clsEntities.FIndBlockID(elem.Block)

  Select DimType
    Case -1 'clsDrawingAids.HelperTrabajo = "DimType? Horizontal;Vertical;Aligned;aNgular;rOtated,Radial;Diameter"

      ' Case gcd.DimAligned
      '   If iPoints = 0 Then     ' marco el primer punto
      '     elem.P[0] = ClickXr     ' posicion base del inserto
      '     elem.P[1] = ClickYr
      '
      '     elem.fParam[0] = 1      ' ScaleX del inserto
      '     elem.fParam[1] = 1      ' ScaleY del inserto
      '     elem.fParam[2] = 0      ' degAngle del inserto
      '
      '   Else If iPoints = 1 Then ' marco el segundo punto, lo que modifica los parametros del bloque
      '     elem.Visible = True
      '     elem.P[2] = ClickXr     ' posicion base del inserto
      '     elem.P[3] = ClickYr
      '
      '     ' el largo de la linea principal viene dado por la distancia entre ambos puntos
      '     d = puntos.distancia(elem.P[0], elem.P[1], ClickXr, ClickYr)
      '
      '     ' con este click calculo el angulo
      '     elem.fParam[2] = Ang(ClickXr - elem.P[0], ClickYr - elem.P[1]) * 180 / Pi
      '
      '     ' la primer entidad del bloque es la linea principal
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[0].P[0] = 0           ' X0
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[0].P[1] = 0           ' Y0
      '
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[0].P[2] = d           ' X1
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[0].P[3] = 0           ' Y1
      '
      '     ' la segunda es la primer linea de demarcacion (sin cambios)
      '     'gcd.CurrentDrawing.arrBlocks[iBloque].entities[1].P[0] = 0           ' X0
      '     'gcd.CurrentDrawing.arrBlocks[iBloque].entities[1].P[1] = 0           ' Y0
      '
      '     'gcd.CurrentDrawing.arrBlocks[iBloque].entities[1].P[2] = d           ' X1
      '     'gcd.CurrentDrawing.arrBlocks[iBloque].entities[1].P[3] = 0           ' Y1
      '
      '     ' la tercera es la segunda linea de demarcacion
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[2].P[0] = d           ' X0
      '     'gcd.CurrentDrawing.arrBlocks[iBloque].entities[2].P[1] = 0           ' Y0
      '
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[2].P[2] = d           ' X1
      '     'gcd.CurrentDrawing.arrBlocks[iBloque].entities[2].P[3] = 0           ' Y1
      '
      '     ' la sexta es el texto
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].StringData[0] = Format(d, Me.DimFormat)
      '
      '     flxTextExt = glPlus.MTextExtends(gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].StringData[0], 0, 0, gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].fParam[1])
      '
      '     ' la cuarta y quinta son las flechas , tengo que verificar si entran, o el texto
      '     If flxTextExt[2] * 1.1 > d Then                      ' no entra
      '
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[0] = d           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[2] = Me.DimArrowSize + d           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[4] = Me.DimArrowSize + d           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[6] = d           ' X0
      '
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[0] = 0           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[2] = -Me.DimArrowSize
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[4] = -Me.DimArrowSize
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[6] = 0           ' X0
      '
      '       ' el texto va afuera
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].P[0] = d + Me.DimArrowSize / 2
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].P[1] = Me.DimArrowWidth
      '
      '     Else                                                                ' entra
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[0] = 0           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[2] = Me.DimArrowSize
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[4] = Me.DimArrowSize
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[6] = 0           ' X0
      '
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[0] = d           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[2] = -Me.DimArrowSize + d           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[4] = -Me.DimArrowSize + d           ' X0
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[6] = d           ' X0
      '
      '       ' el texto va adentro
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].P[0] = d / 2 - flxTextExt[2] / 2
      '       gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].P[1] = Me.DimArrowWidth
      '
      '     End If
      '
      '   Else If iPoints = 2 Then ' marco la extension
      '
      '     extension = -puntos.PointToLineDistance([ClickXr, ClickYr], [elem.P[0], elem.P[1], elem.P[2], elem.P[3]])
      '     'Debug extension
      '
      '     ' linea principal
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[0].P[1] = extension           ' Y0
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[0].P[3] = extension           ' Y1
      '
      '     ' linea de demarcacion
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[1].P[1] = Me.DimExtension + extension           ' Y0
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[1].P[3] = -Me.DimExtension + extension           ' Y1
      '
      '     ' segunda linea de demarcacion
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[2].P[1] = Me.DimExtension + extension           ' Y0
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[2].P[3] = -Me.DimExtension + extension           ' Y1
      '
      '     ' texto
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[5].P[1] = Me.DimArrowWidth + extension
      '
      '     ' flechas
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[1] = extension           ' X0
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[3] = extension + Me.DimArrowWidth
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[5] = extension - Me.DimArrowWidth
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[3].P[7] = extension           ' X0
      '
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[1] = extension           ' X0
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[3] = extension + Me.DimArrowWidth
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[5] = extension - Me.DimArrowWidth
      '     gcd.CurrentDrawing.arrBlocks[iBloque].entities[4].P[7] = extension           ' X0
      '
      '   End If

  End Select

  appmain.redraw

End

Public Function Draw2(oE As Entity)

  cadInsert.Draw2(oe)

End

Public Sub CreatePolygon(oE As Entity)

  cadInsert.CreatePolygon(oe)

End

Public Function BuildPOI(oE As Entity, Optional arrIndex As Integer = -1) As Integer

  cadInsert.BuildPOI(oe, arrIndex)

End

' This function will return False if the element couldn't be created for some reason: bad or incomple user input
' True means all is good, False will instruct the clsEntityBuilder to delete it
Public Sub Finish(oE As Entity) As Boolean

  ' primero agregamos la entidad al array

  cadInsert.Finish(oe)

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  e.fParam.Resize(Me.TotalParams)

  '    MANEJADO EN clsEntities
  '============================
  ' "entity": "DIMENSION_LINEAR",
  ' "index": 262,
  ' "type": 21,
  ' "handle": [0, 3226],
  ' "size": 123,
  ' "bitsize": 872,
  ' "_subclass": "AcDbEntity",
  ' "prev_entity": [12, 1, 164, 3062],
  ' "next_entity": [10, 2, 577, 3803],
  ' "layer": [5, 2, 1883, 1883],
  ' "preview_exists": 0,
  ' "entmode": 2,
  ' "nolinks": 0,
  ' "color": 256,
  ' "ltype_scale": 1.0,
  ' "ltype_flags": 0,
  ' "plotstyle_flags": 0,
  ' "invisible": 0,
  ' "linewt": 29,

  ' ===========================================================================================

  ' "_subclass": "AcDbDimension",
  ' "extrusion": [0.0, 0.0, 1.0],
  ' "text_midpt": [217.50000000000006, 85.76276491494264],
  ' "elevation": 0.0,
  ' "flag1": 10,
  ' "user_text": "",
  ' "text_rotation": 0.0,
  ' "horiz_dir": 0.0,
  ' "ins_scale": [1.0, 1.0, 1.0],
  ' "ins_rotation": 0.0,
  ' "attachment": 5,
  ' "lspace_style": 1,
  ' "lspace_factor": 1.0,
  ' "act_measurement": 384.99999999999989,
  ' "clone_ins_pt": [0.0, 0.0],
  ' "flag": 128,
  ' "_subclass": "AcDbAlignedDimension",
  ' "xline1_pt": [25.0000000000001, 10.0, 0.0],
  e.P.Add(0)
  e.P.Add(0)
  'e.P.Add(c["xline1_pt"][0])
  'e.P.Add(c["xline1_pt"][1])
  ' "xline2_pt": [410.0, 10.0, 0.0],
  ' "def_pt": [410.0, 85.76276491494264, 0.0],
  ' "oblique_angle": 0.0,
  ' "dim_rotation": 0.0,
  e.fParam[Me.ipaEscX] = 1
  e.fParam[Me.ipaEscY] = 1
  e.fParam[Me.ipaEscZ] = 1

  e.fParam[Me.ipaRotacion] = CFloat(c["dim_rotation"]) * 180 / Pi
  ' "_subclass": "AcDbRotatedDimension",
  ' "dimstyle": [5, 1, 57, 57],
  Dim hBlock As Integer

  e.Block = gcd.CurrentDrawing.cmodel["BLOCKS"][c["block"][3]]["block_entity"][3]
  'e.Block = gcd.CurrentDrawing.arrBlocks[clsEntities.FIndBlockIDbyHandle(hBlock)].name
  ' "block": [5, 2, 3228, 3228] '  esto apunta a cModel["BLOCKS"] , pero hay q buscar otra cosa

  Return True

End
