' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
Inherits Caddimension

Public Const Gender As String = "Dimension_Ordinate"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Insert a linear acotation")
Public Const ParamType As String = "PPR"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = "Start point;End point;extension"

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

  ' 10,20,30 -> Baseline              '
  ' 11,21,31 -> Text mid point
  ' 12,22,32 -> UNUSED
  ' 13,23,33 -> Def point, o sea el que determina el valor de la dimension D=Def-Baseline
  ' 14,24,34 -> Leader endpoint, largo de la linea de definicion

  Dim i As Integer
  Dim AfterSubclassmarker As Boolean
  ' revisamos lo que viene del importador comun

  For i = 0 To sClaves.Max
    If sClaves[i] = "100" And sValues[i] = "AcDbOrdinateDimension" Then AfterSubclassmarker = True
    If AfterSubclassmarker Then ' lo siguientes codigos

      If sClaves[i] = "13" Then e.P[6] = CFloat(sValues[i])
      If sClaves[i] = "23" Then e.P[7] = CFloat(sValues[i])

      If sClaves[i] = "14" Then e.P[8] = CFloat(sValues[i])
      If sClaves[i] = "24" Then e.P[9] = CFloat(sValues[i])

    End If

  Next

  ' TODO: cuando este terminada la entidad, sacar eso
  'e.pBlock.AbsoluteCoords = True
  ' y dejar esto
  If e.fParam[Me.ipaStyleTextHeigth] > 0 Then Me.DimTextHeight = e.fParam[Me.ipaStyleTextHeigth]
  Debug "cadDimension.DimTextHeight", cadDimension.DimTextHeight
  e.pBlock = ReBuildBlock(e)

  Return True

  ' catch

  Return False

End

Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

  ' la linea solo recibe puntos

  If vParam[0] <> "point" Then Return False

  If Me.StepsDone = 0 Then
    Me.DimType = gcd.dimAligned

    Try eBuild.P[0] = vParam[1]
    Try eBuild.P[1] = vParam[2]
    eBuild.P[2] = eBuild.P[0]
    eBuild.P[3] = eBuild.P[1]
    If definitive Then Return True
  Else If Me.StepsDone = 1 Then
    eBuild.DrawAble = True
    eBuild.Finished = True
    Try eBuild.P[2] = vParam[1]
    Try eBuild.P[3] = vParam[2]
    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then Return True
  Else If Me.StepsDone = 2 Then
    If vParam[0] = "point" Then  ' vino como un punto, entonces la calculo de otra manera

      ' return the angle from horizontal to us
      eBuild.fParam[Me.ipaExtension] = -puntos.PointToLineDistance([vParam[1], vParam[2]], [eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]]) ' / puntos.distancia(eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]

    Else If vParam[0] = "float" Then  ' vino como un punto, entonces la calculo de otra manera
      eBuild.fParam[Me.ipaExtension] = vParam[1]

    End If
    ' TODO: cuando este terminada la entidad, sacar eso
    ebuild.pBlock.AbsoluteCoords = True
    ' y dejar esto
    ' eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then
      'Stop
      Return True
    End If
  Endif

End

Public Sub ReBuildBlock(ELEM As Entity) As Block

  Dim d As Float, flxTextExt As Float[]
  Dim fRotXY As Float[]

  Dim newBlock As New Block
  Dim f1, f2 As New Float[]

  newBlock.entities = New Entity[]

  ' para definir este bloque necesito 6 entidades
  Dim eLineaPpal As Entity
  Dim eOblique1 As Entity       ' tambien pueden ser flechas Solid
  Dim eOblique2 As Entity
  Dim eExtension1 As Entity
  Dim eExtension2 As Entity
  Dim eDot1 As Entity
  Dim eDot2 As Entity
  Dim eText As Entity
  Dim ePoint2 As Entity

  ' vemos los estilos
  If elem.fParam[Me.ipaStyleTextHeigth] > 0 Then Me.DimTextHeight = elem.fParam[Me.ipaStyleTextHeigth] Else Me.DimTextHeight = elem.pStyle.fTxtHeight_140
  If elem.fParam[Me.ipaStyleArrowSize] > 0 Then Me.DimArrowSize = elem.fParam[Me.ipaStyleArrowSize] Else Me.DimArrowSize = elem.pStyle.fArrowSize_41
  Me.DimArrowWidth = Me.DimArrowSize / 3

  '               (P23=Text mid)
  '         (p67) 12.23
  '         --+--.-----
  '           ^   (P89=Leader endpoint)
  '           !
  '  + (P01=baseline)

  ' Comun para Horiz y Vert
  ' -> el bloque
  elem.fParam[cadInsert.ipaEscX] = 1      ' ScaleX del inserto
  elem.fParam[cadInsert.ipaEscY] = 1      ' ScaleY del inserto
  elem.fParam[cadInsert.ipaEscZ] = 1      ' ScaleY del inserto
  elem.Visible = True
  ' lineas de demarcacion
  clsEntities.AddLine(newBlock.entities, [0, 0, 0, elem.P[9] - elem.P[7]], elem.colour, elem.LineWidth, elem.LineType.Index, elem.pLayer)
  eExtension2 = newBlock.entities.Last
  ' puntos base
  clsEntities.AddPoint(newBlock.entities, [0.0, 0.0], elem.colour, elem.LineWidth, elem.LineType.Index, elem.pLayer)

  ' flechas
  ' la flecha va rotada 90*
  f2.Insert([Me.DimExtension, 0, Me.DimExtension - Me.DimArrowWidth, -Me.DimArrowSize, Me.DimExtension + Me.DimArrowWidth, -Me.DimArrowSize, Me.DimExtension, 0])

  clsEntities.Addsolid(newBlock.entities, f2, elem.colour, elem.LineWidth, elem.LineType.Index, elem.pLayer)

  eOblique2 = newBlock.entities.Last
  ' texto
  clsEntities.AddMText(newBlock.entities, [elem.p[2] - elem.p[6], elem.p[3] - elem.p[7], 0.0, 0.0], 0, Me.DimTextHeight, "0.00", elem.colour, elem.LineWidth, elem.LineType.Index, elem.pLayer)
  eText = newBlock.entities.Last

  ' Armo directamente de acuerdo a lo que necesito
  If elem.fParam[Me.ipaHorizAngle] = 1 Then                               ' Ordenada X Horizontal (texto y lineas verticales)
    elem.fParam[cadDimension.ipaRealMeasure] = elem.P[6] - elem.P[0]

    ' esto no cambia la posicion, ya sea mayor o menor que cero
    ' lineas de demarcacion
    eExtension2.P[3] = elem.P[9] - elem.P[7]

    'If elem.fParam[cadDimension.ipaRealMeasure] >= 0 Then

    ' cuadrante superior
    ' el texto
    eText.StringData[cadMText.sdaText] = "\\A1;" & Format(elem.fParam[cadDimension.ipaRealMeasure], Me.DimFormat)

    'eText.StringData[cadMText.sdaText] = Format(elem.fParam[cadDimension.ipaRealMeasure], Me.DimFormat)
    ' esta ordenada es horiz, entonces el texto se rota
    eText.fParam[cadMText.ipaTextAngle] = 90

    flxTextExt = glPlus.MTextExtends(eText.StringData[cadMText.sdaText], 0, 0, eText.fParam[cadMText.ipaTextHeight])

    eOblique2.ClassHandler.rotate(eOblique2, -Pi / 2 * IIf(elem.fParam[cadDimension.ipaRealMeasure] >= 0, 1, -1))
    eOblique2.ClassHandler.translate(eOblique2, 0, 3 * Me.DimExtension * IIf(elem.fParam[cadDimension.ipaRealMeasure] >= 0, 1, -1))

    'End If
  Else ' es vertical
    elem.fParam[cadDimension.ipaRealMeasure] = elem.P[7] - elem.P[1]
    eExtension2.P[2] = elem.P[8] - elem.P[6]
    eText.StringData[cadMText.sdaText] = "\\A1;" & Format(elem.fParam[cadDimension.ipaRealMeasure], Me.DimFormat)
    ' esta ordenada es vertical, entonces el texto no se rota
    eText.fParam[cadMText.ipaTextAngle] = 0

    flxTextExt = glPlus.MTextExtends(eText.StringData[cadMText.sdaText], 0, 0, eText.fParam[cadMText.ipaTextHeight])

    eOblique2.ClassHandler.rotate(eOblique2, Pi * IIf(elem.fParam[cadDimension.ipaRealMeasure] >= 0, 0, 1))
    eOblique2.ClassHandler.translate(eOblique2, Me.DimExtension * IIf(elem.fParam[cadDimension.ipaRealMeasure] >= 0, 1, -1), 0)

  End If

  ' texto

  newBlock.x0 = elem.P[6] ' el inserto se mete en el def point
  newBlock.y0 = elem.P[7]

  newBlock.AbsoluteCoords = 2

  Return newBlock

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  e.fParam.Resize(Me.TotalParams)

  ' "entity": "DIMENSION_ORDINATE",
  ' "index": 319,
  ' "type": 20,
  ' "handle": [0, 4936],
  ' "size": 122,
  ' "bitsize": 876,
  ' "_subclass": "AcDbEntity",
  ' "prev_entity": [8, 0, 0, 4935],
  ' "next_entity": [10, 1, 9, 4945],
  ' "layer": [5, 2, 5261, 5261],
  ' "preview_exists": 0,
  ' "entmode": 2,
  ' "nolinks": 0,
  ' "color": 256,
  ' "ltype_scale": 1.0,
  ' "ltype_flags": 0,
  ' "plotstyle_flags": 0,
  ' "invisible": 0,
  ' "linewt": 29,

  '=========================================================================

  ' "_subclass": "AcDbDimension",
  ' "extrusion": [0.0, 0.0, 1.0],
  ' "text_midpt": [339.406966706015, 201.3821301658075],
  ' "elevation": 0.0,
  ' "flag1": 11,
  ' "user_text": "",
  ' "text_rotation": 0.0,
  ' "horiz_dir": 0.0,
  ' "ins_scale": [1.0, 1.0, 1.0],
  ' "ins_rotation": 0.0,
  ' "attachment": 5,
  ' "lspace_style": 1,
  ' "lspace_factor": 1.0,
  ' "act_measurement": 126.38743121141022,
  ' "clone_ins_pt": [0.0, 0.0],
  ' "_subclass": "AcDbOrdinateDimension",
  ' "def_pt": [142.92093415289901, 73.80422276392108, 0.0],
  ' "feature_location_pt": [326.91019506733892, 200.19165397533129, 0.0],
  ' "leader_endpt": [335.5974428964912, 200.19165397533129, 0.0],
  ' "flag2": 0,
  ' "flag": 128,
  ' "dimstyle": [5, 1, 57, 57],
  ' "block": [5, 2, 4937, 4937]

  e.P.Add(0) ' TODO: cuando este terminada la entidad, remover esto
  e.P.Add(0)
  '
  e.P.Add(c["def_pt"][0])
  e.P.Add(c["def_pt"][1])
  '
  ' e.P.Add(c["xline2_pt"][0])
  ' e.P.Add(c["xline2_pt"][1])
  '
  '
  e.fParam[Me.ipaEscX] = 1
  e.fParam[Me.ipaEscY] = 1
  e.fParam[Me.ipaEscZ] = 1
  '
  ' e.fParam[Me.ipaRotacion] = CFloat(c["dim_rotation"]) * 180 / Pi

  Dim hBlock As Integer

  e.Block = gcd.CurrentDrawing.cmodel["BLOCKS"][c["block"][3]]["block_entity"][3]
  'e.pBlock = ReBuildBlock(e)
  'e.Block = gcd.CurrentDrawing.arrBlocks[clsEntities.FIndBlockIDbyHandle(hBlock)].name

  Return True

Catch

  Return False

End
