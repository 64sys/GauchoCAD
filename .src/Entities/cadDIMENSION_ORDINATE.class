' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static

Public Const Gender As String = "Dimension_Ordinate"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Insert a linear acotation")
Public ParamType As String = "PPR"                             ' that is Point, Point, Float; could be Color Text, etc
Public ParamHelper As String = "Start point;End point;extension"
Public Const USEWITH As String = "EntityBuilder"
Public Const OrthogonalIgnored As Boolean = False
Public Const OrthogonalForced As Boolean = False
Public Const ParamDefault As String = " "
Public Const StretchAble As Boolean = True           ' Si lo puedo deformar

Public StepsDone As Integer                 ' esto lo cambia cls ElementBuilder durante la construccion

Public TotalDimensions As Integer           ' the total dimensions present in this drawing

' dimstyle: Todas las variables numericas Float estaran multiplicadas por DimScale
Public DimType As Integer = 0            ' = fParam[0] and &X1111
Public DimAtatchPoint As Integer = 2     ' = fParam[1]
Public DimScale As Integer = 1           ' = fParam[2]
Public DimFormat As String = "0.00"      '
Public DimFormatAng As String = "0.0"    '
Public DimArrowSize As Float = 0.3       ' el largo de la flecha
Public DimArrowWidth As Float = 0.1      ' ancho de la flecha
Public DimTickSize As Float = 0.3        ' el tama√±o de la diagonal
Public DimArrowOrThick As Boolean = True ' flecha (True) o diagonal (False)
Public DimTextHeight As Float = 0.3      '
Public DimSeparation As Float = 0.5      ' la separacion entre el punto que define la cota y el inicio de la linea q marca inicio y fin
Public DimExtension As Float = 0.5       ' la continuacion de esas lineas

Public extension As Float
Public iBloque As Integer

' JSON and DXF Read/Export
Public Const JSON_Reading As Boolean = True
Public Const JSON_Export As Boolean = False
Public Const DXF_Reading As Boolean = True
Public Const DXF_Export As Boolean = True

' fParam helpers
Public Const TotalParams As Integer = 8
Public Const ipaEscX As Integer = 0
Public Const ipaEscY As Integer = 1
Public Const ipaEscZ As Integer = 2
Public Const ipaRotacion As Integer = 3
Public Const ipaVertJustif As Integer = 4
Public Const ipaRelativeFactor As Integer = 5
Public Const ipaObliqueAngle As Integer = 6
Public Const ipaExtension As Integer = 7

' stringdata helpers
Public Const sdaTotalParams As Integer = 2
Public Const sdaText As Integer = 0
Public Const sdaStyle As Integer = 1

' Para mejor generalidad y para compatibilidad futura usaremos los P[] asi con los CODE del DXF
' P[] = DXF CODE
' 0 = 10
' 1 = 20
' 2 = 30    Definition points
' 3 = 11
' 4 = 12
' ......
' 20 = 36

' 21 = 210
' 22 = 220	Extrusion direction(Optional ; Default = 0, 0, 1)
' 23 = 230

' fParam[] = DXF CODE
' se usara asi
' 0 =  70, Dimension type:  Values 0 - 6 are integer values that represent the dimension type.Values 32, 64, And 128 are bit values, which are added To the integer values(value 32 Is Always set In R13 And later releases)
'       0 = Rotated; 1 = Aligned; 2 = Angular; 3 = Diameter; 4 = Radius; 5 = Angular3point; 6 = Ordinate
'       32 = Indicates that the block reference(group code 2) Is Referenced by this dimension only
'       64 = Ordinate type.This Is A bit value(bit 7)used only With integer value 6. If set, ordinate Is X - type; If Not set, ordinate Is Y - type
'       128 = This Is A bit value(bit 8)added To the other group 70 values If the dimension text has been positioned at a user - defined location rather than at the Default location
'
' 1 =  71 Attachment point:
'       1 = Top left ; 2 = Top center; 3 = Top right; 4 = Middle left; 5 = Middle center; 6 = Middle right; 7 = Bottom left; 8 = Bottom center; 9 = Bottom right

' 2 = DimScale

' The entity handler receives a user action, and returns the number of expected parameter
' If definitive = true, means the parameter is set
Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

  ' la linea solo recibe puntos

  If vParam[0] <> "point" Then Return False

  If Me.StepsDone = 0 Then
    Me.DimType = gcd.dimAligned
    clsEntities.setEntity(eBuild)

    Try eBuild.P[0] = vParam[1]
    Try eBuild.P[1] = vParam[2]
    eBuild.P[2] = eBuild.P[0]
    eBuild.P[3] = eBuild.P[1]
    If definitive Then Return True
  Else If Me.StepsDone = 1 Then
    eBuild.DrawAble = True
    eBuild.Finished = True
    Try eBuild.P[2] = vParam[1]
    Try eBuild.P[3] = vParam[2]
    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then Return True
  Else If Me.StepsDone = 2 Then
    If vParam[0] = "point" Then  ' vino como un punto, entonces la calculo de otra manera

      ' return the angle from horizontal to us
      eBuild.fParam[Me.ipaExtension] = -puntos.PointToLineDistance([vParam[1], vParam[2]], [eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]]) ' / puntos.distancia(eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]

    Else If vParam[0] = "float" Then  ' vino como un punto, entonces la calculo de otra manera
      eBuild.fParam[Me.ipaExtension] = vParam[1]

    End If

    eBuild.pBlock = ReBuildBlock(eBuild)
    If definitive Then
      'Stop
      Return True
    End If
  Endif

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

  cadInsert.Translate(e, dx, dy, OnlySelected)

End

Public Sub Rotate(e As Entity, radians As Float)

  cadInsert.Rotate(e, radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

  cadInsert.Scale(e, sx, sy)

End

Public Sub Draw(Optional e As Entity)

  cadInsert.Draw(e)

End

'' A fat version of the entity
Public Sub DrawRemark(oE As Entity)

  cadInsert.DrawRemark(oe)

End

'' A fat version of the entity
Public Sub DrawSelected(oE As Entity)

  cadInsert.DrawSelected(oe)

End

Public Sub ReBuildBlock(ELEM As Entity) As Block

  Dim d As Float, flxTextExt As Float[]
  Dim fRotXY As Float[]

  Dim newBlock As New Block
  Dim f1, f2 As New Float[]

  newBlock.entities = New Entity[]

  ' para definir este bloque necesito 6 entidades
  Dim eLineaPpal As Entity
  Dim eOblique1 As Entity       ' tambien pueden ser flechas Solid
  Dim eOblique2 As Entity
  Dim eExtension1 As Entity
  Dim eExtension2 As Entity
  Dim eDot1 As Entity
  Dim eDot2 As Entity
  Dim eText As Entity
  Dim ePoint2 As Entity

  ' linea principal
  clsEntities.AddLine(newBlock.entities, [0, 0, 0, 0], elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)
  eLineaPpal = newBlock.entities.Last

  ' lineas de demarcacion
  clsEntities.AddLine(newBlock.entities, [0, Me.DimExtension, 0, -Me.DimExtension], elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)
  eExtension1 = newBlock.entities.Last

  clsEntities.AddLine(newBlock.entities, [0, Me.DimExtension, 0, -Me.DimExtension], elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)

  eExtension2 = newBlock.entities.Last

  ' puntos base

  clsEntities.AddPoint(newBlock.entities, [0, 0], elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)

  clsEntities.AddPoint(newBlock.entities, [0, 0], elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)
  ePoint2 = newBlock.entities.Last

  ' flechas

  f1.Insert([0, 0, Me.DimArrowSize, Me.DimArrowWidth, Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])
  f2.Insert([0, 0, -Me.DimArrowSize, Me.DimArrowWidth, -Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])

  clsEntities.Addsolid(newBlock.entities, f1, elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)
  eOblique1 = newBlock.entities.Last

  clsEntities.Addsolid(newBlock.entities, f2, elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)
  eOblique2 = newBlock.entities.Last

  ' texto
  clsEntities.AddMText(newBlock.entities, [0, 0, 0, 0], 0, Me.DimTextHeight, "0.00", elem.colour, elem.LineWidth, elem.LineType, elem.layerid, newBlock.name)
  eText = newBlock.entities.Last

  ' -> el bloque
  'iBloque = clsEntities.FIndBlockID(elem.Block)
  elem.fParam[cadInsert.ipaEscX] = 1      ' ScaleX del inserto
  elem.fParam[cadInsert.ipaEscY] = 1      ' ScaleY del inserto
  elem.fParam[cadInsert.ipaEscZ] = 1      ' ScaleY del inserto

  elem.Visible = True

  ' el largo de la linea principal viene dado por la distancia entre ambos puntos
  d = puntos.distancia(elem.P[0], elem.P[1], elem.P[2], elem.P[3])

  ' con este click calculo el angulo
  elem.fParam[cadInsert.ipaRotacion] = Ang(elem.p[2] - elem.P[0], elem.p[3] - elem.P[1]) * 180 / Pi

  ' la primer entidad del bloque es la linea principal
  eLineaPpal.P[0] = 0           ' X0
  eLineaPpal.P[1] = 0           ' Y0

  eLineaPpal.P[2] = d           ' X1
  eLineaPpal.P[3] = 0           ' Y1

  ePoint2.P[0] = d

  ' la segunda es la primer linea de demarcacion (sin cambios)
  ' eExtension1.P[0] = 0           ' X0
  ' eExtension1.P[1] = 0           ' Y0
  '
  ' eExtension1.P[2] = 0           ' X1
  ' eExtension1.P[3] = 0           ' Y1

  ' la tercera es la segunda linea de demarcacion
  eExtension2.P[0] = d           ' X0
  'eExtension2.P[1] = 0           ' Y0

  eExtension2.P[2] = d           ' X1
  'eExtension2.P[3] = 0           ' Y1

  ' el texto
  eText.StringData[cadMText.sdaText] = Format(d, Me.DimFormat)

  flxTextExt = glPlus.MTextExtends(eText.StringData[0], 0, 0, eText.fParam[1])

  ' la cuarta y quinta son las flechas , tengo que verificar si entran, o el texto
  If flxTextExt[2] * 1.1 > d Then                      ' no entra

    eOblique1.P[0] = d           ' X0
    eOblique1.P[2] = Me.DimArrowSize + d           ' X0
    eOblique1.P[4] = Me.DimArrowSize + d           ' X0
    eOblique1.P[6] = d           ' X0

    eOblique2.P[0] = 0           ' X0
    eOblique2.P[2] = -Me.DimArrowSize
    eOblique2.P[4] = -Me.DimArrowSize
    eOblique2.P[6] = 0           ' X0

    ' el texto va afuera
    eText.P[0] = d + Me.DimArrowSize / 2
    eText.P[1] = Me.DimArrowWidth

  Else                                                                ' entra
    eOblique1.P[0] = 0           ' X0
    eOblique1.P[2] = Me.DimArrowSize
    eOblique1.P[4] = Me.DimArrowSize
    eOblique1.P[6] = 0           ' X0

    eOblique2.P[0] = d           ' X0
    eOblique2.P[2] = -Me.DimArrowSize + d           ' X0
    eOblique2.P[4] = -Me.DimArrowSize + d           ' X0
    eOblique2.P[6] = d           ' X0

    ' el texto va adentro
    eText.P[0] = d / 2 - flxTextExt[2] / 2
    eText.P[1] = Me.DimArrowWidth

  End If

  extension = elem.fParam[Me.ipaExtension]
  ' linea principal
  eLineaPpal.P[1] = extension           ' Y0
  eLineaPpal.P[3] = extension           ' Y1

  ' linea de demarcacion
  eExtension1.P[1] = Me.DimExtension + extension           ' Y0
  eExtension1.P[3] = -Me.DimExtension + extension           ' Y1

  ' segunda linea de demarcacion
  eExtension2.P[1] = Me.DimExtension + extension           ' Y0
  eExtension2.P[3] = -Me.DimExtension + extension           ' Y1

  ' texto
  eText.P[1] = Me.DimArrowWidth + extension

  ' flechas
  eOblique1.P[1] = extension           ' X0
  eOblique1.P[3] = extension + Me.DimArrowWidth
  eOblique1.P[5] = extension - Me.DimArrowWidth
  eOblique1.P[7] = extension           ' X0

  eOblique2.P[1] = extension           ' X0
  eOblique2.P[3] = extension + Me.DimArrowWidth
  eOblique2.P[5] = extension - Me.DimArrowWidth
  eOblique2.P[7] = extension           ' X0

  ' End If
  Return newBlock

End

Public Function Draw2(oE As Entity)

  cadInsert.Draw2(oe)

End

Public Sub CreatePolygon(oE As Entity)

  cadInsert.CreatePolygon(oe)

End

Public Function BuildPOI(oE As Entity, Optional arrIndex As Integer = -1) As Integer

  cadInsert.BuildPOI(oe, arrIndex)

End

' This function will return False if the element couldn't be created for some reason: bad or incomple user input
' True means all is good, False will instruct the clsEntityBuilder to delete it
Public Sub Finish(oE As Entity) As Boolean

  ' primero agregamos la entidad al array
  BuildPOI(oe)

  ' busco el tipo de linea, si hace falta
  If oE.LineTypeName = "Dashed" Then oE.LineType = 1

  oE.psel.resize(oE.p.count / 2)

  oE.DrawAble = True
  oE.Selected = False
  oE.Finished = True
  'cadInsert.Finish(oe)

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As Collection, e As Entity) As Boolean

  e.fParam.Resize(Me.TotalParams)

  ' "entity": "DIMENSION_ORDINATE",
  ' "index": 319,
  ' "type": 20,
  ' "handle": [0, 4936],
  ' "size": 122,
  ' "bitsize": 876,
  ' "_subclass": "AcDbEntity",
  ' "prev_entity": [8, 0, 0, 4935],
  ' "next_entity": [10, 1, 9, 4945],
  ' "layer": [5, 2, 5261, 5261],
  ' "preview_exists": 0,
  ' "entmode": 2,
  ' "nolinks": 0,
  ' "color": 256,
  ' "ltype_scale": 1.0,
  ' "ltype_flags": 0,
  ' "plotstyle_flags": 0,
  ' "invisible": 0,
  ' "linewt": 29,

  '=========================================================================

  ' "_subclass": "AcDbDimension",
  ' "extrusion": [0.0, 0.0, 1.0],
  ' "text_midpt": [339.406966706015, 201.3821301658075],
  ' "elevation": 0.0,
  ' "flag1": 11,
  ' "user_text": "",
  ' "text_rotation": 0.0,
  ' "horiz_dir": 0.0,
  ' "ins_scale": [1.0, 1.0, 1.0],
  ' "ins_rotation": 0.0,
  ' "attachment": 5,
  ' "lspace_style": 1,
  ' "lspace_factor": 1.0,
  ' "act_measurement": 126.38743121141022,
  ' "clone_ins_pt": [0.0, 0.0],
  ' "_subclass": "AcDbOrdinateDimension",
  ' "def_pt": [142.92093415289901, 73.80422276392108, 0.0],
  ' "feature_location_pt": [326.91019506733892, 200.19165397533129, 0.0],
  ' "leader_endpt": [335.5974428964912, 200.19165397533129, 0.0],
  ' "flag2": 0,
  ' "flag": 128,
  ' "dimstyle": [5, 1, 57, 57],
  ' "block": [5, 2, 4937, 4937]

  e.P.Add(0) ' TODO: cuando este terminada la entidad, remover esto
  e.P.Add(0)
  '
  e.P.Add(c["def_pt"][0])
  e.P.Add(c["def_pt"][1])
  '
  ' e.P.Add(c["xline2_pt"][0])
  ' e.P.Add(c["xline2_pt"][1])
  '
  '
  e.fParam[Me.ipaEscX] = 1
  e.fParam[Me.ipaEscY] = 1
  e.fParam[Me.ipaEscZ] = 1
  '
  ' e.fParam[Me.ipaRotacion] = CFloat(c["dim_rotation"]) * 180 / Pi

  Dim hBlock As Integer

  e.Block = gcd.CurrentDrawing.cmodel["BLOCKS"][c["block"][3]]["block_entity"][3]
  'e.pBlock = ReBuildBlock(e)
  'e.Block = gcd.CurrentDrawing.arrBlocks[clsEntities.FIndBlockIDbyHandle(hBlock)].name

  Return True

Catch

  Return False

End
