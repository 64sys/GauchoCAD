' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
'Fast
Inherits CadLine
Public Const Gender As String = "Ray"
Public Const DrawingOrder As Integer = 1        ' 1 = draws first
Public Const HelperTrabajo As String = ("an infinite ray")
Public Const ParamType As String = "PP"                             ' that is Point, Point; could be Color Text, etc
Public Const ParamHelper As String = "Start point;Ray direction"

Private p2 As New Float[]

Private Sub MakeRay(p As Float[])

  p2.Clear

  p2.Add(P[0])
  p2.Add(P[1])

  p2.Add((P[2] - p[0]) * 1e10)
  p2.Add((P[3] - p[1]) * 1e10)

  p2.Add(P[0])
  p2.Add(P[1])

  p2.Add((P[2] - p[0]) * -1e10)
  p2.Add((P[3] - p[1]) * -1e10)

End

Public Sub Draw(oE As Entity)

  If Not oE.Visible Then Return
  If Not oE.DrawAble Then Return
  oE.ColorToPaint = gcd.GetGBColor(oE.colour, oE.pLayer)

  MakeRay(oe.p)

  GLplus.Lines(p2, oE.ColorToPaint, oE.LineWidth, oE.LineType.index)

End

'' A fat version of the line
Public Sub DrawSelected(oE As Entity)

  Dim i As Integer
  Dim iLineType As Integer

  ' If oe.LineType = gcd.stiDashed Then iLineType = 0 Else iLineType = gcd.stiDashed
  MakeRay(oe.p)

  GLplus.Lines(p2, gcd.flgWindowBackColor, oE.LineWidth, iLineType)

  GLplus.Lines(p2, gcd.ColorForSelected, oE.LineWidth, oE.LineType.index)

End
'' A fat version of the line

Public Sub DrawRemark(oE As Entity)

  If Not oE.Visible Then Return

  MakeRay(oe.P)
  If oe.Selected Then
    GLplus.Lines(P2, gcd.flgWindowBackColor, oE.LineWidth + 2, gcd.stiDashed)
    GLplus.Lines(P2, gcd.ColorForSelected, oE.LineWidth + 2, oe.linetype.index)
  Else
    GLplus.Lines(P2, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
    GLplus.Lines(P2, oE.ColorToPaint, oE.LineWidth + 2, oe.linetype.index)
  Endif

End

'' The paint version of the entity
Public Function Draw2(oE As Entity)

  paint.MoveTo(oE.p[0], oE.p[1])
  paint.LineTo(oE.p[2], oE.p[3])
  paint.Stroke

End

'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity, Optional arrIndex As Integer = -1) As Integer

  If arrIndex < 0 Then arrIndex = gcd.CurrentDrawing.oEntities       ' si este valor no es provisto , estos POI son de la ultima entidad

  oe.PoiPoints.Clear
  oe.PoiType.Clear

  ' points: end-mid-end
  oe.poiPoints.insert([oE.p[0], oE.p[1]])
  oe.poiType.Add(gcd.poiEndPoint)

  oe.poiPoints.insert([(oE.P[0] + oE.P[2]) / 2, (oE.P[1] + oE.P[3]) / 2])   ' mid
  oe.poiType.Add(gcd.poiMidPoint)
  'gcd.CurrDrawing.poiEntities.Add(arrIndex)

  oe.poiPoints.insert([oE.p[2], oE.p[3]])
  oe.poiType.Add(gcd.poiEndPoint)
  'gcd.CurrDrawing.poiEntities.Add(arrIndex)

  ' line
  ' gcd.CurrDrawing.poiLines.insert([oE.p[0], oE.p[1], oE.p[2], oE.p[3]])
  ' gcd.CurrDrawing.poiLinesEntities.Add(arrIndex)
  'gcd.CurrDrawing.poiLinesRelPoint.Insert([0, 1])

End

Public Sub ExportDXFCol(e As Entity, ByRef cExport As Collection) As Boolean

  cExport.Add("RAY", dxf.codEntity)
  clsEntities.DXFExportCommonCol(e, cExport)
  cExport.Add("AcDbRay", "100")
  cExport.Add(CStr(e.p[0]), dxf.codX0)  ' Start
  cExport.Add(CStr(e.p[1]), dxf.codY0)
  cExport.Add(CStr(e.p[2]), DXF.codX1)  ' End
  cExport.Add(CStr(e.p[3]), dxf.codY1)

End

' Importo los datos que puedo procesar de una coleccion y genero un Entity para ser agregado a un array
Public Function ImportJsonCol(c As JSONCollection, e As Entity) As Boolean

  'Common Pack
  '   e.dwg = c
  ' e.dwg["index"] = c["index"]
  ' e.dwg["type"] = c["type"]
  ' e.dwg["handle"] = c["handle"]
  ' e.dwg["size"] = c["size"]
  ' e.dwg["bitsize"] = c["bitsize"]
  ' If c.Exist("ownerhandle") Then
  '   e.dwg["ownerhandle"] = c["ownerhandle"]
  ' Endif
  ' e.dwg["_subclass"] = c["_subclass"]
  ' e.dwg["prev_entity"] = c["prev_entity"]
  ' e.dwg["next_entity"] = c["next_entity"]
  ' e.dwg["layer"] = c["layer"]
  ' e.dwg["preview_exists"] = c["preview_exists"]
  ' e.dwg["entmode"] = c["entmode"]
  ' e.dwg["nolinks"] = c["nolinks"]
  ' e.dwg["color"] = 0
  ' e.dwg["ltype_scale"] = 1.0
  ' e.dwg["ltype_flags"] = 1
  ' e.dwg["plotstyle_flags"] = 0
  ' e.dwg["invisible"] = 0
  ' e.dwg["linewt"] = 30
  e.P.Clear
  e.P.Add(c["start"][0])
  e.P.Add(c["start"][1])
  e.P.Add(c["end"][0])
  e.P.Add(c["end"][1])

  Return True

Catch

  Return False

End
