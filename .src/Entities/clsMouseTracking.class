' Gambas class file

Create Static

' poi
Public flgSearchingPOI As Boolean
Public flgSearchingEntity As Boolean

Public Function PoiTotalPoints() As Integer

    Dim i, t As Integer

    For i = 0 To appmain.hFCAD.arrEntities.Max

        t += appmain.hFCAD.arrEntities[i].PoiType.Count
    Next
    Return t

End

'' Creo el array de POIpoints
'' son los puntos que van a enganchar el mouse

Fast Unsafe Public Sub ReBuildPOIPoints()

Dim i, ii, n As Integer, EPoi As New Integer[], nPois As Integer
Dim rData As New Float[]
Dim e, breathe, iPoligon, iLine, iTotalPoints As Integer
Dim t As Float = Timer

APPMain.hFCAD.poiPoints.Clear           ' limpio
APPMain.hFCAD.poiType.Clear

iTotalPoints = PoiTotalPoints()         ' calculo el tama√±o total para redimensionar, esto es mas rapido que ir insertando

APPMain.hFCAD.poiType.Resize(iTotalPoints)
appmain.hFCAD.poiEntities.Resize(iTotalPoints)
APPMain.hFCAD.poiPoints.Resize(iTotalPoints * 2)

For e = 0 To APPMain.hFCAD.arrEntities.Max

    For i = 0 To APPMain.hFCAD.arrEntities[e].PoiType.Max
        APPMain.hFCAD.poiType[ii] = APPMain.hFCAD.arrEntities[e].PoiType[i]
        appmain.hFCAD.poiEntities[ii] = e
        APPMain.hFCAD.poiPoints[ii * 2] = APPMain.hFCAD.arrEntities[e].PoiPoints[i]
        APPMain.hFCAD.poiPoints[ii * 2 + 1] = APPMain.hFCAD.arrEntities[e].PoiPoints[i + 1]
        Inc ii
    Next

Next
Debug "POI points built in ", Timer - t

For e = 1 To APPMain.hFCAD.arrEntities.Max
    If e = APPMain.hFCAD.arrEntities.Max Then t = Timer

    RebuilIntersections(e)

Next

Debug "POI points built in ", Timer - t

End

Fast Unsafe Public Sub RebuilIntersections(iEntity As Integer)

Dim i, i2, n As Integer, EPoi As New Integer[], nPois As Integer
Dim rData As New Float[]
Dim breathe, iPoligon, iLine, iTotalPoints As Integer
Dim t As Float = Timer
Dim e As Entity

e = APPMain.hFCAD.arrEntities[iEntity]

' veo cada caso en particular
Select Case e.Gender
    Case "Line"
        For i2 = iEntity - 1 To 0 Step -1

            Select Case APPMain.hFCAD.arrEntities[i2].Gender

                Case "Line"
                    If puntos.doIntersect(e.P[0], e.P[1], e.P[2], e.P[3], APPMain.hFCAD.arrEntities[i2].P[0], APPMain.hFCAD.arrEntities[i2].P[1], APPMain.hFCAD.arrEntities[i2].P[2], APPMain.hFCAD.arrEntities[i2].P[3]) Then
                        APPMain.hFCAD.poiPoints.Insert(puntos.lineLineIntersection([e.P[0], e.P[1]], [e.P[2], e.P[3]], [APPMain.hFCAD.arrEntities[i2].P[0], APPMain.hFCAD.arrEntities[i2].P[1]], [APPMain.hFCAD.arrEntities[i2].P[2], APPMain.hFCAD.arrEntities[i2].P[3]]))
                        appmain.hFCAD.poiEntities.Add(iEntity)
                        APPMain.hFCAD.poiType.Add(gcd.poiIntersection)

                    Endif

            End Select
        Next
End Select

End

'' Creo el array de POI
'' son los puntos que van a enganchar el mouse

Public Sub ReBuildPOI()

    Dim i, ii, n As Integer, EPoi As New Integer[], nPois As Integer
    Dim rData As New Float[]
    Dim e, breathe, iPoligon, iLine, iPoint As Integer
    Dim t As Float = Timer

    APPMain.hFCAD.poiEntities.Clear
    APPMain.hFCAD.poiLines.Clear
    APPMain.hFCAD.poiLinesEntities.Clear
    APPMain.hFCAD.poiPoints.Clear
    APPMain.hFCAD.poiPoligonElements.Clear
    APPMain.hFCAD.poiPoligonEntities.Clear
    APPMain.hFCAD.poiPoligons.Clear
    APPMain.hFCAD.poiPoligonStartIndex.Clear
    APPMain.hFCAD.poiType.Clear

    For e = 0 To APPMain.hFCAD.arrEntities.Max

        Select Case APPMain.hFCAD.arrEntities[e].Gender

            Case "Line"

                appmain.hFCAD.poiLines.insert([APPMain.hFCAD.arrEntities[e].p[0], APPMain.hFCAD.arrEntities[e].p[1], APPMain.hFCAD.arrEntities[e].p[2], APPMain.hFCAD.arrEntities[e].p[3]])
                APPMain.hFCAD.poiLinesEntities.Add(e)

            Case "PLine"
                For i = 0 To APPMain.hFCAD.arrEntities[e].P.count - 4 Step 2
                    appmain.hFCAD.poiLines.insert([APPMain.hFCAD.arrEntities[e].p[i], APPMain.hFCAD.arrEntities[e].p[i + 1], APPMain.hFCAD.arrEntities[e].p[i + 2], APPMain.hFCAD.arrEntities[e].p[i + 3]])
                Next
                For i = 0 To APPMain.hFCAD.arrEntities[e].P.Count / 4
                    APPMain.hFCAD.poiLinesEntities.Add(e)
                Next
            Case "Circle", "Arc", "Ellipse"
                appmain.hFCAD.poiLines.insert(APPMain.hFCAD.arrEntities[e].PolyLine)
                For i = 0 To APPMain.hFCAD.arrEntities[e].PolyLine.Count / 4
                    APPMain.hFCAD.poiLinesEntities.Add(e)
                Next
            Case "Solid", "Text", "MText"

                appmain.hFCAD.poiPoligons.insert(APPMain.hFCAD.arrEntities[e].Polygon)
                APPMain.hFCAD.poiLinesEntities.Add(e)

        End Select

    Next

    Debug "POI arrays regenerados en ", Timer - t

End

'' Veo si estoy sobre una entidad y la devuelvo
Public Function CheckAboveEntity(xr As Float, Yr As Float, tolerance As Float) As Integer

    Dim rData As New Float[], angle, angle2 As Float
    Dim e, i, breathe, iPoligon, iLine, iPoint As Integer
    Dim Found As Boolean = True
    Dim major, minor, la As Float
    Dim x, y, theta, angle_increment As Float

    Dim T As Float = Timer

    flgSearchingEntity = True
    For e = 0 To APPMain.hFCAD.arrEntities.Max      ' for each es 10 veces mas lento que recorrer el array

        Select Case APPMain.hFCAD.arrEntities[e].Gender

            Case "Line"

                If puntos.doIntersect(xr - tolerance, yr, xr + tolerance, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1], APPMain.hFCAD.arrEntities[e].P[2], APPMain.hFCAD.arrEntities[e].P[3]) Or puntos.doIntersect(xr, yr - tolerance, xr, yr + tolerance, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1], APPMain.hFCAD.arrEntities[e].P[2], APPMain.hFCAD.arrEntities[e].P[3]) Then Break

            Case "PLine"

                For i = 0 To APPMain.hFCAD.arrEntities[e].P.count - 4 Step 2
                    If puntos.doIntersect(xr - tolerance, Yr, Xr + tolerance, Yr, APPMain.hFCAD.arrEntities[e].P[i + 0], APPMain.hFCAD.arrEntities[e].P[i + 1], APPMain.hFCAD.arrEntities[e].P[i + 2], APPMain.hFCAD.arrEntities[e].P[i + 3]) Or puntos.doIntersect(xr, Yr - tolerance, Xr, Yr + tolerance, APPMain.hFCAD.arrEntities[e].P[i + 0], APPMain.hFCAD.arrEntities[e].P[i + 1], APPMain.hFCAD.arrEntities[e].P[i + 2], APPMain.hFCAD.arrEntities[e].P[i + 3]) Then Goto ExitSearch
                Next
            Case "Circle"

                If Abs(puntos.distancia(xr, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1]) - APPMain.hFCAD.arrEntities[e].fParam[0]) < tolerance Then Break
                If puntos.Around(xr, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1], tolerance) Then Break

            Case "Arc"

                If puntos.Around(xr, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1], tolerance) Then Break

                If Abs(puntos.distancia(xr, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1]) - APPMain.hFCAD.arrEntities[e].fParam[0]) < tolerance Then

                    ' tengo que ver si esa en la porcion
                    angle = Ang(xr - APPMain.hFCAD.arrEntities[e].P[0], yr - APPMain.hFCAD.arrEntities[e].P[1]) * 180 / Pi
                    If angle < 0 Then angle += 360
                    If APPMain.hFCAD.arrEntities[e].fParam[1] <= APPMain.hFCAD.arrEntities[e].fParam[2] Then
                        If angle >= APPMain.hFCAD.arrEntities[e].fParam[1] And angle <= APPMain.hFCAD.arrEntities[e].fParam[2] Then Break
                    Else
                        If angle >= APPMain.hFCAD.arrEntities[e].fParam[1] Or angle <= APPMain.hFCAD.arrEntities[e].fParam[2] Then Break
                    End If

                End If

            Case "Ellipse"

                ' necesito determinar el radio en el angulo del punto que estaria sobre la elipse
                angle = Ang(xr - APPMain.hFCAD.arrEntities[e].P[0], yr - APPMain.hFCAD.arrEntities[e].P[1]) ' * 180 / Pi

                ' el radio en este agulo viene dado por

                major = Sqr((APPMain.hFCAD.arrEntities[e].p[2] - APPMain.hFCAD.arrEntities[e].p[0]) ^ 2 + (APPMain.hFCAD.arrEntities[e].p[3] - APPMain.hFCAD.arrEntities[e].p[1]) ^ 2)
                Minor = major * APPMain.hFCAD.arrEntities[e].fParam[0]
                angle2 = Ang(APPMain.hFCAD.arrEntities[e].p[2] - APPMain.hFCAD.arrEntities[e].p[0], APPMain.hFCAD.arrEntities[e].p[3] - APPMain.hFCAD.arrEntities[e].p[1])

                x = major * Cos(angle) * Cos(angle2) - minor * Sin(angle) * Sin(angle2)
                y = major * Cos(angle) * Sin(angle2) + minor * Sin(angle) * Cos(angle2)

                ' veo si en esa posicion esta cerca de la elipse
                If Abs(puntos.distancia(xr, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1]) - Sqr(x * x + y * y)) < tolerance Then
                    ' tengo que ver si esa en la porcion
                    angle = Angle * 180 / Pi
                    If angle < 0 Then angle += 360
                    If APPMain.hFCAD.arrEntities[e].fParam[1] <= APPMain.hFCAD.arrEntities[e].fParam[2] Then
                        If angle >= APPMain.hFCAD.arrEntities[e].fParam[1] And angle <= APPMain.hFCAD.arrEntities[e].fParam[2] Then Break
                    Else
                        If angle >= APPMain.hFCAD.arrEntities[e].fParam[1] Or angle <= APPMain.hFCAD.arrEntities[e].fParam[2] Then Break
                    End If
                    'Break

                End If

                ' ademas verifico si esta sobre el centro

                If puntos.Around(xr, yr, APPMain.hFCAD.arrEntities[e].P[0], APPMain.hFCAD.arrEntities[e].P[1], tolerance) Then Break

            Case "Solid", "Text", "MText"

                ' Text, MText, Solid y otros
                If puntos.isInside(APPMain.hFCAD.arrEntities[e].Polygon, xr, yr) Then Break

        End Select

        modUtils.DoEvents(0.100)

    Next

ExitSearch:

    flgSearchingEntity = False
    'Debug "Above entity en ", Timer - t
    If e = APPMain.hFCAD.arrEntities.Count Then

        Return -1
    Else

        Return e

    End If

End

'' This is called by MouseMove events, so make sure its fast
'' and its called form there
Public Sub CheckPOI(xr As Float, Yr As Float) As Float[]

    Dim rData As New Float[], e As Entity
    Dim indexEntity, i, i2, iPoligon, iLine, iPoint As Integer
    Dim pend1, base1, pend2, base2 As Float ' vars para las ecuacionesde las rectas
    Dim puntoB, puntoA, pInter As New Float[]

    ' distancias  los enganches, para determinar cual es el mas cercano al puntero
    Dim DistPer As Float = 1e6
    Dim DistEnd1 As Float = 1e6
    Dim DistEnd2 As Float = 1e6
    Dim DistMid As Float = 1e6
    Dim DistBase As Float = 1e6
    Dim DistTang As Float = 1e6
    Dim DistQuad As Float = 1e6
    Dim DistCenter As Float = 1e6
    Dim DistInter As Float = 1e6
    Dim Dist As Float = 1e5  ' el menor

    ' If Me.flgSearchingPOI Then Return   ' no nesting this
    Me.flgSearchingPOI = True

    Dim t As Float = Timer

    'Debug "Checking POI"

    iPoligon = -1
    iLine = -1

    'iPoligon = puntos.FindPOIPoligon(xr, yr, APPMain.hFCAD.poiPoligons, APPMain.hFCAD.poiPoligonStartIndex, APPMain.hFCAD.poiPoligonElements)
    'iLine = puntos.FindPOILines(xr, yr, APPMain.hFCAD.poiLines, APPMain.hFCAD.Metros(16))
    ' rdata = puntos.FindPOI(xr, yr, APPMain.hFCAD.poiPoints, APPMain.hFCAD.Metros(16))
    ' i = rdata[2]
    ' If i >= 0 Then
    '     rData[2] = appmain.hFCAD.poiType[i]
    '     rData.Add(appmain.hFCAD.poiEntities[i])
    '
    ' Else
    '     rdata.Clear
    '     rdata.Insert([0, 0, -1, -1])
    ' Endif
    ' Me.flgSearchingPOI = False
    ' Return rdata
    'Debug "total poi check time ", Timer - t, APPMain.hFCAD.poiPoligons.Count + APPMain.hFCAD.poiLines.Count + APPMain.hFCAD.poiPoints.Count, " points parsed"

    indexEntity = CheckAboveEntity(xr, yr, APPMain.hFCAD.Metros(16))

    ' If iLine > 0 Then e = appmain.hFCAD.arrEntities[appmain.hFCAD.poiLinesEntities[iLine]]
    ' If iPoligon > 0 Then e = appmain.hFCAD.arrEntities[iPoligon]
    rdata.Insert([0, 0, -1, -1])

    If indexEntity >= 0 Then                                               ' ofrezco opciones de enganche
        e = APPMain.hFCAD.arrEntities[indexEntity]
        'Debug "Encontrada entidad ", e.Gender, " en ", Timer - t
        If APPMain.hFCAD.LastPoint.max > 0 Then                     ' tengo un punto anterior

            Select Case e.Gender

                Case "Line"

                    ' perpendicular

                    If e.P[2] - e.P[0] <> 0 Then
                        pend1 = (e.P[3] - e.P[1]) / (e.P[2] - e.P[0])
                        base1 = e.P[1] - pend1 * e.P[0]                 ' Y = pend1 X + base1

                        ' ecuacion de la recta perpendicular que pasa por el punto anterior
                        If pend1 <> 0 Then
                            pend2 = -1 / pend1
                            base2 = APPMain.hFCAD.LastPoint[1] - pend2 * APPMain.hFCAD.LastPoint[0]

                            ' necesito otro punto
                            If APPMain.hFCAD.LastPoint[0] <> 0 Then
                                puntoA.Add(0)
                                puntoA.Add(base2)
                            Else
                                puntoA.Add(1)
                                puntoA.Add(pend2 + base2)

                            End If

                            ' determino la interseccion de ambas
                            puntoB = puntos.lineLineIntersection(APPMain.hFCAD.LastPoint, puntoA, [e.P[0], e.P[1]], [e.P[2], e.P[3]])
                        Else ' la recta es horizontal

                            puntoB.Add(APPMain.hFCAD.LastPoint[0])
                            puntoB.Add(e.P[1])

                        End If
                    Else        ' la recta es vertical

                        puntoB.Add(e.P[0])
                        puntoB.Add(APPMain.hFCAD.LastPoint[1])

                    End If

                    ' veo si el punto b esta entre los extremos de la linea , aunque deberia estarlo!!!
                    If puntos.onSegment(e.P[0], e.P[1], puntoB[0], puntoB[1], e.P[2], e.P[3]) Then

                        ' determino la distancia al puntero para ofrecerlo como opcion de enganche
                        DistPer = puntos.distancia(puntoB[0], puntoB[1], xr, yr)

                    Endif

                    ' busco tambien intersecciones
                    For i2 = 0 To APPMain.hFCAD.arrEntities.Max
                        Select Case APPMain.hFCAD.arrEntities[i2].Gender

                            Case "Line"
                                If puntos.doIntersect(e.P[0], e.P[1], e.P[2], e.P[3], APPMain.hFCAD.arrEntities[i2].P[0], APPMain.hFCAD.arrEntities[i2].P[1], APPMain.hFCAD.arrEntities[i2].P[2], APPMain.hFCAD.arrEntities[i2].P[3]) Then
                                    pInter = puntos.lineLineIntersection([e.P[0], e.P[1]], [e.P[2], e.P[3]], [APPMain.hFCAD.arrEntities[i2].P[0], APPMain.hFCAD.arrEntities[i2].P[1]], [APPMain.hFCAD.arrEntities[i2].P[2], APPMain.hFCAD.arrEntities[i2].P[3]])
                                    DistInter = puntos.distancia(xr, yr, pInter[0], pInter[1])

                                Endif

                            Case "PLine"

                        End Select
                    Next

                Case "Circle"
                    ' buscamos una tangente..

                    ' Extraido de StackExchange
                    ' #Data Section, change As You need #
                    ' Cx, Cy = coordenadas del centro
                    Dim Cx As Float = e.p[0]
                    Dim Cy As Float = e.p[1]
                    Dim tx, ty, t1x, t1y, t2x, t2y As Float
                    Dim r As Float = e.fParam[0]

                    Dim Px As Float = APPMain.hFCAD.LastPoint[0]
                    Dim Py As Float = APPMain.hFCAD.LastPoint[1]

                    Dim dx As Float = Px - Cx
                    Dim dy As Float = Py - Cy
                    Dim dxr As Float = -dy
                    Dim dyr As Float = dx
                    DistCenter = Sqr(dx ^ 2 + dy ^ 2)               ' y ya que estoy veo el Center

                    If DistCenter >= r Then
                        Dim rho As Float = r / DistCenter
                        Dim ad As Float = rho ^ 2
                        Dim bd As Float = rho * Sqr(1 - rho ^ 2)

                        ' los puntos tangente
                        T1x = Cx + ad * dx + bd * dxr
                        T1y = Cy + ad * dy + bd * dyr
                        T2x = Cx + ad * dx - bd * dxr
                        T2y = Cy + ad * dy - bd * dyr

                        If (DistCenter / r - 1) < 1E-8 Then
                            'P is on the circumference
                        Else    ' determino cual de las dos tangentes es la mas cercana

                            If puntos.distancia(xr, yr, t1x, t1y) > puntos.distancia(xr, yr, t2x, t2y) Then
                                Tx = T2x
                                Ty = T2y
                            Else
                                Tx = T1x
                                Ty = T1y

                            Endif
                            DistTang = puntos.distancia(xr, yr, tx, ty)
                        End If
                    Else ' esta dentro del circulo

                        DistTang = 1e6
                        ' No tangent Is Possible
                    End If

                    ' busco los quadrants
                    Dim qx, qy, q1, q2, q3, q4 As Float
                    q1 = puntos.distancia(e.P[0] - e.fParam[0], e.P[1], xr, yr)
                    q2 = puntos.distancia(e.P[0] + e.fParam[0], e.P[1], xr, yr)
                    q3 = puntos.distancia(e.P[0], e.P[1] - e.fParam[0], xr, yr)
                    q4 = puntos.distancia(e.P[0], e.P[1] + e.fParam[0], xr, yr)

                    DistQuad = 1e10
                    If DistQuad > q1 Then
                        DistQuad = q1
                        qx = e.P[0] - e.fParam[0]
                        qy = e.P[1]
                    End If
                    If DistQuad > q2 Then
                        DistQuad = q2
                        qx = e.P[0] + e.fParam[0]
                        qy = e.P[1]
                    End If
                    If DistQuad > q3 Then
                        DistQuad = q3
                        qx = e.P[0]
                        qy = e.P[1] - e.fParam[0]
                    End If
                    If DistQuad > q4 Then
                        DistQuad = q4
                        qx = e.P[0]
                        qy = e.P[1] + e.fParam[0]
                    End If

            End Select
        End If
        ' otros puntos
        Select Case e.Gender
            Case "Line"

                DistEnd1 = puntos.distancia(e.P[0], e.P[1], xr, yr)

                DistEnd2 = puntos.distancia(e.P[2], e.P[3], xr, yr)

                DistMid = puntos.distancia((e.P[2] + e.P[0]) / 2, (e.P[3] + e.P[1]) / 2, xr, yr)

            Case "Text", "MText"

                DistBase = puntos.distancia(e.P[0], e.P[1], xr, yr)

            Case "Circle", "Ellipse", "Arc"

                DistCenter = puntos.distancia(e.P[0], e.P[1], xr, yr)

        End Select

        ' veo cual es la opcion mas cercana al puntero

        ' dist = Min(DistBase, DistCenter, DistEnd1, DistEnd2, DistMid, DistPer, DistQuad) ' NO FUNCIONA

        If Dist > DistBase Then dist = DistBase
        If Dist > DistCenter Then dist = DistCenter
        If Dist > DistEnd1 Then dist = DistEnd1
        If Dist > DistEnd2 Then dist = DistEnd2
        If Dist > DistMid Then dist = DistMid
        If Dist > DistPer Then dist = DistPer
        If Dist > DistQuad Then dist = DistQuad
        If Dist > DistTang Then dist = DistTang
        If Dist > DistInter Then dist = DistInter

        ' ofrezco ese punto
        If dist = DistEnd1 Then
            rData[0] = e.P[0]
            rData[1] = e.P[1]
            rData[2] = gcd.poiEndPoint
            clsDrawingAids.Helper.texto = "EndPoint"
        End If

        ' ofrezco ese punto
        If dist = DistEnd2 Then
            rData[0] = e.P[2]
            rData[1] = e.P[3]
            rData[2] = gcd.poiEndPoint
            clsDrawingAids.Helper.texto = "EndPoint"
        End If

        ' ofrezco ese punto
        If dist = DistMid Then
            rData[0] = (e.P[2] + e.P[0]) / 2
            rData[1] = (e.P[3] + e.P[1]) / 2
            rData[2] = gcd.poiMidPoint
            clsDrawingAids.Helper.texto = "MidPoint"
        End If

        ' ofrezco ese punto
        If dist = DistInter Then
            rData[0] = pInter[0]
            rData[1] = pInter[1]
            rData[2] = gcd.poiIntersection
            clsDrawingAids.Helper.texto = "Intersection"
        End If

        ' ofrezco ese punto
        If dist = DistPer Then

            rData[0] = puntoB[0]
            rData[1] = puntoB[1]
            rData[2] = gcd.poiPerpendicular
            clsDrawingAids.Helper.texto = "Perpendicular"
        End If

        If dist = DistTang Then

            rData[0] = tx
            rData[1] = ty
            rData[2] = gcd.poiTangent
            clsDrawingAids.Helper.texto = "Tangent"
        End If

        If dist = DistCenter Then

            rData[0] = e.p[0]
            rData[1] = e.p[1]
            rData[2] = gcd.poiCenter
            clsDrawingAids.Helper.texto = "Center"
        End If

        If dist = DistQuad Then
            rData[0] = qx
            rData[1] = qy
            rData[2] = gcd.poiQuadrant
            clsDrawingAids.Helper.texto = "Quadrant"
        End If

        If dist = DistBase Then
            rData[0] = e.P[0]
            rData[1] = e.P[1]
            rData[2] = gcd.poiBasePoint
            clsDrawingAids.Helper.texto = "BasePoint"
        End If

        rData[3] = indexEntity

    Else
        'Debug "Sin POI", Timer - t
        clsDrawingAids.Helper.texto = ""
        rData[0] = xr
        rData[1] = yr
        rData[2] = -1
        rData[3] = -1
    End If
    ' Debug "pois checked"
    Me.flgSearchingPOI = False
    Return rData

End
