' Gambas class file

' Tool maintained by Terco
' PlantDesigner
' Software para diseño de plantas tipo de hormigon
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
' Gambas class file

' Credits
' --------
' Icon design por Trinh Ho ,Good Ware, freepik get them at https://www.flaticon.es
' Scheme inspired on example called MuchosCirculos by JGuardon y Shell
' XML Load/Save by Tincho
' GUI by Postpase/Tincho

Public tmr33Hz As Integer                   ''  +1  every 33Hz so it goes from 0 to 1E32

Public KeysAccumulator As String
Public FirstTime As Boolean = True
Public DrawingReady As Boolean = False
Public DrawNeedsUpdate As Boolean                   '' true on mouse, key or tool events
Public TimerTic As Integer = 0                      '' this reaches 1024 and then zeroes, at 33Hz
Public nDraws As Integer
Public nDrawsRequired As Integer
Public idDrawing As Integer

' vars particulares de cada pestaña

Public CursorX As Integer
Public CursorY As Integer
Public PanX As Integer = 0              '' trnaslation of th 0,0 from the corner of the drawing area
Public PanY As Integer = 0              '' in pixels
Public ScaleZoom As Float
Public Propiedadtest As String
'-----------------------------------
Public cModel As New Collection     '' ALl data from a GauchoCAD xml file is loaded here
Public cImport As New Collection    '' Impor data from dxf, dwg is loaded here

Public Struct arrBlockSt
  name As String
  x As Float
  y As Float
  scaleX As Float
  scaleY As Float
  degRotation As Float
  mirrored As Boolean
  layer As String
  entities As Entity[]
End Struct

Public arrBlocks As New ArrBlockSt[]
Public arrEntities As New Entity[]             '' were al elements live
Public arrTmp As New Entity[]             '' Temporal array to put a copy of an entity before change something in it
Public arrUndo As New Entity[]             '' An array to put an unmodified copy of an entity before modifying it and then restoring it to the previous version.

Public arrSelecIndex As New Integer[]          '' indice en el array de entidades

Public Xmenor As Float = 1E100
Public Xmayor As Float = -1E100
Public Ymenor As Float = 1E100
Public Ymayor As Float = -1E100

' point of interests, lines, areas and entities: all this is generated n the entity creation
Public poiPoints As New Float[]                 '' xy pairs of points
Public poiType As New Integer[]                 '' tipe of poi: End, Mid, Quadrant, Tangent
Public poiEntities As New Integer[]             '' related entity

Public poiLines As New Float[]                  '' x0y0x1y1 points
Public poiLinesEntities As New Integer[]        '' related entity

Public poiPoligons As New Float[]               '' this define multiple poligons to search for proximity
Public poiPoligonStartIndex As New Integer[]
Public poiPoligonElements As New Integer[]
Public poiPoligonEntities As New Integer[]      '' related entity

' interaccion del mouse en pantalla
Public LastPoint As New Float[]                '' ultimo punto marcado o null si no existe
Public iEntity As New Single[]             '' las coordenadas del punto encontrado y el tipo de punto
Public flgShowPOIinfo As Boolean = True

' OpenGl stuff
Public GlListAllEntities As Integer
Public GlListSelectedEntities As Integer

' Form variables
'Private WindowBackMode As String

Public Sub Form_Open()

  Debug "open " & Me.Title

End

Public Sub Form_Close()

  FInspector.Close

End

Public Sub Form_Resize()

  Debug "resize " & Me.Title
  GLplus.Init(glarea1)

End

Public Sub Form_Arrange()

  Debug "arrange " & Me.Title

End

Public Sub Form_Activate()

  Debug "activate " & Me.Title
  If FirstTime Then           ' esto ocurre cuando me llega un archivo cargado que tengo que mostrar por primera vez
    Debug "FirstTIme " & Me.Title
    Debug "FirstTIme " & Me.Title
    gcd.ImportBlocks(cModel)
    gcd.ImportModel(cModel["Entities"], arrEntities)
    gcd.ApplyLayerProperties(1)
    Regen()                 ' estas dos lineas se agregan porque la ventana carga un archivo en _New pero no lo
    cadZoomE.Start()        ' puede mostrar hasta tener una GLArea conformada y a la vista
    FirstTime = False
    DrawingReady = True
    GLplus.Init(glarea1)    ' Esto corrige el que no se van lo que se dibuja
  Endif
  If cImport.Count > 0 Then

    EntitiesTransfer2()
    BlocksTransfer()
    LayersTransfer()
    LoadDrawingMap2()
    APPMain.LoadComboboxes(cModel)
    'APPMain.LoadComboboxes(cModel)
    gcd.ImportBlocks(cModel)
    gcd.ImportModel(cModel["Entities"], arrEntities)
    cImport.Clear
    gcd.ApplyLayerProperties(1)
    regen
    'clsMouseTracking.ReBuildPOIPoints
    cadZoomE.Start()
  Endif

End

Public Sub GLArea1_draw()

  Dim iParent As Integer

  If Not DrawingReady Then Return

  gcd.drwDrawingClass = gcd.drwOpenGLClass

  gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)

  gl.LoadIdentity

  gl.Translatef(PanX, PanY, 0)

  gl.Scalef(ScaleZoom, ScaleZoom, 1)

  ' el orden del dibujo es importante en paint, porque una cosa tapa a la otra; en openGL aparentemente es al reves, lo primero se dibuja primero

  ' Primero la grid
  ' clsDrawingAids.DrawGrid

  If gcd.DrawBounds Then clsDrawingAids.DrawPolygons

  ' entidad resaltada
  If iEntity[3] >= 0 And iEntity[3] < arrEntities.Count Then

    ' si no esta seleccionada, la resalto
    If Not arrEntities[iEntity[3]].Selected Then
      iParent = clsEntities.GetParentBlock(iEntity[3]) ' esto verifica si tiene que resaltar el bloque completo
      arrEntities[iParent].ClassHandler.DrawRemark(arrEntities[iParent])
    End If

  End If
  clsDrawingAids.DrawCoordenadas

  clsDrawingAids.DibujaHelper

  gcd.clsJob.Draw

  gl.CallList(GlListAllEntities)                      ' si GL no tiene contexto, la lista no se genera. Es necesario que la instancia de FCAD este cargada.

  ' POI dinamicos
  If flgShowPOIinfo Then

    ' Select Case iEntity[2]
    '     Case gcd.poimi
    glPlus.Rectangle2D(iEntity[0] - Metros(4), iEntity[1] - Metros(4), Metros(8), Metros(8), Color.Blue,,,, Color.Blue, 1, 1)
    ' Case 2
    '     glPlus.PolygonFilled([iEntity[0] - Metros(4), iEntity[1], iEntity[0], iEntity[1] + Metros(4), iEntity[0] + Metros(4), iEntity[1], iEntity[0], iEntity[1] - Metros(4)], Color.Blue, Color.Green)

    'End Select

  Endif

  'Debug "redraw"

End

' Protocolo del Mouse
'--------------------

' Rigth Clicks  ---> No son enviados a las clases herramienta/entidad; son procesados por FCAD como accion es que terminan o empiezan algo. Tanto MouseDown/Up
'   MouseDown ---------> Lo ignoro
'   MouseUp -----------> A-Trabajo activo? Mando señal de Finalizar/Cancelar ya mismo
'                        B- Click en objeto: muestro las propiedades frmPropiedades (aun no implementado)
'                           Click en el aire: Equivale a <enter> que repite el trabajo anterior, si lo hubo.

' Wheel -----------> Es utilizado como zoom. No es enviado a las clases.

' MouseMove--------> 1-Trabajo activo? --> Se envia el evento
'                    2-Paneando? Se actualizan los valores de PanX/Y y se refresca la pantalla

' Left Clicks
'   MouseDown------> 1- Trabajo activo? -> Se envia a la clase que trabaja gcd.clsJobs si hay una activa. Sino se analziza donde fue el click.
'                    2- no hay trabajos:
'                           2.a- Click en el aire  --> o Paneo, segun el boton que este presionado.
'                           2.b- Click en objeto   --> De/selecciono el objeto
'
'
'
'   MouseUp-------->1-Trabajo activo: ---> envio evento
'
'

Public Sub GLArea1_MouseDown()

  If Mouse.Right Then Return  'handled in MouseUp

  Select Case gcd.clsJob.gender

    Case "Default"                                                  ' 1. Seleccionando

      gcd.clsJob.mouseDown(mouse.x, mouse.y)                               '    -> envio el evento a la clase default

    Case "Builder"                                                  ' 2.Construyendo una entidad

      gcd.clsJob.mouseDown(mouse.x, mouse.y)                                   '      y envio el evento a la clase

    Case Else

      gcd.clsJob.mouseDown(mouse.x, mouse.y)                                   ' dispatch event to the Job

  End Select

  redraw

End

Public Sub GLArea1_MouseMove()

  CursorX = mouse.x
  CursorY = mouse.y

  Select Case gcd.clsJob.gender

    Case "Default"                                                  ' 1. Seleccionando
      flgShowPOIinfo = False
      If gcd.clsJob.poichecking Then
        If Not clsMouseTracking.flgSearchingEntity Then
          iEntity[3] = clsMouseTracking.CheckAboveEntity(Xreal(mouse.x), Yreal(mouse.Y), Metros(16))
        End If
      End If
      gcd.clsJob.MouseMove(mouse.x, mouse.y) ' dispatch event to the Job

      If gcd.ShowInspector Then

        If iEntity[3] >= 0 Then

          FInspector.Run(arrEntities[iEntity[3]])
        Else
          FInspector.Close

        Endif
      End If
    Case Else

      If gcd.clsJob.poichecking Then
        If Not clsMouseTracking.flgSearchingPOI Then
          iEntity = clsMouseTracking.CheckPOI(Xreal(mouse.x), Yreal(mouse.Y))
        Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior

          iEntity[0] = Xreal(mouse.x)
          iEntity[1] = Yreal(mouse.y)
          iEntity[2] = -1                 ' POI type
          iEntity[3] = -1                 ' Hooked entity

        End If

      End If

      If gcd.clsJob.EntityChecking Then
        If Not clsMouseTracking.flgSearchingEntity Then
          iEntity[3] = clsMouseTracking.CheckAboveEntity(Xreal(mouse.x), Yreal(mouse.Y), Metros(16))
        End If
      End If

      flgShowPOIinfo = True

      clsDrawingAids.Helper.dX = 15
      clsDrawingAids.Helper.dY = 15
      clsDrawingAids.Helper.fColor = Color.DarkBlue
      gcd.clsJob.MouseMove(mouse.x, mouse.y) ' dispatch event to the Job

  End Select

  redraw

End

Public Sub GLArea1_MouseUp()
  ' ex Public Sub drwArea_MouseUp()

  ' "Los IF son mas rapidos" - Autor Anonimo

  ' los rigth clicks se manejan en FCAD , ni las herramientas ni las entidades los necesitan
  If Mouse.Right Then                ' rigth clicks means finish what you're doing rigth now and go back to the previous Job
    ' the Finish() sub will do this in a good manner
    If gcd.clsJob.gender <> "Default" Then
      gcd.clsJob.Finish

    Else
      gcd.clsJob = gcd.clsJobPrevious
      gcd.clsJob.Start()
    Endif

  Else ' Left Click

    gcd.clsJob.MouseUp(mouse.x, mouse.y)

  End If

  redraw

End

Public Function Xreal(ScreenX As Float) As Float

  Return Metros((screenx - glarea1.w / 2 - PanX))

End

Public Function Yreal(ScreenY As Float) As Float

  Return Metros((-ScreenY + glarea1.h / 2 - PanY))

End

Public Function Pixels(distancia As Float) As Float  ' converts meters to pixels
  ' transforma Metros en Pixeles sin tener en cuenta el Pan

  Return distancia * ScaleZoom

End

Public Function Metros(pixeles As Integer) As Float  ' converts pixels to meters

  Return pixeles / ScaleZoom

End

Public Sub GLArea1_MouseWheel()
  ' ex  Public Sub drwArea_MouseWheel()

  Dim px, py As Float
  ' chequeamos si vale la pena seguir dibujando la grid, o sea, menos de 3 pixels

  If Pixels(puntos.GridSpacing) < 5 Then puntos.Gridactive = False Else puntos.Gridactive = True

  px = Xreal(GLArea1.w / 2)
  py = Yreal(GLArea1.h / 2)

  ' TODO: , redondear para que la escala sea 1:100 1:75 1:50 etc
  ScaleZoom = ScaleZoom * (1 + 0.075 * Mouse.Delta)

  ' pero con ciertos limites
  ' If ScaleZoom < 0.001 Then ScaleZoom = 0.001
  ' If ScaleZoom > 50 Then ScaleZoom = 50

  ' reacomodo el panning, pero solo si estoy en los limites del drwarea, sino es solo un zoom
  ' pero tengo que reajustar la posicion de las cosas , porque tienden a alejarse
  ' Supongamos que partimos de un Zoom = 1 y una posicion centrada, y hacemos zoom=2
  ' la posicion de las cosas estara 2x mas alejado; yo quiero que lo que hay en el centro de la pantalla, siga ahi
  ' entonces Pc = drwarea/2 anes del zoom, debera estar en el mismo lugar

  If mouse.x < glarea1.w * 0.2 Then
    PanX -= (mouse.x - glarea1.w / 2) / 10 * Mouse.Delta
  Else If mouse.x > glarea1.w * 0.8 Then
    PanX -= (mouse.x - glarea1.w / 2) / 10 * Mouse.Delta
  Else
    ' PanX = glarea1.w / 2 - Pixels(px)
    PanX = -Pixels(px) ' post Paint
  Endif

  If mouse.y < glarea1.h * 0.2 Then
    PanY += (mouse.y - glarea1.w / 2) / 10 * Mouse.Delta
  Else If mouse.y > glarea1.h * 0.8 Then
    PanY += (mouse.y - glarea1.w / 2) / 10 * Mouse.Delta
  Else
    'PanY = (Pixels(py) + glarea1.h / 2)     ' el eje Y trabaja distinto, asi que debemos cambiar esto
    PanY = -Pixels(py)                      ' cambio post Paint
  Endif

  redraw

End

Public Sub form_KeyPress()

  Return

  Dim t As Float = Timer

  If (Key.Code = Key.Enter) Or (Key.Code = Key.Return) Then
    Debug KeysAccumulator
    gcd.clsJob.KeyText(KeysAccumulator)
    KeysAccumulator = ""
    redraw
    Return
  Endif
  If Key.Code = Key.f6 Then
    gcd.DrawBounds = Not gcd.DrawBounds
    ' Dim i As Integer
    '
    ' For i = 0 To 50000
    '     '
    '     gcd.AddLine(arrEntities, [Rnd(-20, 20), Rnd(-20, 20), Rnd(-20, 20), Rnd(-20, 20)], 0, 1, 0, "0")
    '     '     'arrEntities.Last.gbcolor = Color.RGB(Rnd(0, 255), Rnd(0, 255), Rnd(0, 255))
    ' Next
    ' Debug "Entidades creadas en  ", Timer - t
    '        gcd.AddEllipse([10, 10, 150, 150], 0.5, 0, Pi)

    'gcd.AddMText([0, 0], 20, 30, "Primera linea" & gb.Cr & "Segunda linea", 3, 1, 1, "0", "")

    'gcd.AddText([0, -400], 20, 30, "Unica linea", 3, 1, 1, "0", "")
    'gcd.ApplyLayerProperties
    'gcd.AddLine([0, -200, 400, 0], 2, 1, "Dashed", "0", "")
    ' gcd.Benchmarks
    '
    regen
    Return
  Endif

  If Key.Code = Key.BackSpace Then

    KeysAccumulator = Left(KeysAccumulator, -1)
    redraw
    Return
  Endif

  If Key.Code = Key.f8 Then

    Debug "Entidades transferidas en  ", Timer - t
    gcd.Orthogonal = Not gcd.Orthogonal
    redraw
  Endif
  If Key.Code = Key.f7 Then

    puntos.Gridactive = Not puntos.Gridactive
    redraw
  Endif

  If Key.Code = Key.Esc Then

    gcd.clsJob.Finish()  ' Now!
    ' we cancel everything
    gcd.clsJobPrevious = gcd.clsJob
    gcd.clsJob = clsDefaultJob

    redraw
    Return

  End If

  ' A GOOD KEY
  KeysAccumulator &= Key.Text

  If Key.Code = Key.Space Then
    Stop Event
  Endif
  'Label1.Text = KeysAccumulator
  glarea1.Refresh

End

Public Sub tmr500_Timer()

  ' If clsDrawingAids.PromtSlash = "|" Then clsDrawingAids.PromtSlash = "" Else clsDrawingAids.PromtSlash = "|"
  ' Inc clsDrawingAids.ErrorTimer
  ' redraw

End

Public Sub redraw()

  glarea1.Refresh

End

'' Regenera las listas de OpenGL
Public Sub Regen()

  clsEntities.GLGenDrawList
  clsEntities.glGenDrawListSel
  redraw

End

Public Sub TransferToCollections()

  gcd.ExportBlocks(cModel)
  gcd.ExportEntities(cModel["Entities"], arrEntities)

End

' =============================================================================================================================
' =============================================================================================================================
' =============================================================================================================================

'       Desde aca es para el funcionamiento de la GUI

' =============================================================================================================================
' =============================================================================================================================
' =============================================================================================================================

Public Sub _new(cin As Collection)

  iEntity.Insert([0, 0, -1, -1])
  ScaleZoom = gcd.ScreenDensity
  Run(cin)

End

Public Sub Run(cMdl As Collection) As Boolean

  cModel = cMdl.Copy()

  GLArea1.Background = Color.Blue

  'cModel.Add(arrEntities, "Entities") ' Esto lo comento porque si no pisa el Entities collection

  Me.Menus.Hide

  Me.Show()

End

Public Sub ToolButton1_Click()

  If cModel.Exist("Layers") Then
    Print "Layers"
  Endif

End

Public Sub EntitiesTransfer2()

  Dim iEnt As Collection
  Dim mEnt As Collection
  Dim grp As Collection
  Dim e As Variant
  Dim mGrp As Collection

  If cImport.Count > 0 Then
    If cImport.Exist("Entities") Then
      iEnt = cImport["Entities"]
      If cModel.Exist("Entities") Then
        mEnt = cModel["Entities"]

        For Each grp In iEnt
          If mEnt.Exist(iEnt.Key) = False Then
            mEnt.Add(grp.Copy(), iEnt.Key)
          Else
            mGrp = mEnt[iEnt.Key]
            For Each e In grp
              mGrp.Add(e, grp.Key)
            Next

          Endif

        Next

      Endif
    Endif
  Endif

End

Public Sub BlocksTransfer()

  Dim iEnt As Collection
  Dim mEnt As Collection
  Dim grp As Collection
  Dim e As Variant
  Dim mGrp As Collection

  If cImport.Count > 0 Then
    If cImport.Exist("Blocks") Then
      iEnt = cImport["Blocks"]
      If cModel.Exist("Blocks") Then
        mEnt = cModel["Blocks"]

        For Each grp In iEnt
          If mEnt.Exist(iEnt.Key) = False Then
            mEnt.Add(grp.Copy(), iEnt.Key)
          Else
            mGrp = mEnt[iEnt.Key]
            For Each e In grp
              mGrp.Add(e, grp.Key)
            Next

          Endif

        Next
      Else

        cModel.Add(iEnt.Copy(), "Blocks")

      Endif
    Endif
  Endif

End

'' This transfer layers from imported file, one collection actually, to the model collection
'
' Public Sub EntitiesTransfer()
'
'     Dim tEnt As New Collection
'     Dim iEt As Variant
'     Dim prop As String
'     Dim iEnt As Collection
'     Dim mEnt As Collection
'     Dim iBk As Collection
'     Dim iB As Variant
'     Dim iGt As Variant
'
'     If cImport.Count > 0 Then
'         If cImport.Exist("Entities") Then
'             iEnt = cImport["Entities"]
'             If cModel.Exist("Entities") Then
'                 mEnt = cModel["Entities"]
'
'                 For Each iGt In iEnt
'
'                     For Each iEt In iGt
'                         For Each prop In ["entity", "handle", "layer", "style", "width", "colour", "blkid", "visible", "paper", "elev", "thick", "p"]
'                             tEnt.Add(iEt[prop], prop)
'                         Next
'                         Select iEt["entity"]
'                             Case "LINE", "LWPOLYLINE"
'                                 tEnt.Add(iEt["p"], "p")
'
'                             Case "CIRCLE"
'                                 tEnt.Add(iEt["p"], "p")
'                                 tEnt.Add(iEt["r"], "r")
'
'                             Case "ARC"
'                                 tEnt.Add(iEt["p"], "p")
'                                 tEnt.Add(iEt["r"], "r")
'                                 tEnt.Add(iEt["a"], "a")
'
'                             Case "ELLIPSE"
'                                 tEnt.Add(iEt["p"], "p")
'                                 tEnt.Add(iEt["r"], "r")
'                                 tEnt.Add(iEt["a"], "a")
'
'                             Case "INSERT"
'                                 tEnt.Add(iEt["b"], "ba")
'                                 tEnt.Add(iEt["p"], "p")
'                                 tEnt.Add(iEt["s"], "s")
'                                 tEnt.Add(iEt["a"], "a")
'                                 tEnt.Add(iEt["co"], "co")
'                                 tEnt.Add(iEt["ro"], "ro")
'                                 tEnt.Add(iEt["cs"], "cs")
'                                 tEnt.Add(iEt["rs"], "rs")
'
'                             Case "TEXT"
'                                 tEnt.Add(iEt["p"], "p")
'                                 tEnt.Add(iEt["a"], "a")
'                                 tEnt.Add(iEt["h"], "h")
'                                 tEnt.Add(iEt["f"], "f")
'                                 tEnt.Add(iEt["text"], "text")
'
'                             Case "DIMMENSION"
'                                 tEnt.Add(iEt["p"], "p")
'
'                         End Select
'                         mEnt.Add(tEnt.copy(), iEt["handle"])
'                         tEnt.Clear
'
'                     Next
'                 Next
'             Endif
'         Endif
'     Endif
'
' End

'' This transfer layers from imported file, one collection actually, to the model collection

Public Sub LayersTransfer()

  Dim tLay As New Collection
  Dim i As Integer
  Dim il As Variant
  Dim ml As Variant
  Dim prop As String
  Dim iLay As Collection
  Dim mLay As Collection
  Dim r As Integer

  If cImport.Count > 0 Then
    If cImport.Exist("Layers") Then
      iLay = cImport["Layers"]
      If cModel.Exist("Layers") Then
        mLay = cModel["Layers"]

        For Each il In iLay
          r = 0
          For Each ml In mLay
            If ml["name"] = il["name"] Then
              r = -1
              Break
            Else
              Inc r
            Endif
          Next

          If r > -1 Then
            tLay.Add(Format(r, "0"), "id")
            tLay.Add("layer", "type")
            For Each prop In ["name", "show", "frozen", "locked", "colour", "style", "width", "print"]
              tLay.Add(il[prop], prop)
            Next
            mLay.Add(tLay.copy(), Format(r, "0"))
            tLay.Clear
          Endif

        Next
      Else
        For Each il In iLay
          tLay.Add(Format(i, "0"), "id")
          tLay.Add("layer", "type")

          For Each prop In ["name", "show", "frozen", "locked", "colour", "style", "width", "print"]
            tLay.Add(iLay[prop], prop)
          Next

          mLay.Add(tLay.copy(), Format(i, "0"))
          tLay.Clear
          Inc i
        Next
      Endif
    Endif
  Endif

End

Public Sub LoadVars()

  Dim ctn As New Collection
  Dim dra As Variant
  Dim sKey As String
  Dim sTag As String
  Dim sQty As String
  Dim sEle As String
  Dim sEty As String

  Dim it As Variant
  Dim gru As Variant
  Dim ety As Variant

  TreeView1.Clear
  TreeView1.Add("model", "Model")
  TreeView1.Add("import", "Import")

  ctn.Add(cModel, "model")
  ctn.Add(cImport, "import")

  For Each dra In ctn

    For Each it In dra

      sKey = ctn.Key & ":" & dra.Key

      If TreeView1.Exist(sKey) = False Then

        Select dra.Key

          Case "File", "Version"
            sTag = dra.Key & ": " & it
            TreeView1.Add(sKey, sTag,, ctn.Key)

          Case "Layers"
            sTag = ctn.Key & ":" & dra.Key
            sQty = "[" & CStr(it.Count) & "]"
            TreeView1.Add(sTag, dra.Key & sQty,, ctn.Key)
            For Each gru In it
              sKey = dra.Key & ":" & gru["name"]
              If TreeView1.Exist(sKey) = False Then
                TreeView1.Add(sKey, gru["name"],, sTag)
              Endif
            Next

          Case "Entities"
            sTag = ctn.Key & ":" & dra.Key
            TreeView1.Add(sTag, dra.Key,, ctn.Key)
            For Each gru In it
              sKey = ctn.Key & ":" & it.Key
              sQty = "[" & CStr(gru.Count) & "]"
              If TreeView1.Exist(sKey) = False Then
                TreeView1.Add(sKey, it.Key & sQty,, sTag)
              Endif
              For Each ety In gru
                If ety["handle"] <> "" Then
                  sEty = ctn.Key & ":" & ety["handle"]
                  Select it.Key
                    Case "text"
                      sEle = ety["text"]
                    Case Else
                      sEle = ety["handle"]
                  End Select
                  If TreeView1.Exist(sEty) = False Then
                    TreeView1.Add(sEty, sEle,, sKey)
                  Endif
                Endif
              Next
            Next

        End Select
      Endif
    Next
  Next

End

Public Sub LoadDrawingMap2()

  Dim ctn As New Collection
  Dim dra As Variant
  Dim sKey As String
  Dim sTag As String
  Dim sQty As String
  Dim sEle As String
  Dim sEty As String

  Dim it As Variant
  Dim gru As Variant
  Dim ety As Variant

  TreeView1.Clear
  TreeView1.Add("model", "Model")
  TreeView1.Add("import", "Import")

  ctn.Add(cModel, "model")
  ctn.Add(cImport, "import")

  For Each dra In ctn

    For Each it In dra

      sKey = ctn.Key & ":" & dra.Key

      If TreeView1.Exist(sKey) = False Then

        Select dra.Key

          Case "File", "Version"
            sTag = dra.Key & ": " & it
            TreeView1.Add(sKey, sTag,, ctn.Key)

          Case "Layers"
            sTag = ctn.Key & ":" & dra.Key
            sQty = "[" & CStr(it.Count) & "]"
            TreeView1.Add(sTag, dra.Key & sQty,, ctn.Key)
            For Each gru In it
              sKey = dra.Key & ":" & gru["name"]
              If TreeView1.Exist(sKey) = False Then
                TreeView1.Add(sKey, gru["name"],, sTag)
              Endif
            Next

          Case "Entities"
            sTag = ctn.Key & ":" & dra.Key
            TreeView1.Add(sTag, dra.Key,, ctn.Key)
            For Each gru In it
              sKey = ctn.Key & ":" & it.Key
              sQty = "[" & CStr(gru.Count) & "]"
              If TreeView1.Exist(sKey) = False Then
                TreeView1.Add(sKey, it.Key & sQty,, sTag)
              Endif
              For Each ety In gru
                If ety["handle"] <> "" Then
                  sEty = ctn.Key & ":" & ety["handle"]
                  Select it.Key
                    Case "text"
                      sEle = ety["text"]
                    Case Else
                      sEle = ety["handle"]
                  End Select
                  If TreeView1.Exist(sEty) = False Then
                    TreeView1.Add(sEty, sEle,, sKey)
                  Endif
                Endif
              Next
            Next

        End Select
      Endif
    Next
  Next

End

' Public Sub LoadDrawingMap()
'
'   Dim cLayers As New Collection
'   Dim Layer As Variant
'   Dim app As APPMain
'   Dim ito As Variant
'   Dim it As Variant
'   Dim sKey As String
'   Dim sName As String
'   Dim mt As Variant
'   Dim mEt As Variant
'
'   If cModel.Count > 0 Then
'     TreeView1.Clear
'     TreeView1.Add("drawing", "Drawing")
'
'     'File ----------------------
'     If cModel.Exist("File") Then
'       TreeView1.Add("file", ("File") & ": " & File.Name(cModel["File"]),, "drawing")
'     Endif
'     'Version ----------------------
'     If cModel.Exist("Version") Then
'       TreeView1.Add("version", ("Version") & ": " & cModel["Version"],, "drawing")
'     Endif
'
'     cLayers.Clear
'     'Layers ----------------------
'     If cModel.Exist("Layers") Then
'       cLayers = cModel["Layers"]
'       TreeView1.Add("layers", "Layers",, "drawing")
'       For Each Layer In cLayers
'         TreeView1.Add(Layer["name"], Layer["name"],, "layers")
'       Next
'     Endif
'     'Styles ------------------------
'     'Widths ------------------------
'     'Dims --------------------------
'     'Fonts -------------------------
'
'     'Entities ----------------------
'     For Each mt In cModel
'
'       If TreeView1.Exist(cModel.Key) = False Then
'         TreeView1.Add(cModel.Key, cModel.Key,, "drawing")
'       Endif
'
'       Select cModel.Key
'         Case "Entities"
'           mEt = cModel[cModel.Key]
'           For Each mt In mEt
'             sName = String.LCase(mt["entity"])
'             If TreeView1.Exist("m" & sName) = False Then
'               TreeView1.Add("m" & sName, sName,, cModel.Key)
'             Endif
'           Next
'
'       End Select
'
'     Next
'
'     TreeView1["layers"].Expanded = True
'   Endif
'
'   If cImport.Count > 0 Then
'     TreeView1.Add("import", "Import")
'     For Each ito In cImport
'       sKey = cImport.Key
'       Select TypeOf(ito)
'         Case gb.Object
'           TreeView1.Add("i" & sKey, sKey,, "import")
'           For Each it In ito
'             Select sKey
'               Case "Entities"
'                 sName = String.LCase(ito[ito.Key]["entity"])
'                 If TreeView1.Exist("i" & sName) = False Then
'                   TreeView1.Add("i" & sName, sName,, "i" & sKey)
'                 Endif
'               Case "Block"
'                 sName = ito[ito.Key]["block"]
'                 If TreeView1.Exist("i" & sName) = False Then
'                   TreeView1.Add("i" & sName, sName,, "i" & sKey)
'                 Endif
'               Case Else
'                 If TreeView1.Exist("i" & ito.Key) = False Then
'                   TreeView1.Add("i" & ito.Key, sName,, "i" & sKey)
'                 Endif
'
'             End Select
'
'           Next
'         Case gb.String
'           TreeView1.Add("i" & sKey, sKey,, "import")
'       End Select
'     Next
'   Endif
'   APP = Me.Parent.Parent.Parent.Parent.Parent.Parent
'   APPMain.LoadComboboxes(cModel)
'
' End
