' Gambas class file

' Tool maintained by Terco
Create Static

' Lineas de puntos para Paint
Public Dashes As Float[] = [5.0,  'ink
    5.0,  'skip
    5.0,  'ink
    5.0]  'skip

Public DashDot As Float[] = [40.0,  'ink
    10.0,  'skip
    10.0,  'ink
    10.0]  'skip

' ayudas al usuario en pantalla
Public Struct HelperSt
    texto As String
    dX As Integer '= 5 'defasaje con respecto al mouse
    dY As Integer '= 5
    fColor As Integer '= Color.black
    ShowRect As Boolean '= True
    fRectangulo As Integer ' = Color.ButtonBackground
    fFont As String '= "Arial" (ignorado)
    fHeight As Integer '= 20
End Struct

Public ScreenDensity As Float = 1080 / 29.5  ' pixele by cm wich gives a 1:100 scale in my monitor

Public Helper As New HelperSt       ' Esto se escribe al lado del mouse
Public HelperTrabajo As String      '   parte inferior izquierda
Public HelperTrabajoNext As String      '   parte inferior izquierda
Public HelperTrabajo2 As String     '   sin usar
Public HelperTrabajo3 As String     '   sin usar
Public HelperTrabajo4 As String     '   sin usar
Public ErrorMessage As String
Public ErrorTimer As Integer = 0
Public HelperDibujo As String       ' Se escribe abajo "Grid  Ortho" , etc

Public PromtSlash As String = "|"

Public Function CleanTexts()

    Helper.texto = ""
    HelperTrabajo = ""
    HelperTrabajoNext = ""
    HelperTrabajo2 = ""
    HelperTrabajo3 = ""
    HelperTrabajo4 = ""
    HelperDibujo = ""

End

Public Sub _new()

    helper.texto = ""
    helper.dX = 15 'defasaje con respecto al mouse
    helper.dY = 15
    helper.fColor = Color.black
    helper.ShowRect = True
    helper.fRectangulo = Color.ButtonBackground
    helper.fFont = "Arial"
    helper.fHeight = 10

End

'' All text options in one line
'' 0,0 is center
Public Sub Texting(MyText As String, Optional posX As Integer, posY As Integer, txtColor As Integer = 0, txtHeight As Integer = 12, FontName As String)

    gl.PushMatrix

    gl.LoadIdentity

    glPlus.DrawText(MyText, posX, posY, 0, 10, txtColor)

    gl.PopMatrix

End

Public Sub DibujaHelper()

    Dim hExt As PaintExtents, trabajoYteclado As String, sNext As String

    If ErrorMessage <> "" Then

        texting(ErrorMessage, 10 - appmain.hFcad.glarea1.w / 2, 30 - appmain.hFcad.glarea1.h / 2, Color.Red)

        If ErrorTimer = 15 Then ErrorMessage = ""
    Else
        ErrorTimer = 0

    End If

    If HelperTrabajoNext <> "" Then snext = HelperTrabajoNext & " : "

    trabajoYteclado = HelperTrabajo & " > " & sNext & appmain.hFCAD.KeysAccumulator & PromtSlash

    Texting(trabajoYteclado, 10 - appmain.hFcad.glarea1.w / 2, 10 - appmain.hFcad.glarea1.h / 2, color.blue)

    HelperDibujo = ""
    If modCAD.Ortogonal Then HelperDibujo = "F8-Ortho"
    If puntos.Gridactive Then HelperDibujo = HelperDibujo & "  F7-Grid = " & Format$(puntos.GridSpacing, "0.00 m")
    ' and so on...

    texting(HelperDibujo, 40, 10 - appmain.hFcad.glarea1.h / 2, color.blue)

    ' helper del mouse
    If Len(Helper.Texto) = 0 Then Return

    ' paint.MoveTo(puntos.cursorX + helper.dX, puntos.cursorY + Helper.dY)

    Texting(Helper.Texto, appmain.hFcad.CursorX - appmain.hFcad.glarea1.w / 2, -appmain.hFcad.CursorY + appmain.hFcad.glarea1.h / 2, Color.DarkGreen, 10)

    ' paint.Stroke

End Sub

Public Sub DrawCoordenadas()

    ' helpers
    Dim l As String, l2 As String, lEsc As String

    l = Format$(puntos.Near(appmain.hFcad.Xreal(appmain.hFcad.cursorX)), "0.00") & "mts : " & Format$(puntos.Near(appmain.hFcad.Yreal(appmain.hFcad.cursorY)), "0.00") & "mts"

    '    l2 = "Mouse: " & Str$(puntos.cursorX) & ": " & Str$(puntos.cursorY)

    l2 = "ScaleZoom " & Str$(appmain.hFcad.ScaleZoom) & " - Pan: " & Str$(appmain.hFCAD.PanX) & ", " & Str$(appmain.hFCAD.PanY)

    'FCAD.nDraws = 0

    ' intento determinar la escala
    ' en mi monitor, 29cm  = 1080 pixeles

    Dim e As Float, z As Float
    e = 1080 / 0.29 ' pixeles por metro segun el tamaño real de la pantalla
    z = appmain.hFcad.Metros(1) ' metros por pixel segun la ampliacion del usuario (rueda del mouse)
    lEsc = "Esc 1:" & Format$(1 / appmain.hFcad.ScaleZoom * 100 * ScreenDensity, "0")

    Texting(l, 10 - appmain.hFcad.glarea1.w / 2, appmain.hFcad.glarea1.h / 2 - 15, color.blue)
    Texting(l2, 10 - appmain.hFcad.glarea1.w / 2, appmain.hFcad.glarea1.h / 2 - 35, color.blue)
    Texting(lEsc, appmain.hFcad.glarea1.w / 2 - 100, 10 - appmain.hFcad.glarea1.h / 2, color.blue)

End

Public Sub DrawEjes()

    ' helper de los ejes coordenados
    ' TODO:  no se porque el fondo de las dashes me sale gris y no blanco
    paint.brush = Paint.Color(Color.RGB(0, 0, 0, 0))
    paint.LineWidth = 1 / appmain.hFcad.ScaleZoom
    paint.Dash = DashDot
    paint.MoveTo(0 - (DashDot[0] + DashDot[1] + DashDot[2] / 2), 0) ' me voy al origen de coordenadas
    paint.relLineTo(1000, 0)
    paint.MoveTo(0, 0 - (DashDot[0] + DashDot[1] + DashDot[2] / 2)) ' me voy al origen de coordenadas
    paint.relLineTo(0, 1000)
    paint.Dash = []
    paint.Stroke

End

Public Sub DrawCaudricula()

    ' crossing lines each gridspace and darker each 10m

    Dim i, xgg, ygg, xg, yg As Single, espaciado As Single, starting As Single

    espaciado = appmain.hFcad.pixels(puntos.GridSpacing) ' tamaño de la grid en pixeles

    xg = appmain.hFcad.Xreal(0) ' Puntos reales aproximados al 0,0 de la pantalla
    yg = appmain.hFcad.Yreal(0)

    xg = puntos.Near(xg) ' punto en mundo real ajustado a grid
    yg = puntos.Near(yg)

    xg = puntos.Xpix(xg) - espaciado * 2 ' punto inicial en la drawing area
    yg = puntos.Ypix(yg) - espaciado * 2

    xgg = xg
    ygg = yg

    starting = yg ' guardo el Y inicial

    paint.brush = Paint.Color(Color.Gray)
    paint.LineWidth = 1

    ' lineas finas
    Do ' lineas horizontales
        If espaciado < 5 Then Break
        paint.MoveTo(xg, yg)
        paint.RelLineTo(FCAD.drwArea.W + espaciado, 0)
        yg += espaciado - 0.5

    Loop Until yg > (FCAD.drwArea.Height + espaciado * 2)

    xg = xgg
    yg = ygg
    Do ' verticales
        If espaciado < 5 Then Break
        paint.MoveTo(xg, yg)
        paint.RelLineTo(0, appmain.hFCAD.DdrwArea.Height + espaciado)
        xg += espaciado - 0.5

    Loop Until xg > (FCAD.drwArea.Width + espaciado * 2)

    ' lineas gruesas

    paint.Stroke

End

Public Sub DrawBoundingPoligons() ' and other debugging stuff

    Dim e As Object, i As Integer, p0, p1 As Float

    ' HelperTrabajo2 = "modCAD.clsJob: " & Str(modCAD.clsJob) & "->" & Str(clsEntityBuilder.elem)
    '
    ' Texting(HelperTrabajo2, 300, appmain.hFcad.glarea1.h - 20, Color.Blue)
    '
    ' HelperTrabajo2 = "modCAD.clsJobPrevious: " & Str(modCAD.clsJobPrevious)
    '
    ' Texting(HelperTrabajo2, 300, appmain.hFcad.glarea1.h - 40, Color.Blue)

    If modCAD.clsJob.gender = "Builder" Then Return

    paint.brush = Paint.Color(Color.Blue)
    For Each e In APPMain.hFCAD.arrEntities

        If e.boundingpoligon.count > 0 Then
            paint.MoveTo(e.boundingpoligon[e.boundingpoligon.Max - 1], e.boundingpoligon[e.boundingpoligon.Max])

            For i = 0 To e.boundingpoligon.Max Step 2
                paint.lineTo(e.boundingpoligon[i], e.boundingpoligon[i + 1])
            Next

        End If

    Next
    paint.Stroke

    paint.LineWidth = 1
    paint.brush = Paint.Color(&HBFFF00)

    For i = 0 To clsEntities.POI.Max Step 2

        paint.Rectangle(clsEntities.POI[i] - 4 / appmain.hFcad.ScaleZoom, clsEntities.POI[i + 1] - 4 / appmain.hFcad.ScaleZoom, 8 / appmain.hFcad.ScaleZoom, 8 / appmain.hFcad.ScaleZoom)

    Next
    paint.Fill

End
