' Gambas module file

'
' RADG
' Rapid Application Development for Gambas
'
' Copyright (C) MartÃ­n Belmonte
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

' This modeule contains methods for working with cad files.

Export

'' This load all the info form a gaucho xml file, then put it in a collection a
'' nd return it.

Public Function LoadGaucho(sFile As String) As Collection

    Dim c As New Collection
    Dim cLayers As New Collection
    Dim cStyles As New Collection
    Dim cWidths As New Collection
    Dim cDimSts As New Collection
    Dim cFonts As New Collection
    Dim cEntities As New Collection
    Dim cMdl As New Collection
    Dim hxml As New XmlDocument
    Dim ent As XmlElement
    Dim i As Integer
    Dim sKey As String

    hxml.Open(sFile)

    cMdl.Add(sFile, "File")

    For Each ent In hxml.GetElementsByTagName("header")
        Select ent.Attributes["type"]
            Case "version"
                cMdl.Add(ent.Attributes["name"], "Version")

            Case "layer"
                c.Clear
                c["id"] = Format(CInt(ent.Attributes["id"]), "00")
                c["type"] = ent.Attributes["type"]
                c["name"] = ent.Attributes["name"]
                c["show"] = CBool(ent.Attributes["show"])
                c["frozen"] = CBool(ent.Attributes["frozen"])
                c["locked"] = CBool(ent.Attributes["locked"])
                c["colour"] = CInt(ent.Attributes["colour"])
                c["style"] = CInt(ent.Attributes["style"])
                c["width"] = CInt(ent.Attributes["width"])
                c["print"] = CBool(ent.Attributes["print"])
                cLayers.Add(c.Copy(), Format(CInt(ent.Attributes["id"]), "00"))

            Case "style"
                c.Clear
                c["id"] = ent.Attributes["id"]
                c["type"] = ent.Attributes["type"]
                c["name"] = ent.Attributes["name"]
                cStyles.Add(c.Copy(), ent.Attributes["id"])

            Case "width"
                c.Clear
                c["id"] = ent.Attributes["id"]
                c["type"] = ent.Attributes["type"]
                c["value"] = ent.Attributes["value"]
                cWidths.Add(c.Copy(), ent.Attributes["id"])

            Case "dimst"
                c.Clear
                c["id"] = ent.Attributes["id"]
                c["type"] = ent.Attributes["type"]
                c["name"] = ent.Attributes["name"]
                cDimSts.Add(c.Copy(), ent.Attributes["id"])

            Case "font"
                c.Clear
                c["id"] = ent.Attributes["id"]
                c["type"] = ent.Attributes["type"]
                c["name"] = ent.Attributes["name"]
                cFonts.Add(c.Copy(), ent.Attributes["id"])

        End Select
    Next

    cMdl.Add(cLayers, "Layers")
    cMdl.Add(cStyles, "Styles")
    cMdl.Add(cWidths, "Widths")
    cMdl.Add(cDimSts, "DimSts")
    cMdl.Add(cFonts, "Fonts")

    ''TODO: poner las entidade en el cModel
    For Each ent In hxml.GetElementsByTagName("entity")
        c.Clear
        'Commons fields

        'c["id"] = ent.Attributes["id"]
        sKey = CStr(i) 'sog.UUIDHandle(6)
        c["id"] = sKey
        c["type"] = ent.Attributes["type"]
        '-----
        c["layer"] = ent.Attributes["layer"]
        c["style"] = ent.Attributes["style"]
        c["width"] = ent.Attributes["width"]
        c["colour"] = ent.Attributes["colour"]
        '-----

        Select ent.Attributes["type"]

            Case "line", "polyline"
                c["p"] = EncodePoint(ent.Attributes["p"], "p")

            Case "circle"
                c["p"] = EncodePoint(ent.Attributes["p"], "p")
                c["r"] = EncodePoint(ent.Attributes["r"], "r")

            Case "ellipse"
                c["p"] = EncodePoint(ent.Attributes["p"], "p")
                c["r"] = EncodePoint(ent.Attributes["r"], "r")
                c["a"] = EncodePoint(ent.Attributes["a"], "a")
                Print "x"

            Case "arc"
                c["p"] = EncodePoint(ent.Attributes["p"], "p")
                c["r"] = EncodePoint(ent.Attributes["r"], "r")
                c["a"] = EncodePoint(ent.Attributes["a"], "a")
                Print c["a"]

            Case "text"
                c["p"] = EncodePoint(ent.Attributes["p"], "p")
                c["a"] = EncodePoint(ent.Attributes["a"], "a")
                c["text"] = ent.Attributes["t"]
                c["h"] = ent.Attributes["h"]
                c["f"] = ent.Attributes["f"]

            Case "insert"
                c["p"] = EncodePoint(ent.Attributes["p"], "p")
                c["a"] = EncodePoint(ent.Attributes["a"], "a")
                c["s"] = CFloat(ent.Attributes["s"])
                c["b"] = ent.Attributes["b"]

                Print c["a"]

        End Select
        If c.Count > 0 Then
            'If c.Exist("id") Then
            cEntities.Add(c.Copy(), sKey)
            'Endif
        Endif
        Inc i
    Next

    cMdl.Add(cEntities, "Entities")

    Return cMdl

End

'' This function encode a float list like a point angles etc. from a string in
'' delimiter char for dimansions is : the for delimitatiosn of groups we use ;

Private Function EncodePoint(sPoint As String, sTag As String) As Collection

    Dim cp As New Collection
    Dim fp As New Float[]
    Dim stx As New String[]
    Dim sp As String
    Dim i As Integer

    If InStr(sPoint, ";") > 0 Then
        ' Single point ie.lines
        stx = Split(sPoint, ";")
    Else
        'Multipoint, ie.Polylines
        stx.Add(sPoint)
    Endif

    For Each sp In stx
        If InStr(sPoint, ":") > 0 Then
            fp = Split(sp, ":")
        Else
            fp.Add(sp)
        Endif
        cp.Add(fp.Copy(), sTag & CStr(i))
        fp.Clear
        Inc i
    Next

    Return cp

End

Public Function ExportSVG(model As Collection) As String

    Dim ent As Variant
    Dim xsvg As New XmlDocument
    'Dim sFileIn As String
    Dim sFileSVG As String
    Dim sFile As String
    Dim sVersion As String

    sFile = model["File"]
    sVersion = model["Version"]

    sFileSVG = File.Dir(sFile) &/ File.Name(sFile) & ".svg"

    xsvg.Open(sFileSVG)

    For Each ent In model
        Select ent["Name"]
            Case "LINE"

        End Select

    Next

End

Public Function ImportDxf(sFile As String) As Collection

    'Dim model As New Collection       ''Complete model
    Dim sec As New Collection 'String[]

    sec = GetDXFSections(sFile)

    ' If sections.Count > 0 Then
    '     Print sections.Count
    ' Endif

    Return sec

End

Public Function ImportDwg(sFile As String) As Collection

    Dim sCont As String
    Dim cont As Collection
    Dim enty As Collection
    Dim comm As Collection
    Dim spec As Collection
    Dim FileVersion As String       ''2004, 14, 2007 ...
    Dim vent As Collection
    Dim v As Variant
    Dim ctn As Variant
    Dim x As Variant
    Dim Ety As Variant
    Dim Idx As Variant
    Dim set As New Collection         ''Combination of the previous two
    Dim entities As New Collection       ''All the entities
    Dim model As New Collection       ''Complete model
    Dim layers As Collection
    Dim AcHeader As Collection

    layers = GetLayersList(sFile)

    vent = cad.GetEntityList()

    sCont = dwgread(sFile)

    If sCont <> "" Then
        FileVersion = Split(sCont, "\n")[1]
        FileVersion = Replace(FileVersion, " ", "")
        FileVersion = Replace(FileVersion, "(", ":")
        FileVersion = Split(FileVersion, ":")[1]

        cont = Sections(sCont, FileVersion)

        model.Add(sFile, "File")
        model.Add(FileVersion, "Version")
        model.Add(layers, "Layers")

        If cont.Exist("Header") Then
            AcHeader = Header(cont["Header"])
            If AcHeader.Count > 0 Then
                model.Add(AcHeader, "Header")
            Endif
        Endif

        If cont.Exist("Handles") Then

            enty = Objects(cont["Handles"])

            For Each v In vent
                If v = True Then ' for debug change to False
                    If enty.Exist(vent.Key) Then
                        ctn = enty[vent.Key]
                        If ctn.Count > 0 Then
                            For Each x In ctn
                                comm = DecodeCommon(x)
                                spec = DecodeEntity(x)
                                Ety = comm["Name"]
                                Idx = comm["Id"]
                                set.Clear
                                'combinax
                                If comm["Id"] = spec["Id"] Then
                                    For Each v In comm
                                        set.Add(v, comm.Key)
                                    Next
                                    For Each v In spec
                                        If set.Exist(spec.Key) = False Then
                                            set.Add(v, spec.Key)
                                        Endif
                                    Next
                                Endif
                                entities.Add(set.Copy(), set["Id"])
                            Next
                        Endif
                    Endif
                Endif
            Next
        Endif
    Endif

    model.Add(entities, "Entities")

    Return model

End

Public Function GetLayersList(sFile As String) As Collection

    Dim layers As New Collection
    Dim sOut As String
    Dim stx As String[]
    Dim slay As String
    Dim lay As New Collection

    If Exist(sFile) Then
        Shell "/usr/local/bin/dwglayers -f '" & sFile & "' 2>&1 " To sOut
    Endif

    If sOut <> "" Then
        stx = Split(sOut, "\n")
        For Each slay In stx
            If InStr(slay, "\t") > 0 Then

                If String.Mid(slay, 1, 1) = "f" Then
                    lay.Add(True, "Frozen")
                Else
                    lay.Add(False, "Frozen")
                Endif
                If String.Mid(slay, 2, 1) = "+" Then
                    lay.Add(True, "On")
                Else
                    lay.Add(False, "On")
                Endif
                If String.Mid(slay, 3, 1) = "l" Then
                    lay.Add(True, "Locked")
                Else
                    lay.Add(False, "Locked")
                Endif

                lay.Add(Split(slay, "\t")[1], "Name")

            Endif
            layers.Add(lay.Copy(), lay["Name"])
        Next
    Endif

    Return layers

End

Public Function GetEntityList() As Collection

    Dim entity As New Collection

    entity.Add(False, "3DFACE")
    entity.Add(False, "3DSOLID")
    entity.Add(False, "ACAD_PROXY_ENTITY")
    entity.Add(True, "ARC") 'ok
    entity.Add(True, "ATTDEF") 'ok
    entity.Add(True, "ATTRIB") 'ok
    entity.Add(False, "BODY")
    entity.Add(True, "CIRCLE") 'ok
    entity.Add(False, "DIMENSION")
    entity.Add(True, "ELLIPSE") 'ok
    entity.Add(True, "HATCH")
    entity.Add(False, "HELIX")
    entity.Add(False, "IMAGE")
    entity.Add(True, "INSERT") 'ok
    entity.Add(False, "LEADER")
    entity.Add(False, "LIGHT")
    entity.Add(True, "LINE") 'ok
    entity.Add(True, "LWPOLYLINE") 'ok
    entity.Add(False, "MLINE") 'very complex, to do later
    entity.Add(False, "MULTILEADER")
    entity.Add(False, "MLEADERSTYLE")
    entity.Add(True, "MTEXT") 'ok
    entity.Add(False, "OLEFRAME")
    entity.Add(False, "OLE2FRAME")
    entity.Add(True, "POINT") 'ok
    entity.Add(False, "POLYLINE") 'not yey
    entity.Add(False, "RAY")
    entity.Add(False, "REGION")
    entity.Add(False, "SECTION")
    entity.Add(False, "SEQEND")
    entity.Add(False, "SHAPE")
    entity.Add(False, "SOLID")
    entity.Add(False, "SPLINE")
    entity.Add(False, "SUN")
    entity.Add(False, "SURFACE")
    entity.Add(False, "TABLE")
    entity.Add(True, "TEXT") 'ok
    entity.Add(False, "TOLERANCE")
    entity.Add(False, "TRACE")
    entity.Add(False, "UNDERLAY")
    entity.Add(False, "VERTEX")
    entity.Add(False, "VIEWPORT")
    entity.Add(False, "WIPEOUT")
    entity.Add(False, "XLINE")

    Return entity

End

'dwg2dxf
'dwg2svg
'dwgdump
'dwgfilter
'dwggrep
'dwglayers
'dwgread *
'dwgwrite
'dxf2dwg
'dxfwrite
Public Function dwgread(f As String, Optional fmt As String) As String

    Dim sOut As String

    If Exist(f) Then
        Select fmt
            Case ""
                Shell "/usr/local/bin/dwgread -v4 '" & f & "' 2>&1 " To sOut
            Case "json"
                Shell "/usr/local/bin/dwgread -v4 --format JSON '" & f & "' 2>&1 " To sOut
        End Select

    Endif

    Return sOut

End

Public Function Sections(s As String, vsn As String) As Collection

    Dim sWrd As String
    Dim cont As New Collection
    Dim sec As New String[]
    Dim sn As String
    Dim sName As String
    Dim sHead As String
    Dim contx As String[]
    Dim tmx As New String[]
    Dim tm As String

    Select vsn

        Case "AC1015" '"DWG2000"
            sWrd = "=======> "
            s = Replace(s, "\t", " ")
            s = Replace(s, sWrd, "\t")
            sec = Split(s, "\t")

            tmx = ["AuxHeader", "Thumbnail", "Header Variables", "CLASS", "Handles", "Last Object", "Second Header", "MEASUREMENT"]

            For Each sn In sec
                If InStr(sn, "\n") > 0 Then
                    contx = Split(sn, "\n")
                    sHead = contx[0]
                    sName = ""
                    For Each tm In tmx
                        If InStr(sHead, tm) > 0 Then
                            sName = tm
                            Break
                        Endif
                    Next
                    If sName <> "" Then
                        sName = Replace(sName, "AcDb:", "")
                        If sName = "Header Variables" Then
                            sName = "Header"
                        Endif
                        cont.Add(sn, sName)
                    Endif
                Endif
            Next

        Case "AC1018", "AC1024", "AC1027"
            sWrd = "Found section_info["
            s = Replace(s, "\t", " ")
            s = Replace(s, sWrd, "\t")
            sec = Split(s, "\t")

            For Each sn In sec
                If InStr(sn, "\n") > 0 Then
                    contx = Split(sn, "\n")
                    sHead = contx[0]
                    If InStr(sHead, "] AcDb:") > 0 Then
                        sName = Split(sHead, " ")[1]
                        sName = Replace(sName, "AcDb:", "")
                        cont.Add(sWrd & sn, sName)
                    Endif
                Endif
            Next

        Case "AC1021"

            s = Replace(s, "\t", " ")

            tmx = ["AppInfoHistory", "AppInfo", "Preview", "SummaryInfo", "RevHistory", "AcDbObjects", "ObjFreeSpace", "Template", "Handles", "Classes", "AuxHeader", "Header"]

            For Each tm In tmx
                Select tm
                    Case "AppInfoHistory", "AppInfo", "Preview", "SummaryInfo", "RevHistory", "ObjFreeSpace", "Template"
                        s = Replace(s, tm & " (", "\t" & tm & " (")

                    Case "AcDbObjects", "Handles", "Classes", "AuxHeader", "Header"
                        s = Replace(s, tm & "\n-------------------", "\t" & tm & "\n-------------------")

                End Select
            Next

            sec = Split(s, "\t")

            For Each sn In sec
                If InStr(sn, "\n") > 0 Then
                    contx = Split(sn, "\n")
                    sHead = contx[0]
                    sName = ""
                    For Each tm In tmx
                        If InStr(sHead, tm) > 0 Then
                            sName = tm
                            Break
                        Endif
                    Next
                    If sName <> "" Then
                        cont.Add(sn, "AcDb:" & sName)
                    Endif
                Endif
            Next

    End Select

    Return cont

End

Public Function Objects(s As String) As Collection
    'list,number

    Dim stx As String[]
    Dim i As Integer
    Dim obt As String
    'Dim sVer As String
    Dim obx As String[]
    Dim tmx As New Collection
    Dim j As Integer
    Dim hdx As String[]
    'Dim dtx As String[]
    Dim k As Integer
    Dim sTag As String
    Dim sVal As String
    Dim st As String
    Dim out As New Collection
    Dim p As Integer
    Dim sType As String

    s = Replace(s, "==========================================\n", "\t")
    stx = Split(s, "\t")

    If stx.count > 0 Then
        For i = 1 To stx.Max
            tmx.Clear
            obt = stx[i]
            obx = Split(obt, "\n")
            hdx = Split(Replace(Replace(obx[0], ", ", "\t"), ": ", ":"), "\t")
            For k = 0 To hdx.Max
                sTag = Split(hdx[k], ":")[0]
                sTag = Replace(sTag, " ", "")
                sVal = Split(hdx[k], ":")[1]
                If sTag = "Object number" Then
                    tmx.Add(CStr(Split(sVal, "/")[0]), "object_int")
                    tmx.Add(CStr(Split(sVal, "/")[1]), "object_hex")
                Else
                    tmx.Add(sVal, sTag)
                Endif
            Next

            '"Add object BLOCK_CONTROL [0] Decode object BLOCK_CONTROL"
            Select String.Mid(obx[1], 1, 4)
                Case "Warn"
                    sType = Split(obx[2], " ")[Split(obx[2], " ").Max - 1]
                    p = 1
                Case "Add "
                    sType = Split(obx[1], " ")[Split(obx[1], " ").Max - 1]
                    p = 0
                Case Else
                    sType = "Error"
            End Select

            If sType <> "Error" Then
                tmx.Add(sType, "XType")
                sVal = Split(obx[1 + p], " ")[Split(obx[1 + p], " ").Max]
                tmx.Add(sVal, "XName")
            Endif

            For j = (2 + p) To obx.Max - 3
                If InStr(obx[j], ": ") Then
                    st = Replace(obx[j], ": ", "\t")
                    sTag = Split(st, "\t")[0]
                    sTag = Replace(sTag, " ", "")
                    sVal = Split(st, "\t")[1]
                    tmx.Add(sVal, sTag)
                Endif
            Next

            If tmx.Exist("XName") Then
                If out.Exist(tmx["XName"]) Then
                    out[tmx["XName"]].Add(tmx.Copy())
                Else
                    out.Add([tmx.Copy()], tmx["XName"])
                Endif
            Else
                Print "entity error" & tmx["Object_int"]
            Endif
        Next
    Endif

    Return out

End

Public Function Header(s As String) As Collection

    Dim stx As String[]
    Dim i As Integer
    Dim obt As String
    Dim obx As New String[]
    Dim sTag As String
    Dim sVal As String
    Dim out As New Collection

    stx = Split(s, "\n")

    If stx.count > 0 Then
        For i = 1 To stx.Max
            obt = stx[i]
            obx.Clear
            If InStr(obt, ": ") > 0 Then
                obt = Replace(obt, ": ", "\t")
                obt = Replace(obt, " [", "\t")
                obt = Replace(obt, "]", "")
                obx = Split(obt, "\t")
                sTag = obx[0]
                sVal = obx[1]
                out.Add(sVal, sTag)
            Endif
        Next
    Endif

    Return out

End

'' Decode the common fields for any entity

Public Function DecodeCommon(c As Collection) As Collection

    Dim v As Variant
    Dim prp As New Collection
    Dim sVal As Variant
    Dim i As Integer
    'Dim clr As New String[]
    Dim f As Float

    If c.Exist("XName") Then

        If c.Exist("Objectnumber") Then
            If InStr(c["Objectnumber"], "/") > 1 Then
                i = CInt(Split(c["Objectnumber"], "/")[0])
            Endif
            prp.Add(i, "Id")
        Endif

        prp.Add(c["XName"], "Name")

        If c["XName"] = "LWPOLYLINE" Then
            Print "LWPOLYLINE"
        Endif

        For Each v In c
            i = -1
            f = 0.0
            Select c.Key

                Case "layer"
                    sVal = DecodeLayer(CStr(v))
                    prp.Add(sVal, "Layer")

                Case "ltype_flags"
                    i = DecodeInteger(CStr(v))
                    prp.Add(i, "Style")

                Case "linewt"
                    i = DecodeHex(sVal)
                    prp.Add(i, "Weight")

                Case "ltype_scale"
                    f = DecodeFloat(CStr(v))
                    prp.Add(f, c.Key)

                Case "plotstyle_flags"
                    i = DecodeInteger(CStr(v))
                    prp.Add(i, c.Key)

                Case "invisible"
                    i = DecodeInteger(CStr(v))
                    prp.Add(i, c.Key)

            End Select

            ' Colour
            sVal = ""
            If c.Exist("color.raw") Then
                sVal = String.Mid(c["color.raw"], 1, InStr(c["color.raw"], "[") - 1)
                i = DecodeHex(sVal)
            Else
                If c.Exist("color.index") Then
                    sVal = String.Mid(c["color.index"], 1, InStr(c["color.index"], "[") - 1)
                    sval = Replace(sval, " ", "")
                    i = CInt(sval)
                Endif
            Endif

            If i >= 0 And i <= 256 Then
                prp.Add(i, "Colour")
            Else
                prp.Add(0, "Colour")
            Endif

        Next
    Endif

    Return prp

End

'' Decode the fields for a specific entity

Public Function DecodeEntity(c As Collection) As Collection

    Dim v As Variant
    Dim prp As New Collection
    Dim sVal As Variant
    Dim pt As New Float[]
    Dim pt1 As New Float[]
    Dim pt2 As New Float[]
    Dim i As Integer
    Dim f As Float
    ' Dim fp1 As Float
    ' Dim fp2 As Float
    ' Dim fp3 As Float
    Dim p As Integer
    Dim sDec As String
    Dim sTag As String
    Dim sTag1 As String
    Dim sTag2 As String
    Dim hx As Integer
    Dim sTag3 As String
    Dim n As Integer
    Dim d As Integer
    Dim sTag5 As String
    Dim sTag4 As String

    If c.Exist("XName") Then

        If c.Exist("Objectnumber") Then
            If InStr(c["Objectnumber"], "/") > 1 Then
                i = CInt(Split(c["Objectnumber"], "/")[0])
            Endif
            prp.Add(i, "Id")
        Endif

        prp.Add(c["XName"], "Name")

        Select c["XName"]

            Case "TEXT"

                For Each v In c
                    Select c.Key
                        Case "insertion_pt"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "alignment_pt"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P2")

                        Case "rotation"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Angle")

                        Case "height"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Height")

                        Case "horiz_alignment"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, "Horiz")

                        Case "style"
                            sVal = DecodeTextStyle(CStr(v))
                            prp.Add(sVal, "Font")

                        Case "text_value" ' I deide call just "text" to the tag
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, "Text")

                    End Select
                Next

            Case "MTEXT"

                For Each v In c
                    Select c.Key
                        Case "insertion_pt"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "extrusion"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, c.Key)

                        Case "x_axis_dir"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, c.Key)

                        Case "rect_width"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "text_height"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Height")

                        Case "attachment"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "drawing_dir"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "extents_height"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "extents_width"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "text"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, "Text")

                        Case "linespace_style"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "linespace_factor"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "unknown_bit"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "bg_fill_flag"

                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "style"
                            sVal = DecodeTextStyle(CStr(v))
                            prp.Add(sVal, "Font")

                    End Select
                Next

            Case "ATTDEF"

                For Each v In c
                    Select c.Key
                        Case "insertion_pt"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "height"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Height")

                        Case "default_value"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, "Default")

                        Case "tag"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, "Tag")

                        Case "field_length"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, "Length")

                        Case "prompt"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, "Prompt")

                        Case "style"
                            sVal = DecodeTextStyle(CStr(v))
                            prp.Add(sVal, "Font")

                    End Select
                Next

            Case "ATTRIB"

                For Each v In c
                    Select c.Key
                        Case "insertion_pt"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "height"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Height")

                        Case "text_value"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, "Text")

                        Case "tag"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, "Tag")

                        Case "field_length"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, "Length")

                        Case "style"
                            sVal = DecodeTextStyle(CStr(v))
                            prp.Add(sVal, "Font")

                    End Select
                Next

            Case "POINT"
                prp.Add([0, 0, 0], "P1")
                For Each v In c
                    Select c.Key
                        Case "x"
                            f = DecodeFloat(CStr(v))
                            prp["P1"][0] = f

                        Case "y"
                            f = DecodeFloat(CStr(v))
                            prp["P1"][1] = f

                        Case "z"
                            f = DecodeFloat(CStr(v))
                            prp["P1"][2] = f

                    End Select
                Next

                f = DecodeFloat(c["x_ang"])
                prp.Add(f, "Angle")

            Case "LINE"
                For Each v In c
                    Select c.Key
                        Case "start"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")
                        Case "end"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P2")
                    End Select
                Next

            Case "INSERT"
                For Each v In c
                    Select c.Key

                        Case "ins_pt"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "scale_flag"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "scale"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "Scale")

                        Case "rotation"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Angle")

                        Case "extrusion"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, c.Key)

                        Case "has_attribs"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "num_owned"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "block_header"
                            sVal = DecodeBlockHeader(CStr(v))
                            prp.Add(sVal, c.Key)

                    End Select
                Next

            Case "CIRCLE"
                For Each v In c
                    Select c.Key
                        Case "center"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "radius"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Radius")
                    End Select
                Next

            Case "ARC"
                For Each v In c
                    Select c.Key
                        Case "center"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "radius"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Radius")

                        Case "start_angle"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Angle1")

                        Case "end_angle"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Angle2")
                    End Select
                Next

            Case "ELLIPSE"
                For Each v In c
                    Select c.Key
                        Case "center"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, "P1")

                        Case "sm_axis"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, c.Key)

                        Case "extrusion"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, c.Key)

                        Case "axis_ratio"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "start_angle"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Angle1")

                        Case "end_angle"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, "Angle2")

                    End Select

                Next

            Case "LWPOLYLINE"
                For Each v In c
                    Select c.Key
                        Case "num_points"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, "Points")
                            For p = 0 To i
                                sDec = "points[" & p & "]"
                                sTag = "P" & CStr(p)
                                If c.Exist(sDec) Then
                                    pt = DecodeCoord(CStr(c[sDec]))
                                    prp.Add(pt, sTag)
                                Endif
                            Next
                    End Select
                Next

            Case "HATCH"
                For Each v In c
                    Select c.Key

                        Case "is_gradient_fill"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "reserved"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "gradient_angle"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "gradient_shift"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "single_color_gradient"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "gradient_tint"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "num_colors"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "gradient_name"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, c.Key)

                        Case "elevation"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "extrusion"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, c.Key)

                        Case "name"
                            sVal = DecodeText(CStr(v))
                            prp.Add(sVal, c.Key)

                        Case "solid_fill"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "associative"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "num_paths"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "paths[0].flag"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "paths[0].num_segs_or_paths"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                            For p = 0 To i
                                sTag = "paths[0].segs[p].type_status"
                                sTag1 = "paths[0].segs[p].first_endpoint"
                                sTag2 = "paths[0].segs[p].second_endpoint"

                                If c.Exist(sTag) Then
                                    hx = DecodeHex(CStr(c[sTag]))
                                    prp.Add(hx, sTag1)
                                Endif

                                If c.Exist(sTag1) Then
                                    pt1 = DecodeCoord(CStr(c[sTag1]))
                                    prp.Add(pt1, sTag1)
                                Endif

                                If c.Exist(sTag2) Then
                                    pt2 = DecodeCoord(CStr(c[sTag2]))
                                    prp.Add(pt2, sTag2)
                                Endif

                            Next

                        Case "paths[0].num_boundary_handles"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "style"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "pattern_type"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "angle"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "scale_spacing"
                            f = DecodeFloat(CStr(v))
                            prp.Add(f, c.Key)

                        Case "double_flag"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "num_deflines"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                            For p = 0 To i

                                sTag1 = "deflines[" & CStr(i) & "].pt0"
                                pt = DecodeCoord(CStr(c[sTag1]))
                                prp.Add(pt, sTag1)

                                sTag2 = "deflines[" & CStr(i) & "].offset"
                                pt = DecodeCoord(CStr(c[sTag2]))
                                prp.Add(pt, sTag2)

                                sTag3 = "deflines[" & CStr(i) & "].num_dashes"
                                n = DecodeInteger(CStr(c[sTag3]))
                                prp.Add(n, sTag3)

                                For d = 0 To n
                                    sTag4 = "deflines[rcount1].dashes[" & CStr(d) & "]"
                                    f = DecodeFloat(CStr(c[sTag4]))
                                    prp.Add(f, sTag4)
                                Next
                                sTag5 = "deflines[rcount1].angle"
                                f = DecodeFloat(CStr(c[sTag5]))
                                prp.Add(f, sTag5)

                            Next

                        Case "num_seeds"
                            i = DecodeInteger(CStr(v))
                            prp.Add(i, c.Key)

                        Case "seeds[vcount]"
                            pt = DecodeCoord(CStr(v))
                            prp.Add(pt, c.Key)

                    End Select
                Next
        End Select
    Endif

    Return prp

End

Private Function DecodeCoord(s As String) As Float[]

    Dim pt As New Float[]
    Dim sVal As String

    sVal = Replace(s, " ", "")
    sVal = Replace(sVal, ",", ":")
    sVal = Replace(sVal, "(", "")
    sVal = Replace(sVal, ")", "")
    If InStr(sVal, "[") > 0 Then
        sVal = String.Mid(sVal, 1, InStr(sVal, "[") - 1)
    Endif

    pt = Split(sVal, ":")

    Return pt

End

Private Function DecodeHex(s As String) As Integer

    Dim out As Integer

    If InStr(s, "0x") > 0 Then
        out = Val(Replace(s, "0x", "&00"))
    Else
        out = 0
    Endif

    Return out

End

Private Function DecodeFloat(s As String) As Float

    Dim out As Float
    Dim sVal As String

    sVal = Replace(s, " ", "")
    If InStr(sVal, "[") > 0 Then
        out = Split(sVal, "[")[0]
    Else
        out = 0.0
    Endif

    Return out

End

Private Function DecodeInteger(s As String) As Integer

    Dim out As Integer
    Dim sVal As String

    sVal = Replace(s, " ", "")
    If InStr(sVal, "[") > 0 Then
        out = Split(sVal, "[")[0]
    Else
        out = 0
    Endif

    Return out

End

Private Function DecodeLayer(s As String) As String

    Dim out As String

    If InStr(s, " => LAYER ") > 0 Then
        out = Split(Replace(s, " => LAYER ", "\t"), "\t")[1]
    Else
        out = s
    Endif

    Return out

End

Private Function DecodeBlockHeader(s As String) As String

    Dim out As String

    If InStr(s, " => BLOCK_HEADER ") > 0 Then
        out = Split(Replace(s, " => BLOCK_HEADER ", "\t"), "\t")[1]
    Else
        out = s
    Endif

    Return out

End

Private Function DecodeTextStyle(s As String) As String

    Dim out As String

    If InStr(s, " => STYLE ") > 0 Then
        out = Split(Replace(s, " => STYLE ", "\t"), "\t")[1]
    Else
        out = s
    Endif

    Return out

End

Private Function DecodeText(s As String) As String

    Dim out As String

    s = Conv$(s, "ISO-8859-1", "UTF-8")
    If InStr(s, "\\U+") > 0 Then
        s = String2.Flat(s)
    Endif

    If InStr(s, " [") > 0 Then
        out = Split(Replace(s, " [", "\t"), "\t")[0]
        If String.Left(out) = Chr(34) Then
            out = String.Mid(out, 2)
        Endif
        If String.Right(out) = Chr(34) Then
            out = String.Mid(out, 1, String.Len(out) - 1)

        Endif
    Else
        out = s
    Endif

    Return out

End

Private Function DimCodes() As Collection

    Dim d As New Collection

    d.Add(["DIMPOST", "float"], "3")
    d.Add(["DIMAPOST", "float"], "4")
    d.Add(["DIMBLK", "string"], "5")
    d.Add(["DIMBLK1", "string"], "6")
    d.Add(["DIMBLK2", "string"], "7")
    d.Add(["DIMSCALE", "float"], "40")
    d.Add(["DIMASZ", "float"], "41")
    d.Add(["DIMEXO", "float"], "42")
    d.Add(["DIMDLI", "float"], "43")
    d.Add(["DIMEXE", "float"], "44")
    d.Add(["DIMRND", "float"], "45")
    d.Add(["DIMDLE", "float"], "46")
    d.Add(["DIMTP", "float"], "47")
    d.Add(["DIMTM", "float"], "48")
    d.Add(["DIMTXT", "float"], "140")
    d.Add(["DIMCEN", "float"], "141")
    d.Add(["DIMTSZ", "float"], "142")
    d.Add(["DIMALTF", "float"], "143")
    d.Add(["DIMLFAC", "float"], "144")
    d.Add(["DIMTVP", "float"], "145")
    d.Add(["DIMTFAC", "float"], "146")
    d.Add(["DIMGAP", "float"], "147")
    d.Add(["DIMALTRND", "float"], "148")
    d.Add(["DIMTOL", "float"], "71")
    d.Add(["DIMLIM", "float"], "72")
    d.Add(["DIMTIH", "float"], "73")
    d.Add(["DIMTOH", "float"], "74")
    d.Add(["DIMSE1", "float"], "75")
    d.Add(["DIMSE2", "float"], "76")
    d.Add(["DIMTAD", "float"], "77")
    d.Add(["DIMZIN", "float"], "78")
    d.Add(["DIMAZIN", "float"], "79")
    d.Add(["DIMALT", "float"], "170")
    d.Add(["DIMALTD", "float"], "171")
    d.Add(["DIMTOFL", "float"], "172")
    d.Add(["DIMSAH", "float"], "173")
    d.Add(["DIMTIX", "float"], "174")
    d.Add(["DIMSOXD", "float"], "175")
    d.Add(["DIMCLRD", "float"], "176")
    d.Add(["DIMCLRE", "float"], "177")
    d.Add(["DIMCLRT", "float"], "178")
    d.Add(["DIMADEC", "float"], "179")
    d.Add(["DIMUNIT", "float"], "270")
    d.Add(["DIMDEC", "float"], "271")
    d.Add(["DIMTDEC", "float"], "272")
    d.Add(["DIMALTU", "float"], "273")
    d.Add(["DIMALTTD", "float"], "274")
    d.Add(["DIMAUNIT", "float"], "275")
    d.Add(["DIMFRAC", "float"], "276")
    d.Add(["DIMLUNIT", "float"], "277")
    d.Add(["DIMDSEP", "float"], "278")
    d.Add(["DIMTMOVE", "float"], "279")
    d.Add(["DIMJUST", "float"], "280")
    d.Add(["DIMSD1", "float"], "281")
    d.Add(["DIMSD2", "float"], "282")
    d.Add(["DIMTOLJ", "float"], "283")
    d.Add(["DIMTZIN", "float"], "284")
    d.Add(["DIMALTZ", "float"], "285")
    d.Add(["DIMALTTZ", "float"], "286")
    d.Add(["DIMFIT", "float"], "287")
    d.Add(["DIMUPT", "float"], "288")
    d.Add(["DIMATFIT", "float"], "289")
    d.Add(["DIMTXSTY", "string"], "340")
    d.Add(["DIMLDRBLK", "string"], "341")
    d.Add(["DIMBLK", "string"], "342")
    d.Add(["DIMBLK1", "string"], "343")
    d.Add(["DIMBLK2", "string"], "344")
    d.Add(["DIMLWD", "string"], "371")
    d.Add(["DIMLWE", "string"], "372")

    Return d

End

'' This return a codes collection for the given entity name

Public Function EntityCodes(Optional ent As String) As Collection

    Dim cod As New Collection

    cod.Add("entity", "0") '*
    cod.Add("handle", "5") '*
    cod.Add("style", "6") '*
    cod.Add("layer", "8") '*
    cod.Add("colour", "62") '*
    cod.Add("width", "370") '*
    cod.Add("visible", "60") '*
    cod.Add("paper", "67") '*
    cod.Add("elev", "38")
    cod.Add("thick", "39")
    cod.Add("x0", "10")
    cod.Add("y0", "20")
    cod.Add("z0", "30")
    cod.Add("x1", "11")
    cod.Add("y1", "21")
    cod.Add("z1", "31")
    cod.Add("extrx", "210")
    cod.Add("extry", "220")
    cod.Add("extrz", "230")
    cod.Add("blkid", "330")

    Select String.LCase(ent)

        Case "lwpolyline"
            cod.Add("points", "90")
            cod.Add("closed", "70")
            cod.Add("constant", "43")

        Case "arc"
            cod.Add("radius", "40")
            cod.Add("angle0", "50")
            cod.Add("angle1", "51")

        Case "circle"
            cod.Add("radius", "40")

        Case "ellipse"
            cod.Add("ratio", "40")
            cod.Add("angle0", "41")
            cod.Add("angle1", "42")

        Case "attdef"
            cod.Add("texth", "40")
            cod.Add("defval", "1")
            cod.Add("tag", "2")
            cod.Add("promt", "3")
            cod.Add("flen", "73")
            cod.Add("vert", "74")
            cod.Add("angle", "50")
            cod.Add("wfactor", "41")
            cod.Add("tstyle", "7")
            cod.Add("oblique", "51")
            cod.Add("version", "280")

        Case "block"
            cod.Add("xref", "1")
            cod.Add("block", "2")
            cod.Add("bdesc", "4")

        Case "insert"
            cod.Add("block", "2")
            cod.Add("scalex", "41")
            cod.Add("scaley", "42")
            cod.Add("scalex", "43")
            cod.Add("angle", "50")
            cod.Add("columns", "70")
            cod.Add("rows", "71")
            cod.Add("cspa", "44")
            cod.Add("rspa", "44")

    End Select

    Return cod

End

'Dim d As New Collection

Public Function RGBColors() As String[]

    Dim rgbx As New String[]

    rgbx.Add("0,0,0")
    rgbx.Add("255,0,0")
    rgbx.Add("255,255,0")
    rgbx.Add("0,255,0")
    rgbx.Add("0,255,255")
    rgbx.Add("0,0,255")
    rgbx.Add("255,0,255")
    rgbx.Add("255,255,255")
    rgbx.Add("128,128,128")
    rgbx.Add("192,192,192")
    rgbx.Add("255,0,0")
    rgbx.Add("255,127,127")
    rgbx.Add("165,0,0")
    rgbx.Add("165,82,82")
    rgbx.Add("127,0,0")
    rgbx.Add("127,63,63")
    rgbx.Add("76,0,0")
    rgbx.Add("76,38,38")
    rgbx.Add("38,0,0")
    rgbx.Add("38,19,19")
    rgbx.Add("255,63,0")
    rgbx.Add("255,159,127")
    rgbx.Add("165,41,0")
    rgbx.Add("165,103,82")
    rgbx.Add("127,31,0")
    rgbx.Add("127,79,63")
    rgbx.Add("76,19,0")
    rgbx.Add("76,47,38")
    rgbx.Add("38,9,0")
    rgbx.Add("38,23,19")
    rgbx.Add("255,127,0")
    rgbx.Add("255,191,127")
    rgbx.Add("165,82,0")
    rgbx.Add("165,124,82")
    rgbx.Add("127,63,0")
    rgbx.Add("127,95,63")
    rgbx.Add("76,38,0")
    rgbx.Add("76,57,38")
    rgbx.Add("38,19,0")
    rgbx.Add("38,28,19")
    rgbx.Add("255,191,0")
    rgbx.Add("255,223,127")
    rgbx.Add("165,124,0")
    rgbx.Add("165,145,82")
    rgbx.Add("127,95,0")
    rgbx.Add("127,111,63")
    rgbx.Add("76,57,0")
    rgbx.Add("76,66,38")
    rgbx.Add("38,28,0")
    rgbx.Add("38,33,19")
    rgbx.Add("255,255,0")
    rgbx.Add("255,255,127")
    rgbx.Add("165,165,0")
    rgbx.Add("165,165,82")
    rgbx.Add("127,127,0")
    rgbx.Add("127,127,63")
    rgbx.Add("76,76,0")
    rgbx.Add("76,76,38")
    rgbx.Add("38,38,0")
    rgbx.Add("38,38,19")
    rgbx.Add("191,255,0")
    rgbx.Add("223,255,127")
    rgbx.Add("124,165,0")
    rgbx.Add("145,165,82")
    rgbx.Add("95,127,0")
    rgbx.Add("111,127,63")
    rgbx.Add("57,76,0")
    rgbx.Add("66,76,38")
    rgbx.Add("28,38,0")
    rgbx.Add("33,38,19")
    rgbx.Add("127,255,0")
    rgbx.Add("191,255,127")
    rgbx.Add("82,165,0")
    rgbx.Add("124,165,82")
    rgbx.Add("63,127,0")
    rgbx.Add("95,127,63")
    rgbx.Add("38,76,0")
    rgbx.Add("57,76,38")
    rgbx.Add("19,38,0")
    rgbx.Add("28,38,19")
    rgbx.Add("63,255,0")
    rgbx.Add("159,255,127")
    rgbx.Add("41,165,0")
    rgbx.Add("103,165,82")
    rgbx.Add("31,127,0")
    rgbx.Add("79,127,63")
    rgbx.Add("19,76,0")
    rgbx.Add("47,76,38")
    rgbx.Add("9,38,0")
    rgbx.Add("23,38,19")
    rgbx.Add("0,255,0")
    rgbx.Add("127,255,127")
    rgbx.Add("0,165,0")
    rgbx.Add("82,165,82")
    rgbx.Add("0,127,0")
    rgbx.Add("63,127,63")
    rgbx.Add("0,76,0")
    rgbx.Add("38,76,38")
    rgbx.Add("0,38,0")
    rgbx.Add("19,38,19")
    rgbx.Add("0,255,63")
    rgbx.Add("127,255,159")
    rgbx.Add("0,165,41")
    rgbx.Add("82,165,103")
    rgbx.Add("0,127,31")
    rgbx.Add("63,127,79")
    rgbx.Add("0,76,19")
    rgbx.Add("38,76,47")
    rgbx.Add("0,38,9")
    rgbx.Add("19,38,23")
    rgbx.Add("0,255,127")
    rgbx.Add("127,255,191")
    rgbx.Add("0,165,82")
    rgbx.Add("82,165,124")
    rgbx.Add("0,127,63")
    rgbx.Add("63,127,95")
    rgbx.Add("0,76,38")
    rgbx.Add("38,76,57")
    rgbx.Add("0,38,19")
    rgbx.Add("19,38,28")
    rgbx.Add("0,255,191")
    rgbx.Add("127,255,223")
    rgbx.Add("0,165,124")
    rgbx.Add("82,165,145")
    rgbx.Add("0,127,95")
    rgbx.Add("63,127,111")
    rgbx.Add("0,76,57")
    rgbx.Add("38,76,66")
    rgbx.Add("0,38,28")
    rgbx.Add("19,38,33")
    rgbx.Add("0,255,255")
    rgbx.Add("127,255,255")
    rgbx.Add("0,165,165")
    rgbx.Add("82,165,165")
    rgbx.Add("0,127,127")
    rgbx.Add("63,127,127")
    rgbx.Add("0,76,76")
    rgbx.Add("38,76,76")
    rgbx.Add("0,38,38")
    rgbx.Add("19,38,38")
    rgbx.Add("0,191,255")
    rgbx.Add("127,223,255")
    rgbx.Add("0,124,165")
    rgbx.Add("82,145,165")
    rgbx.Add("0,95,127")
    rgbx.Add("63,111,127")
    rgbx.Add("0,57,76")
    rgbx.Add("38,66,76")
    rgbx.Add("0,28,38")
    rgbx.Add("19,33,38")
    rgbx.Add("0,127,255")
    rgbx.Add("127,191,255")
    rgbx.Add("0,82,165")
    rgbx.Add("82,124,165")
    rgbx.Add("0,63,127")
    rgbx.Add("63,95,127")
    rgbx.Add("0,38,76")
    rgbx.Add("38,57,76")
    rgbx.Add("0,19,38")
    rgbx.Add("19,28,38")
    rgbx.Add("0,63,255")
    rgbx.Add("127,159,255")
    rgbx.Add("0,41,165")
    rgbx.Add("82,103,165")
    rgbx.Add("0,31,127")
    rgbx.Add("63,79,127")
    rgbx.Add("0,19,76")
    rgbx.Add("38,47,76")
    rgbx.Add("0,9,38")
    rgbx.Add("19,23,38")
    rgbx.Add("0,0,255")
    rgbx.Add("127,127,255")
    rgbx.Add("0,0,165")
    rgbx.Add("82,82,165")
    rgbx.Add("0,0,127")
    rgbx.Add("63,63,127")
    rgbx.Add("0,0,76")
    rgbx.Add("38,38,76")
    rgbx.Add("0,0,38")
    rgbx.Add("19,19,38")
    rgbx.Add("63,0,255")
    rgbx.Add("159,127,255")
    rgbx.Add("41,0,165")
    rgbx.Add("103,82,165")
    rgbx.Add("31,0,127")
    rgbx.Add("79,63,127")
    rgbx.Add("19,0,76")
    rgbx.Add("47,38,76")
    rgbx.Add("9,0,38")
    rgbx.Add("23,19,38")
    rgbx.Add("127,0,255")
    rgbx.Add("191,127,255")
    rgbx.Add("82,0,165")
    rgbx.Add("124,82,165")
    rgbx.Add("63,0,127")
    rgbx.Add("95,63,127")
    rgbx.Add("38,0,76")
    rgbx.Add("57,38,76")
    rgbx.Add("19,0,38")
    rgbx.Add("28,19,38")
    rgbx.Add("191,0,255")
    rgbx.Add("223,127,255")
    rgbx.Add("124,0,165")
    rgbx.Add("145,82,165")
    rgbx.Add("95,0,127")
    rgbx.Add("111,63,127")
    rgbx.Add("57,0,76")
    rgbx.Add("66,38,76")
    rgbx.Add("28,0,38")
    rgbx.Add("33,19,38")
    rgbx.Add("255,0,255")
    rgbx.Add("255,127,255")
    rgbx.Add("165,0,165")
    rgbx.Add("165,82,165")
    rgbx.Add("127,0,127")
    rgbx.Add("127,63,127")
    rgbx.Add("76,0,76")
    rgbx.Add("76,38,76")
    rgbx.Add("38,0,38")
    rgbx.Add("38,19,38")
    rgbx.Add("255,0,191")
    rgbx.Add("255,127,223")
    rgbx.Add("165,0,124")
    rgbx.Add("165,82,145")
    rgbx.Add("127,0,95")
    rgbx.Add("127,63,111")
    rgbx.Add("76,0,57")
    rgbx.Add("76,38,66")
    rgbx.Add("38,0,28")
    rgbx.Add("38,19,33")
    rgbx.Add("255,0,127")
    rgbx.Add("255,127,191")
    rgbx.Add("165,0,82")
    rgbx.Add("165,82,124")
    rgbx.Add("127,0,63")
    rgbx.Add("127,63,95")
    rgbx.Add("76,0,38")
    rgbx.Add("76,38,57")
    rgbx.Add("38,0,19")
    rgbx.Add("38,19,28")
    rgbx.Add("255,0,63")
    rgbx.Add("255,127,159")
    rgbx.Add("165,0,41")
    rgbx.Add("165,82,103")
    rgbx.Add("127,0,31")
    rgbx.Add("127,63,79")
    rgbx.Add("76,0,19")
    rgbx.Add("76,38,47")
    rgbx.Add("38,0,9")
    rgbx.Add("38,19,23")
    rgbx.Add("0,0,0")
    rgbx.Add("51,51,51")
    rgbx.Add("102,102,102")
    rgbx.Add("153,153,153")
    rgbx.Add("204,204,204")
    rgbx.Add("255,255,255")

    Return rgbx

End

'' Input a dxf color return a rgb color

Public Function DecodeColor() As Integer[]

    Dim rgb As New Integer[]

    Dim s As String
    Dim r As String
    Dim g As String
    Dim b As String
    Dim irgb As Integer
    Dim rgbx As String[]

    rgbx = RGBColors()

    For Each s In rgbx
        r = Split(s, ",")[0]
        g = Split(s, ",")[1]
        b = Split(s, ",")[2]
        irgb = Color.RGB(CInt(r), CInt(g), CInt(b))
        rgb.Add(irgb)
    Next

    Return rgb

End

'' Create a collection whith te program variables needed

Public Function CADConfig() As Collection

    Dim ctnOut As New Collection
    Dim ctnTmp As New Collection
    Dim str As String
    Dim sBase As String

    sBase = User.Home &/ "." & String.LCase(vag.NoSymbols(Application.Name))

    ctnTmp.Clear

    ctnTmp.Add("CAD.Background-Dark", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(False, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Drawing window bacground color"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)

    ctnTmp.Add("CAD.DrawOriginals", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(False, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Draw originals"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)

    ctnTmp.Add("CAD.DrawMarcados", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(True, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Draw marked"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'DrawMarcados As Boolean = True

    ctnTmp.Add("CAD.DrawSoloColumnas", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(False, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Draw only columns"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'DrawSoloColumnas As Boolean = False

    ctnTmp.Add("CAD.DrawBounds", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(False, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Draw bounds"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'DrawBounds As Boolean = False

    ctnTmp.Add("CAD.FormatoCotas", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add("0.00", "Value")
    ctnTmp.Add("String", "Data")
    ctnTmp.Add("txo", "Ctrl")
    ctnTmp.Add(("Dimensions format"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'FormatoCotas As String = "0.00"

    ctnTmp.Add("CAD.ColorForSelected", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(&H70E000, "Value")
    ctnTmp.Add("String", "Data")
    ctnTmp.Add("txo", "Ctrl")
    ctnTmp.Add(("Color sellection"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'ColorForSelected As Integer = &H70E000

    ctnTmp.Add("CAD.ToolActive", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(True, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Tool active"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'ToolActive As Boolean

    ctnTmp.Add("CAD.Ortogonal", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(False, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Ortogonal"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'Ortogonal As Boolean = False

    ctnTmp.Add("CAD.OrtogonalForzado", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(False, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Oorthogonal forced"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'OrtogonalForzado As Boolean = False

    ctnTmp.Add("CAD.OrtogonalIgnorado", "Name")
    ctnTmp.Add(("CAD"), "Group")
    ctnTmp.Add(False, "Value")
    ctnTmp.Add("Boolean", "Data")
    ctnTmp.Add("cko", "Ctrl")
    ctnTmp.Add(("Oorthogonal ignored"), "Desc")
    str = ctnTmp["Name"]
    ctnOut.Add(ctnTmp.Copy(), str)
    'OrtogonalIgnorado As Boolean = False

    Return ctnOut

End

'DXF ========================================================================

Public Function GetDXFSections(sFile As String) As Collection

    Dim sContent As String
    Dim tmx As New String[]
    'Dim stx As New String[]
    Dim sec As String
    Dim sSub As String
    Dim i As Integer
    Dim out As New Collection
    Dim sName As String
    Dim sCont As String
    Dim cCont As New Collection
    Dim isec As Variant

    'Dim isec As String

    If Exist(sFile) Then
        If Stat(sFile).Type = gb.File Then
            sContent = File.Load(sFile)
            sSub = String.Mid(sContent, 1, 25)

            out.Add(File.Name(sFile), "File")

            For i = 1 To String.Len(sSub)
                Print Asc(String.Mid(sSub, i, 1)) & " " & String.Mid(sSub, i, 1)
            Next

            sContent = Replace(sContent, "\r\n", "\n")
            sContent = Replace(sContent, "\t", " ")
            sContent = Replace(sContent, "  0\nSECTION\n  2\n", "\t")
            sContent = Replace(sContent, "  0\nENDSEC\n", "\t")
            tmx = Split(sContent, "\t")

            If tmx.count > 0 Then
                For Each sec In tmx
                    If sec <> "" Then
                        sName = Split(sec, "\n")[0]
                        sCont = String.Mid(sec, String.Len(sName & "\n") + 1)

                        File.Save(User.Home &/ sName & ".txt", sCont)
                        Select sName
                            Case "HEADER"
                                cCont = GetDXFHeader(sCont)
                                If cCont.Exist("ACADVER") Then
                                    out.Add(cCont["ACADVER"], "version")
                                Endif
                                out.Add(cCont, "Variables")

                            Case "TABLES"
                                cCont = GetDXFTables(sCont)
                                For Each isec In cCont
                                    out.Add(isec.Copy(), cCont.Key)
                                Next

                            Case "BLOCKS"
                                cCont = GetDXFBlocks(sCont)
                                out.Add(cCont, "Blocks")

                            Case "ENTITIES"
                                cCont = GetDXFEntities(sCont)
                                out.Add(cCont, "Entities")

                                'Case "CLASSES", "OBJECTS"
                                '    out.Add(sCont, sName)
                        End Select

                    Endif
                Next
            Endif
        Endif
    Endif

    Return out

End

Public Function GetDXFBlocks(sCont As String) As Collection

    Dim stx As New String[]
    Dim out As New Collection
    Dim i As Integer
    Dim cItem As New Collection
    'Dim e As Variant
    'Dim sKey As String

    sCont = Replace(sCont, "\t", " ")
    sCont = Replace(sCont, "  0\nBLOCK\n", "\t  0\nBLOCK\n")

    stx = Split(sCont, "\t")

    For i = 0 To stx.Max
        If InStr(stx[i], "AcDbBlockBegin") > 0 Then
            If String2.Count(stx[i], "\n  0\n") > 1 And InStr(stx[i], "  0\nVIEWPORT") = 0 Then
                'cItem = DecodeDXFEntity(stx[i])
                cItem = DecodeDXFBlock(stx[i])
                If cItem.Count > 1 Then
                    '     sKey = ""
                    '     For Each e In cItem
                    '         If e["entity"] = "BLOCK" Then
                    '             sKey = cItem.Key
                    '             Break
                    '         Endif
                    '     Next
                    '     If sKey <> "" Then
                    out.Add(cItem.Copy(), cItem["block"])
                    cItem.Clear
                    '     Endif
                    '
                Endif
            Endif
        Endif
    Next
    Return out

End

Public Function GetDXFEntities(sCont As String) As Collection

    Dim stx As New String[]
    'Dim cTmp As New Collection
    Dim out As New Collection
    'Dim item As String
    'Dim sRec As String
    Dim i As Integer
    'Dim j As Integer
    'Dim slx As String[]
    'Dim sTag As String
    'Dim sVal As String
    'Dim blx As New String[]
    'Dim k As Integer
    Dim cItem As New Collection
    'Dim e As Variant
    Dim sKey As String
    Dim cEnty As Collection
    Dim eN As Variant

    cEnty = GetEntityList()

    sCont = Replace(sCont, "\t", " ")

    For Each eN In cEnty
        sCont = Replace(sCont, "  0\n" & cEnty.Key & "\n  5\n", "\t  0\n" & cEnty.Key & "\n  5\n")
    Next
    'sCont = Replace(sCont, "  0\n", "\t  0\n")

    '  0\nLWPOLYLINE\n  5\n

    stx = Split(sCont, "\t")

    For i = 0 To stx.Max
        If InStr(stx[i], "\n100\nAcDbEntity\n") > 0 Then
            'If String2.Count(stx[i], "\n  0\n") > 1 And InStr(stx[i], "  0\nVIEWPORT") = 0 Then
            If InStr(stx[i], "  0\nLWPOLYLINE") > 0 Then
                Print "x"
            Endif
            cItem = DecodeDXFEntity(stx[i])
            If cItem.Count > 1 Then
                sKey = ""
                If cItem.Exist("handle") Then
                    sKey = cItem["handle"]
                    out.Add(cItem.Copy(), sKey)
                Endif
            Endif
        Endif
    Next
    Return out

End

Public Function GetDXFHeader(sCont As String) As Collection

    'Dim tmx As New String[]
    Dim stx As New String[]
    Dim cTmp As New Collection
    Dim out As New Collection
    Dim i As Integer
    Dim item As String
    Dim vrt As Variant
    'Dim v As Variant
    'Dim f As Variant
    'Dim s As String
    'Dim d As String

    sCont = Replace(sCont, "  9\n$", "\t")

    stx = Split(sCont, "\t")

    For Each item In stx
        If item <> "" Then
            cTmp = DecodeDXFItem(item)
            Select cTmp.Count
                Case 0
                    'skip
                Case 1
                    For Each vrt In cTmp
                        out.Add(vrt, cTmp.Key)
                    Next

                Case Else
                    Print "overload"
            End Select
        Endif
        Inc i
    Next
    Return out

End

Public Function GetDXFTables(sCont As String) As Collection

    'Dim tmx As New String[]
    Dim stx As New String[]
    'Dim cTmp As New Collection
    Dim cDecoded As New Collection
    Dim out As New Collection
    'Dim i As Integer
    Dim item As String
    'Dim vrt As Variant
    'Dim v As Variant
    'Dim f As Variant
    'Dim s As String
    'Dim d As String

    sCont = Replace(sCont, "\t", " ")
    sCont = Replace(sCont, "  0\nTABLE\n  2\n", "\t")
    sCont = Replace(sCont, "  0\nENDTAB\n", "\t")

    stx = Split(sCont, "\t")

    For Each item In stx
        If item <> "" Then
            If InStr(item, "\n  5\n") > 0 Then
                Select Split(item, "\n")[0]
                    Case "LAYER"
                        cDecoded = GetDXFLayerList(item)
                        out.Add(cDecoded.Copy(), "Layers")
                        cDecoded.Clear
                    Case "LTYPE"
                        cDecoded = GetDXFLtypeList(item)
                        out.Add(cDecoded.Copy(), "LineTypes")
                        cDecoded.Clear
                    Case "STYLE"
                        cDecoded = GetDXFStyleList(item)
                        out.Add(cDecoded.Copy(), "TextStyles")
                        cDecoded.Clear
                    Case "DIMSTYLE"
                        cDecoded = GetDXFDimStyleList(item)
                        out.Add(cDecoded.Copy(), "DimStyles")
                        cDecoded.Clear
                    Case "BLOCK_RECORD"
                        cDecoded = GetDXFBLockList(item)
                        out.Add(cDecoded.Copy(), "BLockRecord")
                        cDecoded.Clear
                End Select
            Endif
        Endif
    Next
    Return out

End

Private Function GetDXFLayerList(sItem As String) As Collection

    Dim stx As String[]
    Dim i As Integer
    Dim sCont As String
    Dim cTmp As New Collection
    Dim cDeco As New Collection
    Dim sLay As String
    Dim slx As String[]
    'Dim s As String
    'Dim lName As String
    Dim sTag As String
    Dim sVal As String
    Dim j As Integer

    sCont = Replace(sItem, "\t", " ")
    sCont = Replace(sCont, "LAYER\n  5\n", "\t")
    sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
    '
    stx = Split(sCont, "\t")

    For i = 0 To stx.Max
        If InStr(stx[i], "AcDbLayerTableRecord\n  2\n") > 0 Then
            sLay = Replace(stx[i], "AcDbLayerTableRecord\n  2\n", "")
            slx = Split(slay, "\n")

            cTmp.Add(slx[0], "name")

            For j = 1 To slx.Max - 2 Step 2
                sTag = Replace(slx[j], " ", "")
                sVal = Replace(slx[j + 1], " ", "")
                Select sTag
                    Case "70"
                        Select sVal
                            Case "1"
                                cTmp.Add(True, "frozen")
                                cTmp.Add(False, "locked")
                            Case "4"
                                cTmp.Add(False, "frozen")
                                cTmp.Add(True, "locked")
                            Case Else
                                cTmp.Add(False, "locked")
                                cTmp.Add(False, "frozen")
                        End Select
                    Case "62"
                        If InStr(sVal, "-") = 0 Then
                            cTmp.Add(True, "show")
                            cTmp.Add(CInt(sVal), "colour")
                        Else
                            cTmp.Add(False, "show")
                            cTmp.Add(CInt(Replace(sVal, "-", "")), "colour")
                        Endif

                    Case "6"
                        cTmp.Add(sVal, "style")

                    Case "290"
                        If sVal = 0 Then
                            cTmp.Add(False, "print")
                        Else
                            cTmp.Add(True, "print")
                        Endif

                    Case "370"
                        cTmp.Add(CInt(sVal), "width")

                End Select
                If cTmp.Exist("print") = False Then
                    cTmp.Add(True, "print")
                Endif

            Next

            cDeco.Add(cTmp.Copy(), slx[0])
            cTmp.Clear

        Endif

    Next

    Return cDeco

End

Private Function GetDXFLtypeList(sItem As String) As Collection

    Dim stx As String[]
    Dim i As Integer
    Dim sCont As String
    Dim cTmp As New Collection
    Dim cDeco As New Collection
    Dim sLay As String
    Dim slx As String[]
    'Dim s As String
    'Dim lName As String
    Dim sTag As String
    Dim sVal As String
    Dim j As Integer

    sCont = Replace(sItem, "\t", " ")
    sCont = Replace(sCont, "LTYPE\n  5\n", "\t")
    sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
    '
    stx = Split(sCont, "\t")

    For i = 0 To stx.Max
        If InStr(stx[i], "AcDbLinetypeTableRecord\n  2\n") > 0 Then
            sLay = Replace(stx[i], "AcDbLinetypeTableRecord\n  2\n", "")
            slx = Split(slay, "\n")

            cTmp.Add(slx[0], "Ltype")

            For j = 1 To slx.Max - 2 Step 2
                sTag = Replace(slx[j], " ", "")
                sVal = Replace(slx[j + 1], " ", "")
                Select sTag

                    Case "3"
                        cTmp.Add(sVal, "desc")

                    Case "72"
                        cTmp.Add(CInt(sVal), "align")

                    Case "73"
                        cTmp.Add(CInt(sVal), "elements")

                    Case "40"
                        cTmp.Add(CFloat(sVal), "patern")

                End Select

            Next

            cDeco.Add(cTmp.Copy(), slx[0])
            cTmp.Clear

        Endif

    Next

    Return cDeco

End

Private Function GetDXFStyleList(sItem As String) As Collection

    Dim stx As String[]
    Dim i As Integer
    Dim sCont As String
    Dim cTmp As New Collection
    Dim cDeco As New Collection
    Dim sLay As String
    Dim slx As String[]
    'Dim s As String
    'Dim lName As String
    Dim sTag As String
    Dim sVal As String
    Dim j As Integer

    sCont = Replace(sItem, "\t", " ")
    sCont = Replace(sCont, "STYLE\n  5\n", "\t")
    sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
    '
    stx = Split(sCont, "\t")

    For i = 0 To stx.Max
        If InStr(stx[i], "AcDbTextStyleTableRecord\n  2\n") > 0 Then
            sLay = Replace(stx[i], "AcDbTextStyleTableRecord\n  2\n", "")
            slx = Split(slay, "\n")

            cTmp.Add(slx[0], "Style")

            For j = 1 To slx.Max - 2 Step 2
                sTag = Replace(slx[j], " ", "")
                sVal = Replace(slx[j + 1], " ", "")
                Select sTag
                    Case "70"
                        Select sVal
                            Case "1"
                                cTmp.Add(True, "shape")
                            Case "4"
                                cTmp.Add(True, "vertical")
                        End Select
                    Case "40"
                        cTmp.Add(CFloat(sVal), "fixed")

                    Case "41"
                        cTmp.Add(CFloat(sVal), "wfactor")
                    Case "50"
                        cTmp.Add(CFloat(sVal), "oblique")

                    Case "71"
                        Select sVal
                            Case "2"
                                cTmp.Add(True, "mirrored_x")
                            Case "4"
                                cTmp.Add(True, "mirrored_y")
                        End Select

                    Case "42"
                        cTmp.Add(CFloat(sVal), "last")

                    Case "3"
                        cTmp.Add(sVal, "font")
                    Case "4"

                        If sVal <> "" Then
                            cTmp.Add(sVal, "fbig")
                        Endif

                End Select

            Next

            cDeco.Add(cTmp.Copy(), slx[0])
            cTmp.Clear

        Endif

    Next

    Return cDeco

End

Private Function GetDXFDimStyleList(sItem As String) As Collection

    Dim stx As String[]
    Dim i As Integer
    Dim sCont As String
    Dim cTmp As New Collection
    Dim cDeco As New Collection
    Dim sLay As String
    Dim slx As String[]
    'Dim s As String
    'Dim lName As String
    Dim sTag As String
    Dim sVal As String
    Dim j As Integer
    Dim code As Collection

    code = DimCodes()

    sCont = Replace(sItem, "\t", " ")
    sCont = Replace(sCont, "STYLE\n  5\n", "\t")
    sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
    '
    stx = Split(sCont, "\t")

    For i = 0 To stx.Max
        If InStr(stx[i], "AcDbDimStyleTableRecord\n  2\n") > 0 Then
            sLay = Replace(stx[i], "AcDbDimStyleTableRecord\n  2\n", "")
            slx = Split(slay, "\n")

            cTmp.Add(slx[0], "DimStyle")

            For j = 1 To slx.Max - 2 Step 2
                sTag = Replace(slx[j], " ", "")
                sVal = Replace(slx[j + 1], " ", "")
                If code.Exist(sTag) Then
                    Select code[sTag][1]
                        Case "string"
                            cTmp.Add(sVal, code[sTag][0])
                        Case "float"
                            cTmp.Add(CFloat(sVal), code[sTag][0])
                    End Select
                Endif
            Next
            cDeco.Add(cTmp.Copy(), slx[0])
            cTmp.Clear
        Endif
    Next

    Return cDeco

End

Private Function GetDXFBLockList(sItem As String) As Collection

    Dim stx As String[]
    Dim i As Integer
    Dim sCont As String
    Dim cTmp As New Collection
    Dim cDeco As New Collection
    Dim sLay As String
    Dim slx As String[]
    'Dim s As String
    'Dim lName As String
    Dim sTag As String
    Dim sVal As String
    Dim j As Integer

    sCont = Replace(sItem, "\t", " ")
    sCont = Replace(sCont, "BLOCK_RECORD\n  5\n", "\t")
    sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
    '
    stx = Split(sCont, "\t")

    For i = 0 To stx.Max
        If InStr(stx[i], "AcDbBlockTableRecord\n  2\n") > 0 Then
            sLay = Replace(stx[i], "AcDbBlockTableRecord\n  2\n", "")
            slx = Split(slay, "\n")

            cTmp.Add(slx[0], "Block")

            For j = 1 To slx.Max - 2 Step 2
                sTag = Replace(slx[j], " ", "")
                sVal = Replace(slx[j + 1], " ", "")
                Select sTag

                    Case "70"
                        cTmp.Add(sVal, "units")

                    Case "340"
                        cTmp.Add(CInt(sVal), "handle")

                End Select

            Next

            cDeco.Add(cTmp.Copy(), slx[0])
            cTmp.Clear

        Endif

    Next

    Return cDeco

End

Private Function DecodeDXFEntity(sItem As String) As Collection

    Dim stx As String[]
    Dim cTmp As New Collection
    Dim cTmp2 As New Collection
    Dim i As Integer
    Dim sTag As String
    Dim Entity As String
    Dim sVal As String
    Dim codes As New Collection
    Dim rep As New Collection
    Dim e As Variant
    Dim p As New Float[]
    Dim x As Float
    Dim y As Float
    Dim z As Float
    Dim xTag As String
    Dim xOrd As String
    Dim pt As String
    Dim pt2 As String
    Dim spt As New String[]
    Dim cp As New Collection
    Dim a1 As Float
    Dim a2 As Float
    Dim r As Float
    Dim sx As Float
    Dim c As Integer
    Dim sy As Float
    Dim sz As Float

    stx = Split(sItem, "\n")

    If stx[0] = "  0" Then
        sTag = "entity"
        sVal = stx[1]
        cTmp.Add(sVal, sTag)
        codes = EntityCodes(sVal)
    Endif

    For i = 0 To stx.Max Step 2
        If stx[i] <> "" Then
            sTag = Replace(stx[i], " ", "")
            If codes.Exist(sTag) Then
                sTag = codes[sTag]
            Endif
            If rep.Exist(sTag) = False Then
                rep.Add([1, 0], sTag)
            Else
                rep[sTag][0] = rep[sTag][0] + 1
            Endif
        Endif
    Next

    For i = 0 To stx.Max Step 2
        If stx[i] = "  0" Then
            Entity = ""
            cTmp.Clear
            sVal = stx[i + 1]
            cTmp.Add(sVal, "entity")
        Else
            If stx[i] <> "" Then
                If codes.Count = 0 Then
                    Print "Error codes"
                Endif

                sTag = Replace(stx[i], " ", "")
                If codes.Exist(sTag) Then
                    sTag = codes[sTag]
                Endif

                sVal = stx[i + 1]

                If rep.Exist(sTag) And rep[sTag][0] > 1 Then
                    rep[sTag][1] = rep[sTag][1] + 1
                    cTmp.Add(sVal, sTag & "." & CStr(rep[sTag][1]))
                Else
                    cTmp.Add(sVal, sTag)
                Endif

            Endif
        Endif
    Next

    If cTmp.Exist("style") = False Then
        cTmp.Add(0, "style")
    Endif

    If cTmp.Exist("width") = False Then
        cTmp.Add(0, "width")
    Endif

    If cTmp.Exist("colour") = False Then
        cTmp.Add(0, "colour")
    Endif

    If cTmp.Exist("x0") Or cTmp.Exist("x0.1") Then
        'Select cTmp["entity"]
        '    Case "LWPOLYLINE", "LINE", "XLINE", "POLYLINE", "SPLINE", "ARC", "CIRCLE", "ELLIPSE", "VERTEX", "INSERT", "POINT", "ATTRIB", "ATTDEF"
        spt.Clear
        For Each e In cTmp
            If InStr(cTmp.Key, "x0") > 0 Or InStr(cTmp.Key, "x1") > 0 Then

                If InStr(cTmp.Key, ".") > 0 Then
                    xTag = Split(cTmp.Key, ".")[0]
                    xOrd = "." & Split(cTmp.Key, ".")[1]
                Else
                    xTag = cTmp.Key
                    xOrd = ""
                Endif

                Select xTag
                    Case "x0"
                        pt = cTmp[cTmp.Key]
                        If cTmp.Exist("y0" & xOrd) Then
                            pt &= ":" & cTmp["y0" & xOrd]
                        Endif
                        If cTmp.Exist("z0" & xOrd) Then
                            pt &= ":" & cTmp["z0" & xOrd]
                        Endif
                        spt.Add(pt)
                    Case "x1"
                        pt = cTmp[cTmp.Key]
                        If cTmp.Exist("y1" & xOrd) Then
                            pt &= ":" & cTmp["y1" & xOrd]
                        Endif
                        If cTmp.Exist("z1" & xOrd) Then
                            pt &= ":" & cTmp["z1" & xOrd]
                        Endif
                        spt.Add(pt)
                End Select
            Endif

            'If InStr(cTmp.Key, "x0") = 0 And InStr(cTmp.Key, "y0") = 0 And InStr(cTmp.Key, "z0") = 0 Then
            '    If InStr(cTmp.Key, "x1") = 0 And InStr(cTmp.Key, "y1") = 0 And InStr(cTmp.Key, "z1") = 0 Then
            '        cTmp2.Add(cTmp[cTmp.Key], cTmp.Key)
            '    Endif
            'Endif
            Select cTmp.Key
                Case "entity", "handle", "layer", "style", "width", "colour", "blkid", "visible", "paper", "elev", "thick"
                    cTmp2.Add(cTmp[cTmp.Key], cTmp.Key)
            End Select

        Next
        cp = EncodePoint(spt.Join(";"), "p")
        cTmp2.Add(cp.Copy(), "p")
        cp.Clear

        Select cTmp["entity"]

            Case "BLOCK"
                If cTmp.Exist("block") Then
                    cTmp2.Add(cTmp["block"], "block")
                Else
                    cTmp2.Add("", "block")
                Endif
                If cTmp.Exist("bdesc") Then
                    cTmp2.Add(cTmp["bdesc"], "bdesc")
                Else
                    cTmp2.Add("", "bdesc")
                Endif

            Case "ELLIPSE", "CIRCLE", "ARC"
                If cTmp.Exist("ratio") Then ' For ellipse
                    r = CFloat(cTmp["ratio"])
                    cTmp2.Add(r, "r")
                Endif

                If cTmp.Exist("radius") Then ' For circle and arc
                    r = CFloat(cTmp["radius"])
                    cTmp2.Add(r, "r")
                Endif

                If cTmp.Exist("angle0") And cTmp.Exist("angle1") Then ' For ellipse and arc
                    a1 = CFloat(cTmp["angle0"])
                    a2 = CFloat(cTmp["angle1"])
                    cTmp2.Add([a1, a2], "a")
                Endif

            Case "INSERT"

                If cTmp.Exist("block") Then
                    cTmp2.Add(cTmp["block"], "b")
                Else
                    cTmp2.Add("", "b")
                Endif

                If cTmp.Exist("angle") Then
                    cTmp2.Add(CFloat(cTmp["angle"]), "a")
                Else
                    cTmp2.Add(0, "a")
                Endif

                If cTmp.Exist("scalex") Then
                    sx = CFloat(cTmp["scalex"])
                Else
                    sx = CFloat(1)
                Endif

                If cTmp.Exist("scaley") Then
                    sy = CFloat(cTmp["scaley"])
                Else
                    sy = CFloat(1)
                Endif

                If cTmp.Exist("scalez") Then
                    sz = CFloat(cTmp["scalex"])
                Else
                    sz = CFloat(1)
                Endif

                cTmp2.Add([sx, sy, sz], "s")

                If cTmp.Exist("columns") Then
                    cTmp2.Add(CInt(cTmp["columns"]), "co")
                Else
                    cTmp2.Add(1, "co")
                Endif

                If cTmp.Exist("rows") Then
                    cTmp2.Add(CInt(cTmp["rows"]), "ro")
                Else
                    cTmp2.Add(1, "ro")
                Endif

                If cTmp.Exist("cspace") Then
                    cTmp2.Add(CFloat(cTmp["cspace"]), "cs")
                Else
                    cTmp2.Add(0, "cs")
                Endif

        End Select

        cTmp2.Add(0, "width")

        Return cTmp2
    Else
        'If cTmp["entity"] = "ELLIPSE" Then
        '    Print "ELLIPSE"
        'Endif
        Return cTmp
    Endif

End

'' In takes all the raw data in a block item from blocks section, listing each
'' entity inside the block but also the block inset
'' This function lists the content of a block, that is, all the entities that
'' compose it including block itself and endblock. Then it creates a collection
'' with all the entities that are not a block or endblock and puts it as one
'' more property of the collection returned by this function that represents th
'' e block.

Private Function DecodeDXFBlock(sItem As String) As Collection

    Dim sCont As String
    Dim btx As String[]
    Dim raw As New Collection       '' List all the entities including the block and endblk at the same level
    Dim out As New Collection       '' List returned by the function that represent the block and its contents
    Dim parts As New Collection     '' List of all entities in the block
    Dim i As Integer
    Dim cTmp As Collection
    Dim cEnty As Collection
    Dim eN As Variant
    Dim rw As Variant
    Dim bl As Variant

    cEnty = GetEntityList()

    sCont = Replace(sItem, "\t", " ")

    For Each eN In cEnty
        sCont = Replace(sCont, "  0\n" & cEnty.Key & "\n  5\n", "\t  0\n" & cEnty.Key & "\n  5\n")
    Next

    btx = Split(sCont, "\t")

    For i = 0 To btx.Max
        If InStr(btx[i], "100\nAcDbEntity") > 0 Then
            cTmp = DecodeDXFEntity(btx[i])

            If cTmp.Count > 0 Then
                If cTmp.Exist("handle") Then
                    raw.Add(cTmp.Copy(), cTmp["handle"])
                    cTmp.Clear
                Endif
            Endif
        Endif
    Next
    ' ok now
    cTmp.Clear
    For Each rw In raw
        Select rw["entity"]
            Case "BLOCK"
                For Each bl In rw
                    out.Add(bl, rw.Key)
                Next

            Case Else

                For Each bl In rw
                    cTmp.Add(bl, rw.Key)
                Next
                parts.Add(cTmp.Copy(), rw["handle"])
                cTmp.Clear

        End Select
    Next

    If parts.Count > 0 Then
        out.Add(parts.Copy(), "Entities")
    Endif

    Return out

End

Private Function DecodeDXFItem(sItem As String) As Collection

    Dim stx As String[]
    Dim cTmp As New Collection
    Dim i As Integer
    Dim vrt As Variant
    Dim sTag As String
    Dim x As Float
    Dim y As Float
    Dim z As Float

    stx = Split(sItem, "\n")

    For i = 0 To stx.Max
        If i = 0 Then
            Select Replace(stx[i + 1], " ", "")
                Case "1", "3"
                    sTag = stx[i]
                    vrt = stx[i + 2]
                    cTmp.Add(vrt, sTag)
                Case "70", "62", "370", "280", "290", "380"
                    sTag = stx[i]
                    vrt = CInt(Replace(stx[i + 2], " ", ""))
                    cTmp.Add(vrt, sTag)
                Case "40", "50"
                    sTag = stx[i]
                    vrt = CFloat(Replace(stx[i + 2], " ", ""))
                    cTmp.Add(vrt, sTag)
                Case "10"
                    sTag = stx[i]
                    x = CFloat(Replace(stx[i + 2], " ", ""))
                    If Replace(stx[i + 3], " ", "") = "20" Then
                        y = CFloat(Replace(stx[i + 4], " ", ""))
                    Endif
                    If Replace(stx[i + 5], " ", "") = "30" Then
                        z = CFloat(Replace(stx[i + 6], " ", ""))
                    Endif
                    cTmp.Add([x, y, z], sTag)
                Case "20", "30"
                    'skip
                Case Else
                    sTag = stx[i]
                    vrt = stx[i + 2]
                    cTmp.Add(vrt, sTag)

                    Select sTag
                        Case "OLESTARTUP"
                            Print sTag & ": " & vrt
                    End Select
            End Select
        Endif
    Next
    Return cTmp

End
