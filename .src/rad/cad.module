' Gambas module file

'''Working with cad files.
' RADG
' Rapid Application Development for Gambas
'
' Copyright (C) Mart√≠n Belmonte
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

Export

'' This function transfers the information housed in the temporary file import collection to the active model, another collection.
Public Function Import(cImp As Collection, cMdl As Collection) As Integer[]

  Dim ix As New Integer[]
  Dim im As Variant

  Dim xFile As Collection
  Dim xTextStyles As Collection
  Dim xVariables As Collection
  Dim xLayers As Collection 'ok
  Dim auxLayer As New Collection
  Dim xBlocks As Collection
  Dim auxBlocks As New Collection
  Dim xLineTypes As Collection
  Dim auxLtypes As New Collection
  Dim xDimStyles As Collection
  Dim xObjects As Collection
  Dim auxWidts As New Collection
  Dim xEntities As Collection
  Dim x As Variant
  Dim p As Variant

  Dim Enty As Variant
  Dim Lay As Variant

  Dim mFile As Collection
  Dim mTextStyles As Collection
  Dim mVariables As Collection
  Dim mLayers As Collection
  Dim mBlocks As Collection
  Dim mLineTypes As Collection
  Dim mDimStyles As Collection
  Dim mObjects As Collection
  Dim mEntities As Collection
  Dim m As Variant
  Dim lx As Variant

  Dim Layexist As Boolean
  Dim nlay As New Collection
  Dim nsty As New Collection
  Dim qlay As Integer               '' Number of layers
  Dim xWidth As Integer
  Dim xStyle As Integer
  Dim xColor As Integer
  Dim xFrozen As Boolean
  Dim n As Variant
  Dim xShow As Boolean
  Dim xLocked As Boolean
  Dim e As Variant
  Dim tEnt As New Collection
  Dim te As New Collection
  Dim cmx As New Collection
  Dim emx As New Collection
  Dim prp As Variant
  Dim tmp As New Collection
  Dim mWidths As Variant
  Dim sTag As String
  Dim i As Integer
  Dim vrt As Variant

  If cImp.Exist("File") Then
    xFile = cImp["File"]
    ix.Add(xFile.Count)
  Else
    ix.Add(0)
  Endif

  If cImp.Exist("Variables") Then
    xVariables = cImp["Variables"]
    ix.Add(xVariables.Count)
  Else
    ix.Add(0)
  Endif

  If cImp.Exist("TextStyles") Then
    xTextStyles = cImp["TextStyles"]
    ix.Add(xTextStyles.Count)
  Else
    ix.Add(0)
  Endif

  If cImp.Exist("Layers") Then
    xLayers = cImp["Layers"]
    ix.Add(xLayers.Count)
    For Each lx In xLayers
      auxLayer.Add(lx["name"], lx["handle"][1])
    Next

  Else
    ix.Add(0)
  Endif

  If cImp.Exist("Blocks") Then
    xBlocks = cImp["Blocks"]
    ix.Add(xBlocks.Count)
    For Each lx In xBlocks
      auxBlocks.Add(lx["name"], lx["handle"][1])
    Next
  Else
    ix.Add(0)
  Endif

  If cImp.Exist("LineTypes") Then
    xLineTypes = cImp["LineTypes"]
    ix.Add(xLineTypes.Count)
    For Each lx In xBlocks
      auxLtypes.Add(lx["name"], lx["handle"][1])
    Next
  Else
    ix.Add(0)
  Endif

  If cImp.Exist("DimStyles") Then
    xDimStyles = cImp["DimStyles"]
    ix.Add(xDimStyles.Count)
  Else
    ix.Add(0)
  Endif

  If cImp.Exist("Objects") Then
    xObjects = cImp["Objects"]
    ix.Add(xObjects.Count)
  Else
    ix.Add(0)
  Endif

  If cImp.Exist("Entities") Then
    xEntities = cImp["Entities"]
    ix.Add(xEntities.Count)
  Else
    ix.Add(0)
  Endif

  '-- DWG -------------------------------------------------------
  If xFile["path"] Like "*.dwg" Or xFile["path"] Like "*.json" Then
    '---------------------------------------------- Variables -----1
    If cMdl.Exist("Variables") = False Then
      cMdl.Add(NewVars(), "Variables")
    Endif
    mVariables = cMdl["Variables"]
    For Each x In xVariables
      mVariables[xVariables.Key] = x
    Next
    '---------------------------------------------- LineStyles ----2
    If cMdl.Exist("LineTypes") = False Then
      cMdl.Add(NewStyles(), "LineTypes")
    Endif

    '---------------------------------------------- Layers --------3
    If cMdl.Exist("Layers") = False Then
      qlay = 0
      nlay = ["id": 0, "object": "LAYER", "name": "0", "show": True, "frozen": False, "locked": False, "color": 7, "ltype": 1, "linewt": 17, "print": True, "handle": 1, "ownerhandle": 2, "is_xref_dep": False]
      cMdl.Add([nlay.Copy(), "0"], "Layers")
      Inc qlay
      nlay.Clear
    Else
      mLayers = cMdl["Layers"]
      qlay = mLayers.Count
    Endif

    For Each x In xLayers
      xShow = True
      xColor = 0
      If TypeOf(x["color"]) = gb.Object Then
        If x["color"] Is Collection Or x["color"] Is JSONCollection Then
          If x["color"].Exist("index") Then
            xColor = x["color"]["index"] ' Simple color 1-256
          Endif
        Else
          xColor = 7
        Endif
      Else
        xColor = x["color"]
      Endif
      If xColor < 0 Then
        xShow = False
      Endif
      xColor = Abs(xColor)
      '------------------------------------
      If DWGFlag(x["flag"], 1) = 0 Then
        xFrozen = False
      Else
        xFrozen = True
      Endif

      If DWGFlag(x["flag"], 4) = 0 Then
        xLocked = False
      Else
        xLocked = True
      Endif
    Next

    nlay.Clear
    xStyle = 1 'x["ltype"]

    nlay["object"] = "LAYER"
    nlay["name"] = x["name"]
    nlay["show"] = xShow
    nlay["frozen"] = xFrozen
    nlay["locked"] = xLocked
    nlay["color"] = xColor
    nlay["ltype"] = 1
    nlay["linewt"] = x["linewt"]
    nlay["print"] = True
    nlay["handle"] = x["handle"][1]
    nlay["ownerhandle"] = x["ownerhandle"][1]
    nlay["is_xref_dep"] = False

    Layexist = False
    For Each m In mLayers
      If m["name"] = x["name"] Then
        Layexist = True
        For Each n In nlay
          m[nlay.Key] = n
        Next
        Break
      Endif
    Next
    If Layexist = False Then
      nlay["id"] = qlay + 1
      mLayers.Add(nlay.Copy(), CStr(nlay["id"]))
    Endif
    '---------------------------------------------- TextStyles ----4
    If cMdl.Exist("TextStyles") = False Then
      nsty["id"] = "0"
      nsty["object"] = "STYLE"
      nsty["name"] = "Standard"
      nsty["fixed"] = 0
      nsty["size"] = 0
      nsty["wfactor"] = 0.9
      nsty["oblique"] = 0
      nsty["last"] = 100
      nsty["font"] = "txt"
      nsty["handle"] = 4
      cMdl.Add(["0": nsty.Copy()], "TextStyles")
    Endif
    mTextStyles = cMdl["TextStyles"]

    For Each x In xTextStyles
      If TypeOf(x) = gb.Object Then
        For Each m In mTextStyles
          If Lower(m["name"]) = Lower(x["name"]) Then
            m["fixed"] = x["fixed"]
            m["size"] = x["text_size"]
            m["wfactor"] = x["width_factor"]
            m["oblique"] = x["oblique_angle"]
            m["last"] = x["last_height"]
            m["font"] = x["font_file"]
            m["handle"] = x["handle"][1]
          Endif
        Next
      Endif
    Next
    '---------------------------------------------- Auxiliars ----#
    If cMdl.Exist("Widths") = False Then
      cMdl["Widths"] = cad.NewWidths()
    Endif
    mWidths = cMdl["Widths"]
    For Each lx In mWidths
      auxWidts.Add(lx, mWidths.Key)
    Next
    '---------------------------------------------- Entities -----5
    cmx = DWGCommonTags()
    mEntities = cMdl["Entities"]
    For Each e In xEntities
      te.Clear
      '----------------Common Proprties
      For Each prp In e
        If cmx.Exist(e.Key) Then
          'If cmx.Exist(e.Key) Then
          sTag = cmx[e.Key]
          vrt = prp
          'Else
          '  sTag = e.Key
          'Endif

          If TypeOf(prp) = gb.Object Then
            Select e.Key
              Case "handle"
                vrt = prp[1]
              Case "ltype"
                If auxLtypes.Exist(CStr(prp[2])) Then
                  vrt = auxLtypes[CStr(prp[2])]
                Else
                  vrt = "Continous"
                Endif

              Case "layer"
                If auxLayer.Exist(CStr(prp[2])) Then
                  vrt = auxLayer[CStr(prp[2])]
                Else
                  vrt = "0"
                Endif
              Case "color"
                If prp.Exist("index") Then
                  vrt = prp["index"]
                Else
                  vrt = 7
                Endif

            End Select
          Else
            Select e.Key
              Case "linewt"
                If auxWidts.Exist(prp) Then
                  'vrt = auxWidts[prp][0]
                  vrt = prp
                Else
                  vrt = 31
                  'vrt = "Default"
                Endif
            End Select
          Endif
          te.Add(vrt, sTag)
        Endif
        '---------------- Special Proprties
        Select e["entity"]
          Case "LINE"
            te["p"] = [e["start"]]
            te["p"].Add(e["end"])

          Case "LWPOLYLINE"
            'If DWGFlag(e["flag"], 1) = 0 Then
            Select e["flag"]
              Case 512, 1
                te["closed"] = 1
              Case Else
                te["closed"] = 0
            End Select
            te["p"] = e["points"]

          Case "SPLINE"
            te["scenario"] = e["scenario"]
              te["degree"] = e["degre"]
            te["p"] = e["fit_pts"]

        Case "ARC"
          te["p"] = [e["center"]]
            te["radius"] = e["radius"]
            te["start_angle"] = e["start_angle"]
            te["end_angle"] = e["end_angle"]

          Case "CIRCLE"
            te["p"] = [e["center"]]
            te["radius"] = e["radius"]

          Case "ELLIPSE"
            te["p"] = [e["center"]]
            te["p"].Add(e["sm_axis"])
            te["ratio"] = e["axis_ratio"]
            te["start_angle"] = e["start_angle"]
            te["end_angle"] = e["end_angle"]

          Case "TEXT"
            te["p"] = [e["ins_pt"]]
            te["angle"] = ATan2(e["extrusion"][0], e["extrusion"][1])
            te["text"] = e["text_value"]
            te["text_height"] = e["height"]

          Case "MTEXT"
            te["p"] = [e["ins_pt"]]
            te["angle"] = e["rotation"]
            te["text"] = e["text"]
            te["text_height"] = e["text_height"]
            te["attachment"] = e["attachment"]
            te["flow_dir"] = e["flow_dir"]

          Case "INSERT"
            te["p"] = [e["ins_pt"]]
            te["angle"] = e["rotation"]
            te["scalex"] = e["scale"][0]
            te["scaley"] = e["scale"][1]
            te["scalez"] = e["scale"][2]
            te["block"] = auxBlocks[e["block_header"][2]]

          Case "SOLID"
            te["p"] = [e["corner1"]]
            te["p"].Add(e["corner2"])
            te["p"].Add(e["corner3"])
            te["p"].Add(e["corner4"])

        End Select

      Next

      '---------------- Transfer

      ' -- Some Checks before
      If te.Exist("ltype") = False Then
        te.Add("Continous", "ltype")
      Endif

      If te.Exist("color") = False Then
        te.Add(7, "color")
      Endif

      If cMdl.Exist("Entities") = False Then
        cMdl.Add([e["entity"]: [CStr(te["handle"]): te.Copy()]], "Entities")
        te.Clear
      Else
        If cMdl["Entities"].Exist(e["entity"]) = False Then
          cMdl["Entities"].Add([CStr(te["handle"]): te.Copy()], e["entity"])
          te.Clear
        Else
          cMdl["Entities"][e["entity"]].Add(te.Copy(), CStr(te["handle"]))
          te.Clear
        Endif
      Endif
    Next
    '-- DXF -------------------------------------------------------
  Else
    If xFile["path"] Like "*.dxf" Then
      Print "dxf"
    Else
      Print "other"
    Endif
  Endif

  Return ix

End

Public Function DWGFlag(iFlag As Integer, iPos As Integer) As Byte

  Dim t As String
  Dim b As Byte

  t = Bin(iFlag, 8)
  b = CByte(Mid(t, 9 - iPos, 1))

  Return b

End

Public Function DWGCommonTags(Optional sEntity As String) As Collection

  Dim comm As New Collection

  Select Upper(sEntity)
    Case "", "COMMON"
      comm.Add("entity", "entity")
      comm.Add("index", "index")
      comm.Add("type", "type")
      comm.Add("handle", "handle")
      comm.Add("layer", "layer")
      comm.Add("color", "color")
      comm.Add("entmode", "entmode")
      comm.Add("ownerhandle", "ownerhandle")
      comm.Add("invisible", "invisible")
      comm.Add("linewt", "linewt") '#
      comm.Add("material", "material")
      comm.Add("ltype", "ltype")
      comm.Add("ltscale", "ltype_scale")
      comm.Add("plotstyle", "plotstyle")

    Case "LINE"
      comm.Add("start", "start")
      comm.Add("end", "end")

  End Select

  Return comm

End

'' This load all the info form a gaucho xml file, then put it in a collection a
'' nd return it.

Public Function GauchoSave(sFile As String, cMdl As Collection)

  Dim writer As New XmlWriter
  Dim var As Variant
  Dim att As Variant
  Dim v As Variant
  Dim ety As Variant
  Dim p As Variant
  Dim ptx As New String[]
  Dim sErr As String
  Dim sEfl As String
  Dim stx As New String[]
  Dim atr As New Collection
  Dim a As String

  stx = ["entity", "handle", "layer", "style", "linewt", "color", "p", "radius", "ratio", "start_angle", "end_angle", "angle", "scale", "block", "text", "height", "font", "oblique", "just_h", "just_v", "wfactor", "paper", "blkid"]

  sErr = ""
  sEfl = User.Home &/ "err.txt"
  If Exist(sEfl) Then
    Kill sEfl
  Endif

  writer.Open(sFile, True)                'True es para que le ponga los saltos de linea
  writer.Comment(Application.Title & " v" & Application.Version)
  writer.StartElement("svg")             ' Compatibility with SVG
  writer.StartElement("metadata")        ' Compatibility with SVG
  writer.Attribute("id", "metadata5")
  writer.StartElement("dc:format")
  writer.Text("image/svg+xml")
  writer.EndElement
  writer.EndElement

  For Each var In cMdl
    Select cMdl.Key
      Case "Layers", "Colors", "LineTypes", "Weights", "DimStyles", "TextStyles"
        For Each att In var
          writer.StartElement("header")
          For Each v In att
            writer.Attribute(att.Key, v)
          Next
          writer.EndElement
        Next

      Case "Entities"
        For Each ety In var
          For Each att In ety
            writer.StartElement("entity")
            For Each v In att
              If stx.Exist(att.Key) Then

                Select TypeOf(v)

                  Case gb.Null
                    atr.Add(v, att.Key)
                  Case gb.Boolean
                    atr.Add(v, att.Key)
                  Case gb.Byte, gb.Short, gb.Integer, gb.Long, gb.Single
                    atr.Add(v, att.Key)
                  Case gb.Float
                    atr.Add(v, att.Key)
                  Case gb.Date
                    atr.Add(Format(v, "yyyymmddhhnnss"), att.Key)
                  Case gb.String
                    atr.Add(v, att.Key)
                  Case gb.Variant
                    atr.Add(v, att.Key)
                  Case gb.Object
                    Select Object.Type(v)
                      Case "Collection"
                        For Each p In v
                          ptx.Add(p[0] & ":" & p[1])
                        Next
                        Select ptx.Count
                          Case 0
                            atr.Add("", att.Key)
                          Case 1
                            atr.Add(ptx[0], att.Key)
                            ptx.Clear

                          Case Else
                            atr.Add(ptx.Join(";"), att.Key)
                            ptx.Clear

                        End Select

                      Case "FLoat[]"
                        For Each p In v
                          ptx.Add(p)
                        Next
                        Select ptx.Count
                          Case 0
                            atr.Add("", att.Key)
                          Case 1
                            atr.Add(ptx[0], att.Key)
                            ptx.Clear

                          Case Else
                            atr.Add(ptx.Join(":"), att.Key)
                            ptx.Clear

                        End Select

                    End Select

                End Select

                For Each a In stx
                  If atr.Exist(a) Then
                    writer.Attribute(a, atr[a])
                  Endif
                Next
              Else
              Endif
              atr.Clear
            Next
            writer.EndElement
          Next
        Next
    End Select
  Next
  If sErr <> "" Then
    File.Save(sEfl, sErr)
    If Exist(sEfl) Then
      Desktop.Open(sEfl)
    Endif

  Endif
  writer.EndElement ' svg
  writer.EndDocument

End

'' This load all the info form a gaucho xml file, then put it in a collection a
'' nd return it.

Public Function GauchoLoad(sFile As String) As Collection

  Dim c As New Collection
  Dim cLayers As New Collection
  Dim cStyles As New Collection
  Dim cWidths As New Collection
  Dim cDimStyles As New Collection
  Dim cFonts As New Collection
  Dim cVars As New Collection
  Dim cEntities As New Collection
  Dim cMdl As New Collection
  Dim hxml As New XmlDocument
  Dim ent As XmlElement
  Dim i As Integer
  Dim sKey As String
  Dim cSout As New Collection

  hxml.Open(sFile)

  cMdl.Add(sFile, "File")

  cMdl = Skeleton()

  For Each ent In hxml.GetElementsByTagName("header")
    Select ent.Attributes["type"]
      Case "version"
        cMdl.Add(ent.Attributes["name"], "Version")

      Case "layer"
        c.Clear
        c["id"] = ent.Attributes["id"]
        c["object"] = ent.Attributes["type"]
        c["name"] = ent.Attributes["name"]
        c["show"] = CBool(ent.Attributes["show"])
        c["frozen"] = CBool(ent.Attributes["frozen"])
        c["locked"] = CBool(ent.Attributes["locked"])
        c["colour"] = CInt(ent.Attributes["colour"])
        c["style"] = CInt(ent.Attributes["style"])
        c["linewt"] = CInt(ent.Attributes["linewt"])
        c["print"] = CBool(ent.Attributes["print"])
        cLayers.Add(c.Copy(), ent.Attributes["id"])

      Case "style"
        c.Clear
        c["id"] = ent.Attributes["id"]
        c["object"] = ent.Attributes["type"]
        c["name"] = ent.Attributes["name"]
        cStyles.Add(c.Copy(), ent.Attributes["id"])

      Case "linewt"
        c.Clear
        c["id"] = ent.Attributes["id"]
        c["object"] = ent.Attributes["type"]
        c["value"] = ent.Attributes["value"]
        cWidths.Add(c.Copy(), ent.Attributes["id"])

      Case "dimst"
        c.Clear
        c["id"] = ent.Attributes["id"]
        c["object"] = ent.Attributes["type"]
        c["name"] = ent.Attributes["name"]
        cDimStyles.Add(c.Copy(), ent.Attributes["id"])

      Case "font"
        c.Clear
        c["id"] = ent.Attributes["id"]
        c["object"] = ent.Attributes["type"]
        c["name"] = ent.Attributes["name"]
        cFonts.Add(c.Copy(), ent.Attributes["id"])

      Case "Variables"
        cVars.Add(ent.Attributes["value"], ent.Attributes["name"])

    End Select
  Next

  cMdl.Add(cLayers, "Layers")
  cMdl.Add(cStyles, "LineTypes")
  cMdl.Add(cWidths, "Widths")
  cMdl.Add(cDimStyles, "DimStyles")
  cMdl.Add(cFonts, "TextStyles")
  'Flags / Variables
  cMdl.Add(cVars, "Variables")

  ''TODO: poner las entidade en el cModel
  For Each ent In hxml.GetElementsByTagName("entity")
    c.Clear
    'Commons fields

    sKey = CStr(i) 'sog.UUIDHandle(6)
    c["id"] = sKey
    '-----
    If ent.Attributes["handle"] Then
      c["handle"] = ent.Attributes["handle"]
    Else
      c["handle"] = sog.UUIDHandle(6)
    Endif
    '-----
    c["entity"] = ent.Attributes["entity"]
    '-----
    c["layer"] = ent.Attributes["layer"]
    c["style"] = ent.Attributes["style"]
    c["linewt"] = ent.Attributes["linewt"]
    c["colour"] = ent.Attributes["colour"]
    '-----

    ' aca hay un problema: si gcad guarda los puntos p0="1:2"  p1="1:1" etc, entoces cModel queda igual que como cuando lees cImport
    ' pero si los guardas seguido, no podes usar la rutina gcd.ImportEntities pq vienen distinto

    ' una solucion es cuando importas DXF guardas todos los p seguidos o en gaucho los guardas separados , lo que para polilineas largas no se que comportamiento tendra
    ' https://stackoverflow.com/questions/56035887/what-is-the-one-line-max-length-limit-in-xml-files
    Select ent.Attributes["entity"]

      Case "line", "polyline", "lwpolyline"
        c["p"] = GauchoEncodePoint(ent.Attributes["p"], "p")

      Case "circle"
        c["p"] = GauchoEncodePoint(ent.Attributes["p"], "p")
        c["radius"] = vag.CFloat(ent.Attributes["radius"]) 'EncodePoint(ent.Attributes["r"], "r")

      Case "ellipse"
        c["p"] = GauchoEncodePoint(ent.Attributes["p"], "p")
        c["ratio"] = vag.CFloat(ent.Attributes["ratio"]) 'EncodePoint(ent.Attributes["r"], "r")
        ' estos angulos vienen en radianes
        c["start_angle"] = vag.CFloat(ent.Attributes["start_angle"]) 'FloatList(ent.Attributes["a"]) 'EncodePoint(ent.Attributes["a"], "a")
        c["end_angle"] = vag.CFloat(ent.Attributes["end_angle"]) 'FloatList(ent.Attributes["a"]) 'EncodePoint(ent.Attributes["a"], "a")
        'Print "x"

      Case "arc"
        c["p"] = GauchoEncodePoint(ent.Attributes["p"], "p")
        c["radius"] = vag.CFloat(ent.Attributes["radius"]) 'EncodePoint(ent.Attributes["r"], "r")
        ' estos angulos vienen en GRADOS
        c["start_angle"] = vag.CFloat(ent.Attributes["start_angle"]) 'FloatList(ent.Attributes["a"]) 'EncodePoint(ent.Attributes["a"], "a")
        c["end_angle"] = vag.CFloat(ent.Attributes["end_angle"]) 'FloatList(ent.Attributes["a"]) 'EncodePoint(ent.Attributes["a"], "a")

      Case "text"
        c["p"] = GauchoEncodePoint(ent.Attributes["p"], "p")
        c["angle"] = vag.CFloat(ent.Attributes["angle"])        ' grados
        c["text"] = ent.Attributes["text"]
        c["height"] = ent.Attributes["height"]
        c["font"] = ent.Attributes["font"]

      Case "insert"
        c["p"] = GauchoEncodePoint(ent.Attributes["p"], "p")
        c["angle"] = vag.CFloat(ent.Attributes["angle"])            ' grados
        c["scale"] = GauchoFloatList(ent.Attributes["scale"])
        c["block"] = ent.Attributes["block"]

    End Select

    CheckModel()

    If c.Count > 0 Then
      cEntities.Add(c.Copy(), sKey)
      cSout = GauchoEntitiesSort(cEntities)
    Endif
    Inc i
  Next

  cMdl.Add(cSout, "Entities")

  Return cMdl

End

'' This give the skeleton of a gaucho file as collection, a model collection including each section

Public Function Skeleton() As Collection

  Dim cMdl As New Collection

  ''
  cMdl.Add(NewLayer(), "Layers")
  cMdl.Add(NewVars(), "Variables")
  cMdl.Add(NewStyles(), "LineTypes")

  Return cMdl

End

Public Function CheckModel(cM As Collection) As Collection

  If cM.Exist("Variables") = False Then
    cM.Add(NewVars(), "Variables")
  Endif

  Return cM

End

'' This give the layer 0 and its information

Public Function NewLayer() As Collection

  Dim c As New Collection
  Dim cLy As New Collection

  c.Clear
  c["id"] = "0"
  c["object"] = "LAYER"
  c["name"] = "0"
  c["show"] = True
  c["frozen"] = False
  c["locked"] = False
  c["colour"] = 0
  c["style"] = 0
  c["linewt"] = 0
  c["print"] = True
  cLy.Add(c.Copy(), "0")
  c.Clear

  Return cLy

End

Public Function NewVars() As Collection

  Dim c As New Collection

  c.Add(1, "LTSCALE")
  c.Add(0, "ATTMODE")
  c.Add(200, "TEXTSIZE")
  c.Add("Standard", "TEXTSTYLE")
  c.Add("0", "CLAYER")
  c.Add("ByLayer", "CELTYPE")
  c.Add(0, "CECOLOR")
  c.Add(1, "CELTSCALE")
  c.Add(1, "CELWEIGHT")
  c.Add("Standard", "DIMSTYLE")
  c.Add(4, "AUNITS")
  c.Add(10, "CHAMFERA")
  c.Add(10, "CHAMFERB")
  c.Add(0.0, "ANGBASE")
  c.Add("Standard", "CMLSTYLE")
  c.Add(4, "INSUNITS")

  Return c

End

Public Function NewStyles() As Collection

  Dim c As New Collection

  c.Add([[3], &X00000000000000001111111111111111, "Continous"], "0")
  c.Add([[14, 4, 4, 4], &X00000000000000001111111111111111, "Center"], "1") ' the second parameter here is fake
  c.Add([[10, 6, 3, 6], &X00000000000000000001100011111111, "Dashdot"], "2")
  c.Add([[10, 6], &X00000000000000000000111100001111, "Dashed"], "3")
  c.Add([[6, 4, 3, 4, 3, 4], &X00000000000000000011001100111111, "Divide"], "4")
  c.Add([[3, 4], &X00000000000000000001000100010001, "Dot"], "5")
  c.Add([[6, 4], &X00000000000000001111111111111111, "Hidden"], "6") ' the second parameter here is fake
  c.Add([[4, 3], &X00000000000000001111111111111111, "Hidden2"], "7") ' the second parameter here is fake
  c.Add([[12, 4, 4, 4, 4, 4], &X00000000000000001111111111111111, "Phantom"], "8") ' the second parameter here is fake
  c.Add([[3], &X00000000000000001111111111111111, "ByBLock"], "9")
  c.Add([[3], &X00000000000000001111111111111111, "ByLayer"], "10")

  Return c

End

Public Function NewWidths() As Collection

  Dim c As New Collection

  'c.Add(["0.25", 1], "1") '1
  'c.Add(["0.50", 2], "2") '2
  'c.Add(["0.75", 3], "3") '3
  'c.Add(["1.00", 4], "4") '4
  'c.Add(["1.25", 5], "5") '5
  'c.Add(["1.50", 6], "6") '6
  'c.Add(["1.75", 7], "7") '7
  'c.Add(["2.00", 8], "8") '8

  c.Add(["0.05", "1"], "1")
  c.Add(["0.10", "2"], "2")
  c.Add(["0.12", "3"], "3")
  c.Add(["0.14", "4"], "4")
  c.Add(["0.16", "5"], "5")
  c.Add(["0,18", "6"], "6")
  c.Add(["0.20", "7"], "7")
  c.Add(["0.25", "8"], "8")
  c.Add(["0.30", "9"], "9")
  c.Add(["0.35", "10"], "10")
  c.Add(["0.40", "11"], "11")
  c.Add(["0.45", "12"], "12")
  c.Add(["0.50", "13"], "13")
  c.Add(["0.55", "14"], "14")
  c.Add(["0.60", "15"], "15")
  c.Add(["0.65", "16"], "16")
  c.Add(["0.70", "17"], "17")
  c.Add(["0.80", "18"], "18")
  c.Add(["0.90", "19"], "19")
  c.Add(["1.00", "20"], "20")
  c.Add(["1.25", "21"], "21")
  c.Add(["1.45", "22"], "22")
  c.Add(["1.65", "23"], "23")
  c.Add(["1.85", "24"], "24")
  c.Add(["2.00", "25"], "25")
  c.Add(["2.15", "26"], "26")

  c.Add(["ByLayer", "29"], "29")
  c.Add(["ByBlock", "30"], "30")
  c.Add(["Default", "31"], "31")

  Return c

End

'' Creates a list of floating point numbers from a colon-delimited text string

Private Function GauchoFloatList(sList As String) As Float[]

  Dim stx As New String[]
  Dim flx As New Float[]
  Dim n As String

  If InStr(sList, ":") > 0 Then
    stx = Split(sList, ":")
    If stx.Count > 0 Then
      For Each n In stx
        flx.Add(CFloat(n))
      Next
    Endif
  Endif

  Return flx

End

'' This function encode a float list like a point angles etc. from a string in
'' delimiter char for dimansions is : the for delimitatiosn of groups we use ;

Private Function GauchoEncodePoint(sPoint As String, sTag As String) As Collection

  Dim cp As New Collection
  Dim fp As New Float[]
  Dim stx As New String[]
  Dim sp As String
  Dim i As Integer

  If InStr(sPoint, ";") > 0 Then
    ' Single point ie.lines
    stx = Split(sPoint, ";")
  Else
    'Multipoint, ie.Polylines
    stx.Add(sPoint)
  Endif

  For Each sp In stx
    If InStr(sPoint, ":") > 0 Then
      fp = Split(sp, ":")
      If fp.Count = 2 Then
        fp.Add(0)
      Endif
    Else
      fp.Add(sp)
    Endif
    cp.Add(fp.Copy(), sTag & CStr(i))
    fp.Clear
    Inc i
  Next

  Return cp

End

'' Export the information in cModel collection to an SVG file.

Public Function GauchoExportSVG(model As Collection) As String

  Dim ent As Variant
  Dim xsvg As New XmlDocument
  Dim sFileSVG As String
  Dim sFile As String
  Dim sVersion As String

  sFile = model["File"]
  sVersion = model["Version"]

  sFileSVG = File.Dir(sFile) &/ File.Name(sFile) & ".svg"

  xsvg.Open(sFileSVG)

  For Each ent In model
    Select ent["Name"]
      Case "LINE"

    End Select

  Next

End

'' Import a DXF file into cModel collection.

Public Function DXFImport(sFile As String) As Collection

  Dim sec As New Collection 'String[]

  sec = DXFSections(sFile)

  Return sec

End

'' Import a DWG file into cModel collection.

Public Function DWGImport(sFile As String) As Collection

  Dim sCont As String
  Dim cont As Collection
  Dim FileVersion As String       ''2004, 14, 2007 ...
  Dim vent As Collection
  Dim model As New Collection       ''Complete model
  Dim layers As Collection
  Dim AcHeader As Collection

  layers = DWGLayersList(sFile)

  vent = DWGEntityList()

  sCont = dwgread(sFile)

  If sCont <> "" Then
    FileVersion = Split(sCont, "\n")[1]
    FileVersion = Replace(FileVersion, " ", "")
    FileVersion = Replace(FileVersion, "(", ":")
    FileVersion = Split(FileVersion, ":")[1]

    cont = DWGSections(sCont, FileVersion)

    model.Add(sFile, "File")
    model.Add(FileVersion, "Version")
    model.Add(layers, "Layers")

    If cont.Exist("Header") Then
      AcHeader = DWGHeader(cont["Header"])
      If AcHeader.Count > 0 Then
        model.Add(AcHeader, "Header")
      Endif
    Endif

    If model.Exist("Entities") = False Then
      If cont.Exist("Entities") Then
        model.Add(cont["Entities"], "Entities")
      Endif
    Endif
  Endif
  Return model

End

'' Get the DWG file layers list.

Public Function DWGLayersList(sFile As String) As Collection

  Dim layers As New Collection
  Dim sOut As String
  Dim stx As String[]
  Dim slay As String
  Dim lay As New Collection

  If Exist(sFile) Then
    Shell "/usr/local/bin/dwglayers -f '" & sFile & "' 2>&1 " To sOut
  Endif

  If sOut <> "" Then
    stx = Split(sOut, "\n")
    For Each slay In stx
      If InStr(slay, "\t") > 0 Then

        If String.Mid(slay, 1, 1) = "font" Then
          lay.Add(True, "Frozen")
        Else
          lay.Add(False, "Frozen")
        Endif
        If String.Mid(slay, 2, 1) = "+" Then
          lay.Add(True, "On")
        Else
          lay.Add(False, "On")
        Endif
        If String.Mid(slay, 3, 1) = "l" Then
          lay.Add(True, "Locked")
        Else
          lay.Add(False, "Locked")
        Endif

        lay.Add(Split(slay, "\t")[1], "Name")

      Endif
      layers.Add(lay.Copy(), lay["Name"])
    Next
  Endif

  Return layers

End

'' Create the stanard entities list.

Public Function DWGEntityList() As Collection

  Dim entity As New Collection

  entity.Add(False, "3DFACE")
  entity.Add(False, "3DSOLID")
  entity.Add(False, "ACAD_PROXY_ENTITY")
  entity.Add(True, "ARC") 'ok
  entity.Add(True, "ATTDEF") 'ok
  entity.Add(True, "ATTRIB") 'ok
  entity.Add(False, "BODY")
  entity.Add(True, "CIRCLE") 'ok
  entity.Add(False, "DIMENSION")
  entity.Add(True, "ELLIPSE") 'ok
  entity.Add(False, "ENDBLK") ' solo de referencia
  entity.Add(True, "HATCH")
  entity.Add(False, "HELIX")
  entity.Add(False, "IMAGE")
  entity.Add(True, "INSERT") 'ok
  entity.Add(False, "LEADER")
  entity.Add(False, "LIGHT")
  entity.Add(True, "LINE") 'ok
  entity.Add(True, "LWPOLYLINE") 'ok
  entity.Add(False, "MLINE") 'very complex, to do later
  entity.Add(False, "MULTILEADER")
  entity.Add(False, "MLEADERSTYLE")
  entity.Add(True, "MTEXT") 'ok
  entity.Add(False, "OLEFRAME")
  entity.Add(False, "OLE2FRAME")
  entity.Add(True, "POINT") 'ok
  entity.Add(False, "POLYLINE") 'not yey
  entity.Add(False, "RAY")
  entity.Add(False, "REGION")
  entity.Add(False, "SECTION")
  entity.Add(False, "SEQEND")
  entity.Add(False, "SHAPE")
  entity.Add(False, "SOLID")
  entity.Add(False, "SPLINE")
  entity.Add(False, "SUN")
  entity.Add(False, "SURFACE")
  entity.Add(False, "TABLE")
  entity.Add(True, "TEXT") 'ok
  entity.Add(False, "TOLERANCE")
  entity.Add(False, "TRACE")
  entity.Add(False, "UNDERLAY")
  entity.Add(False, "VERTEX")
  entity.Add(False, "VIEWPORT")
  entity.Add(False, "WIPEOUT")
  entity.Add(False, "XLINE")

  Return entity

End

'dwg2dxf
'dwg2svg
'dwgdump
'dwgfilter
'dwggrep
'dwglayers
'dwgread *
'dwgwrite
'dxf2dwg
'dxfwrite

'' Read a DWG file using the dwgread utility from libreDWG library.

Public Function DWGRead(f As String, Optional fmt As String) As String

  Dim sOut As String

  If Exist(f) Then
    Select fmt
      Case ""
        Shell "/usr/local/bin/dwgread -v4 '" & f & "' 2>&1 " To sOut
      Case "json"
        Shell "/usr/local/bin/dwgread -v4 --format JSON '" & f & "' 2>&1 " To sOut
    End Select

  Endif

  Return sOut

End

'' Create a list of DWG sections using the previously extracted text with the dwgread function.

Public Function DWGSections(s As String, vsn As String) As Collection

  Dim sWrd As String
  Dim cont As New Collection
  Dim sec As New String[]
  Dim sn As String
  Dim sName As String
  Dim sHead As String
  Dim contx As String[]
  Dim tmx As New String[]
  Dim tm As String
  Dim sCont As Variant
  Dim cCont As Collection
  Dim out As New Collection

  Select vsn

    Case "AC1015" '"DWG2000"
      sWrd = "=======> "
      s = Replace(s, "\t", " ")
      s = Replace(s, sWrd, "\t")
      sec = Split(s, "\t")

      tmx = ["AuxHeader", "Thumbnail", "Header Variables", "CLASS", "Handles", "Last Object", "Second Header", "MEASUREMENT"]

      For Each sn In sec
        If InStr(sn, "\n") > 0 Then
          contx = Split(sn, "\n")
          sHead = contx[0]
          sName = ""
          For Each tm In tmx
            If InStr(sHead, tm) > 0 Then
              sName = tm
              Break
            Endif
          Next
          If sName <> "" Then
            sName = Replace(sName, "AcDb:", "")
            If sName = "Header Variables" Then
              sName = "Header"
            Endif

            If sName = "Handles" Then
              sn = Replace(sn, "==========================================\n", "\t")
            Endif
            cont.Add(sn, sName)
          Endif
        Endif
      Next

    Case "AC1018", "AC1024", "AC1027"
      sWrd = "Found section_info["
      s = Replace(s, "\t", " ")
      s = Replace(s, sWrd, "\t")
      sec = Split(s, "\t")

      For Each sn In sec
        If InStr(sn, "\n") > 0 Then
          contx = Split(sn, "\n")
          sHead = contx[0]
          If InStr(sHead, "] AcDb:") > 0 Then
            sName = Split(sHead, " ")[1]
            sName = Replace(sName, "AcDb:", "")
            cont.Add(sWrd & sn, sName)
            '==========================================
          Endif
        Endif
      Next

    Case "AC1021"

      s = Replace(s, "\t", " ")

      tmx = ["AppInfoHistory", "AppInfo", "Preview", "SummaryInfo", "RevHistory", "AcDbObjects", "ObjFreeSpace", "Template", "Handles", "Classes", "AuxHeader", "Header"]

      For Each tm In tmx
        Select tm
          Case "AppInfoHistory", "AppInfo", "Preview", "SummaryInfo", "RevHistory", "ObjFreeSpace", "Template"
            s = Replace(s, tm & " (", "\t" & tm & " (")

          Case "AcDbObjects", "Handles", "Classes", "AuxHeader", "Header"
            s = Replace(s, tm & "\n-------------------", "\t" & tm & "\n-------------------")

        End Select
      Next

      sec = Split(s, "\t")

      For Each sn In sec
        If InStr(sn, "\n") > 0 Then
          contx = Split(sn, "\n")
          sHead = contx[0]
          sName = ""
          For Each tm In tmx
            If InStr(sHead, tm) > 0 Then
              sName = tm
              Break
            Endif
          Next
          If sName <> "" Then
            cont.Add(sn, "AcDb:" & sName)
          Endif
        Endif
      Next

  End Select

  '' Arranging the data to standarize like DXF collection
  For Each sCont In cont
    Select cont.Key
      Case "Handles" 'Entities en DXF
        cCont = DWGEntities(sCont)
        out.Add(cCont, "Entities")
    End Select
  Next

  Return out

End

'' Create a list of DWG entities using the previously extracted text with the dwgread function

Public Function DWGEntities(s As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim obt As String
  Dim obx As New String[]
  Dim tmx As New Collection
  Dim j As Integer
  Dim hdx As New String[]
  Dim sTag As String
  Dim sVal As String
  Dim vVal As Variant
  Dim out As New Collection

  Dim sRaw As String
  Dim t As String
  Dim otx As New String[]
  Dim enty As Collection
  Dim alias As Collection
  Dim sAlias As Variant
  Dim r As Variant
  Dim sOut As String
  Dim arr As New Collection
  Dim sKey As String
  Dim out2 As Collection

  enty = DWGEntityList()
  alias = DWGAlias()

  s = Replace(s, "==========================================\n", "\t")
  stx = Split(s, "\t")

  If stx.count > 0 Then
    For i = 1 To stx.Max
      tmx.Clear
      obt = stx[i]
      obx.Clear
      obx = Split(obt, "\n")

      If obx.Count > 1 Then
        If InStr(obx[1], " Decode entity ") > 0 Then
          hdx.Clear
          hdx = Split(Replace(obx[1], " Decode entity ", "\t"), "\t")
          vVal = hdx[hdx.Max]
          tmx.Add(vVal, "entity")
          File.Save("/tmp" &/ vVal & ".txt", obt)

          If enty.Exist(hdx[hdx.Max]) Then
            If enty[hdx[hdx.Max]] Then
              Print "Acepted: " & hdx[hdx.Max]
              File.Save("/tmp" &/ Format(i, "0000") & ".txt", obt)

              otx = Split(Replace(obx[0], ", ", "\t"), "\t")

              For Each t In otx
                sRaw = Replace(t, ": ", ":")
                sTag = String.Lower(Split(sRaw, ":")[0])
                sTag = Replace(sTag, " ", "")
                sVal = Replace(sRaw, Split(sRaw, ":")[0] & ":", "")
                vVal = DWGDecodeItem([sTag, sVal])
                If tmx.Exist(sTag) = False Then
                  If sTag = "objectnumber" Then
                    If InStr(sVal, "/") > 0 Then
                      tmx.Add(CStr(Split(sVal, "/")[0]), "id") 'Long
                    Endif
                  Else
                    tmx.Add(vVal, sTag)
                  Endif
                Endif
              Next

              For j = 2 To obx.Max

                If InStr(obx[j], ":") > 0 Then
                  sRaw = Replace(obx[j], ": ", ":")
                  sTag = String.Lower(Split(sRaw, ":")[0])
                  sTag = Replace(sTag, " ", "")
                  If alias.Exist(sTag) Then
                    sAlias = alias[sTag]
                  Else
                    sAlias = sTag
                  Endif

                  sVal = Replace(sRaw, Split(sRaw, ":")[0] & ":", "")

                  vVal = DWGDecodeItem([sTag, sVal])
                  If tmx.Exist(sTag) = False Then
                    tmx.Add(vVal, sAlias)
                  Else
                    tmx.Add(vVal, sAlias & "[" & CStr(j) & "]")
                  Endif
                Else
                Endif
              Next
              If tmx.Count > 0 Then
                'out.Add([tmx.Copy()], tmx["object_name"])
                sOut = ""
                For Each r In tmx
                  If TypeOf(r) <> 16 Then
                    sOut &= tmx.Key & ": " & CStr(r) & "\n"
                  Else
                    sOut &= tmx.Key & ": [type 16]" & "\n"
                  Endif
                Next

                arr = DWGArrangeEnty(tmx.Copy())
                If arr.Exist("id") Then
                  sKey = arr["entity"] & ":" & arr["id"]
                  out.Add(arr.Copy(), sKey)
                Endif
              Endif
            Endif
          Endif
        Else
        Endif
      Endif
      APPMain.Progress(stx.Count, i)
    Next
  Endif

  out2 = GauchoEntitiesSort(out)

  Return out2

End

Public Function DWGDecodeItem(xRaw As String[]) As Variant

  Dim sVal As String
  Dim sTag As String
  Dim vVal As Variant
  Dim k As Integer
  Dim sDxf As String
  Dim sType As String
  Dim tVal As String
  Dim sGrp As String
  Dim kword As String
  Dim px As Float[]

  sTag = String.Lower(xRaw[0])
  If InStr(sTag, "entries[vcount]") > 0 Then
    sGrp = "entries"
  Endif
  sVal = Replace(xRaw[1], " [", "[")

  Print sTag & ": " & sVal

  Select sTag

    Case "ownerhandle", "layer", "style", "block_header"
      If InStr(sVal, "=>") > 0 Then
        k = InStr(sVal, " => ")
        If k > 0 Then
          tVal = String.Mid(sVal, k + 4)
          For Each kword In ["LAYER", "BLOCK_HEADER", "STYLE"]
            If InStr(tVal, kword) > 0 Then
              tVal = Replace(tVal, kword & " ", "")
              Break
            Endif
          Next
          vVal = tVal
        Endif
      Else
        vVal = "Error"
      Endif

    Case "start", "end", "ins_pt", "center", "alignment_pt", "sm_axis", "extrusion"
      px = DWGDecodeCoord(sVal)
      If px.Count = 2 Then
        px.Add(0.0)
      Endif
      vVal = px

    Case "scale"
      px = DWGDecodeCoord(sVal)
      If px.Count = 2 Then
        px.Add(1.0)
      Endif
      vVal = px

    Case "crc"
      vVal = DWGDecodeCRC(sVal)

    Case "color.index"
      vVal = DWGDecodeColor(sVal)

    Case "linewt", "color.raw"
      If InStr(sVal, "[") > 0 Then
        tVal = Split(sVal, "[")[0]
        vVal = tVal
      Else
        vVal = sVal
      Endif
      vVal = DWGDecodeHex(tVal)

    Case "handle"
      vVal = DWGDecodeHandle(sVal)

    Case "start_angle", "end_angle", "axis_ratio"
      If InStr(sVal, "[") > 0 Then
        tVal = Split(sVal, "[")[0]
        vVal = DWGDecodeFloat(tVal)
      Else
        vVal = DWGDecodeFloat(sVal)
      Endif

    Case "prev_entity", "next_entity", "xdicobjhandle"
      If InStr(sVal, ")") > 0 Then
        tVal = Split(sVal, ")")[0]
        tVal = Replace(tVal, "(", "")
        vVal = tVal
      Else
        vVal = sVal
      Endif

    Case "address"
      vVal = sVal

    Case "bitsize", "num_eed", "horiz_alignment"
      vVal = DWGDecodeInteger(sVal)

    Case "hdlsize"
      If InStr(sVal, ",") > 0 Then
        tVal = Split(sVal, ",")[0]
      Else
        tVal = sVal
      Endif
      vVal = DWGDecodeInteger(tVal)

    Case "x_ang", "height", "x", "y", "z", "radius", "rotation"
      vVal = DWGDecodeFloat(tVal)

    Case Else
      If InStr(sVal, "[") > 0 And Right(sVal) = "]" Then
        If InStr(sVal, " ") > 0 Then
          sType = Split(Split(sVal, "[")[1], " ")[0]
          sDxf = Split(Split(sVal, "[")[1], " ")[1]
        Else
          sType = Split(sVal, "[")[1]
          sType = Replace(sType, "]", "")
          sDxf = ""
        Endif
        tVal = Split(sVal, "[")[0]

        Select sType
          Case "3B", "4BITS", "B", "BB" 'Byte
            Try vVal = CByte(tVal)

            If Error Then
              Print Error.Backtrace
              vVal = CByte("0")
            Endif

          Case "BD", "BE", "BT", "RD" 'FLoat
            vVal = vag.CFloat(tVal)

          Case "DD" 'Coords
            Select sDxf
              Case ""
                vVal = vag.CFloat(tVal)
              Case "10", "11", "20", "21", "30", "31", "40", "41"
                vVal = DWGDecodeCoord(sVal)
            End Select

          Case "BL", "BLL", "MC", "MS", "RL", "UMC" 'Long
            vVal = CLong(tVal)

          Case "BS", "RS"  'Short
            vVal = CShort(tVal)

          Case "RC", "TF", "TFF", "TU", "TV" 'String
            vVal = CString(tVal)

          Case "CMC", "H" ' ¬øString?
            vVal = CString(tVal)

          Case Else
            vVal = tVal

        End Select

      Else
        vVal = sVal
      Endif

  End Select

  Return vVal

End

'' Create a list of DWG headers using the previously extracted text with the dwgread function

Public Function DWGHeader(s As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim obt As String
  Dim obx As New String[]
  Dim sTag As String
  Dim sVal As String
  Dim out As New Collection

  stx = Split(s, "\n")

  If stx.count > 0 Then
    For i = 1 To stx.Max
      obt = stx[i]
      obx.Clear
      If InStr(obt, ": ") > 0 Then
        obt = Replace(obt, ": ", "\t")
        obt = Replace(obt, " [", "\t")
        obt = Replace(obt, "]", "")
        obx = Split(obt, "\t")
        sTag = obx[0]
        sVal = obx[1]
        out.Add(sVal, sTag)
      Endif
    Next
  Endif

  Return out

End

'' Decode common fields to DWG entities.

Public Function DWGDecodeCommon(c As Collection) As Collection

  Dim v As Variant
  Dim prp As New Collection
  Dim sVal As Variant
  Dim i As Integer
  Dim f As Float

  If c.Exist("XName") Then

    prp.Add(c["XName"], "entity")

    If c.Exist("Objectnumber") Then
      If InStr(c["Objectnumber"], "/") > 1 Then
        i = CInt(Split(c["Objectnumber"], "/")[0])
      Endif
      prp.Add(i, "handle")
    Endif

    For Each v In c
      i = -1
      f = 0.0
      Select c.Key

        Case "layer"
          sVal = DWGDecodeLayer(CStr(v))
          prp.Add(sVal, "layer")

        Case "ltype_flags"
          i = DWGDecodeInteger(CStr(v))
          prp.Add(i, "style")

        Case "linewt"
          i = DWGDecodeHex(sVal)
          prp.Add(i, "linewt")

        Case "ltype_scale"
          f = DWGDecodeFloat(CStr(v))
          prp.Add(f, c.Key)

        Case "plotstyle_flags"
          i = DWGDecodeInteger(CStr(v))
          prp.Add(i, c.Key)

        Case "invisible"
          i = DWGDecodeInteger(CStr(v))
          prp.Add(i, c.Key)

      End Select

      ' Colour
      sVal = ""
      If c.Exist("color.raw") Then
        sVal = String.Mid(c["color.raw"], 1, InStr(c["color.raw"], "[") - 1)
        i = DWGDecodeHex(sVal)
      Else
        If c.Exist("color.index") Then
          sVal = String.Mid(c["color.index"], 1, InStr(c["color.index"], "[") - 1)
          sval = Replace(sval, " ", "")
          i = CInt(sval)
        Endif
      Endif

      If i >= 0 And i <= 256 Then
        prp.Add(i, "colour")
      Else
        prp.Add(0, "colour")
      Endif

    Next
  Endif

  Return prp

End

'' Decode the specific fields of an entity

Public Function DWGDecodeEntity(c As Collection) As Collection

  Dim v As Variant
  Dim prp As New Collection
  Dim sVal As Variant
  Dim pt As New Float[]
  Dim pt1 As New Float[]
  Dim pt2 As New Float[]
  Dim i As Integer
  Dim f As Float
  Dim p As Integer
  Dim sDec As String
  Dim sTag As String
  Dim sTag1 As String
  Dim sTag2 As String
  Dim hx As Integer
  Dim sTag3 As String
  Dim n As Integer
  Dim d As Integer
  Dim sTag5 As String
  Dim sTag4 As String
  Dim vVal As Variant

  If c.Exist("XName") Then

    If c.Exist("Objectnumber") Then
      If InStr(c["Objectnumber"], "/") > 1 Then
        i = CInt(Split(c["Objectnumber"], "/")[0])
      Endif
      prp.Add(CStr(i), "handle")
    Endif

    prp.Add(c["XName"], "entity")

    Select c["XName"]

      Case "TEXT"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "alignment_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p2")

            Case "rotation"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle")

            Case "height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "horiz_alignment"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "horiz")

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

            Case "text_value" ' I deide call just "text" to the tag
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "text")

          End Select
        Next

      Case "MTEXT"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "x_axis_dir"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "rect_width"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "text_height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "attachment"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "drawing_dir"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "extents_height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "extents_width"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "text"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "text")

            Case "linespace_style"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "linespace_factor"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "unknown_bit"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "bg_fill_flag"

              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

          End Select
        Next

      Case "ATTDEF"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "default_value"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "default")

            Case "tag"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "tag")

            Case "field_length"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "length")

            Case "prompt"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "prompt")

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

          End Select
        Next

      Case "ATTRIB"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "text_value"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "text")

            Case "tag"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "tag")

            Case "field_length"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "length")

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

          End Select
        Next

      Case "POINT"
        prp.Add([0, 0, 0], "p1")
        For Each v In c
          Select c.Key
            Case "x"
              f = DWGDecodeFloat(CStr(v))
              prp["p1"][0] = f

            Case "y"
              f = DWGDecodeFloat(CStr(v))
              prp["p1"][1] = f

            Case "z"
              f = DWGDecodeFloat(CStr(v))
              prp["p1"][2] = f

          End Select
        Next

        f = DWGDecodeFloat(c["x_ang"])
        prp.Add(f, "angle")

      Case "LINE"
        For Each v In c
          Select c.Key
            Case "start"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")
            Case "end"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p2")
          End Select
        Next

      Case "INSERT"
        For Each v In c
          Select c.Key

            Case "ins_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "scale_flag"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "scale"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "scale")

            Case "rotation"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle")

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "has_attribs"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "num_owned"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "block_header"
              sVal = DWGDecodeBlockHeader(CStr(v))
              prp.Add(sVal, c.Key)

          End Select
        Next

      Case "CIRCLE"
        For Each v In c
          Select c.Key
            Case "center"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "radius"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "radius")
          End Select
        Next

      Case "ARC"
        For Each v In c
          Select c.Key
            Case "center"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "radius"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "radius")

            Case "start_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle1")

            Case "end_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle2")
          End Select
        Next

      Case "ELLIPSE"
        For Each v In c
          Select c.Key
            Case "center"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "sm_axis"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "axis_ratio"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "start_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle1")

            Case "end_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle2")

          End Select

        Next

      Case "LWPOLYLINE"
        For Each v In c
          Select c.Key
            Case "num_points"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "points")
              For p = 0 To i
                sDec = "points[" & p & "]"
                sTag = "p" & CStr(p)
                If c.Exist(sDec) Then
                  pt = DWGDecodeCoord(CStr(c[sDec]))
                  prp.Add(pt, sTag)
                Endif
              Next
          End Select
        Next

      Case "HATCH"
        For Each v In c
          Select c.Key

            Case "is_gradient_fill"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "reserved"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "gradient_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "gradient_shift"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "single_color_gradient"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "gradient_tint"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "num_colors"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "gradient_name"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, c.Key)

            Case "elevation"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "name"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, c.Key)

            Case "solid_fill"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "associative"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "num_paths"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "paths[0].flag"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "paths[0].num_segs_or_paths"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

              For p = 0 To i
                sTag = "paths[0].segs[p].type_status"
                sTag1 = "paths[0].segs[p].first_endpoint"
                sTag2 = "paths[0].segs[p].second_endpoint"

                If c.Exist(sTag) Then
                  hx = DWGDecodeHex(CStr(c[sTag]))
                  prp.Add(hx, sTag1)
                Endif

                If c.Exist(sTag1) Then
                  pt1 = DWGDecodeCoord(CStr(c[sTag1]))
                  prp.Add(pt1, sTag1)
                Endif

                If c.Exist(sTag2) Then
                  pt2 = DWGDecodeCoord(CStr(c[sTag2]))
                  prp.Add(pt2, sTag2)
                Endif

              Next

            Case "paths[0].num_boundary_handles"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "style"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "pattern_type"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "scale_spacing"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "double_flag"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "num_deflines"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

              For p = 0 To i

                sTag1 = "deflines[" & CStr(i) & "].pt0"
                pt = DWGDecodeCoord(CStr(c[sTag1]))
                prp.Add(pt, sTag1)

                sTag2 = "deflines[" & CStr(i) & "].offset"
                pt = DWGDecodeCoord(CStr(c[sTag2]))
                prp.Add(pt, sTag2)

                sTag3 = "deflines[" & CStr(i) & "].num_dashes"
                n = DWGDecodeInteger(CStr(c[sTag3]))
                prp.Add(n, sTag3)

                For d = 0 To n
                  sTag4 = "deflines[rcount1].dashes[" & CStr(d) & "]"
                  f = DWGDecodeFloat(CStr(c[sTag4]))
                  prp.Add(f, sTag4)
                Next
                sTag5 = "deflines[rcount1].angle"
                f = DWGDecodeFloat(CStr(c[sTag5]))
                prp.Add(f, sTag5)

              Next

            Case "num_seeds"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "seeds[vcount]"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

          End Select
        Next
      Case Else
        For Each v In c
          sVal = CStr(v)
          If InStr(sVal, "[") > 0 And InStr(sVal, "]") > 0 Then
            vVal = DWGDecodeItem(sVal)
          Else
            vVal = sVal
          Endif
          prp.Add(vVal, c.Key)
        Next

    End Select
  Endif

  Return prp

End

'' Decode the coordinate fields in a entity from DWG file.

Public Function DWGDecodeCoord(s As String) As Float[]

  Dim pt As New Float[]
  Dim sVal As String

  sVal = Replace(s, " ", "")
  sVal = Replace(sVal, ",", ":")
  sVal = Replace(sVal, "(", "")
  sVal = Replace(sVal, ")", "")
  If InStr(sVal, "[") > 0 Then
    sVal = String.Mid(sVal, 1, InStr(sVal, "[") - 1)
  Endif

  pt = Split(sVal, ":")

  Return pt

End

Public Function DWGDecodeCRC(s As String) As String

  Dim out As String

  If InStr(s, "[RSx]") > 0 Then
    out = Split(s, "[")[0]
  Else
    out = ""
  Endif

  Return out

End

Public Function DWGDecodeColor(s As String) As Byte

  Dim out As Byte

  If InStr(s, "[") > 0 Then
    s = Replace(s, " [", "[")
    Try out = CByte(Split(s, "[")[0])
    If Error Then
      out = 0
    Endif
  Else
    out = 0
  Endif

  Return out

End

'' Decode the Hex fields in a entity from DWG file.

Public Function DWGDecodeHex(s As String) As Integer

  Dim out As Integer

  If InStr(s, "0x") > 0 Then
    out = Val(Replace(s, "0x", "&00"))
  Else
    out = 0
  Endif

  Return out

End

'' Decode the Floar fields in a entity from DWG file.

Public Function DWGDecodeFloat(s As String) As Float

  Dim out As Float
  Dim sVal As String

  sVal = Replace(s, " ", "")
  If InStr(sVal, "[") > 0 Then
    out = Split(sVal, "[")[0]
  Else
    out = 0.0
  Endif

  Return out

End

'' Decode the Integer fields.

Public Function DWGDecodeInteger(s As String) As Integer

  Dim out As Integer
  Dim sVal As String

  sVal = Replace(s, " ", "")
  If InStr(sVal, "[") > 0 Then
    out = Split(sVal, "[")[0]
  Else
    out = 0
  Endif

  Return out

End

'' Decode the layers fields.

Public Function DWGDecodeLayer(s As String) As String

  Dim out As String

  If InStr(s, " => LAYER ") > 0 Then
    out = Split(Replace(s, " => LAYER ", "\t"), "\t")[1]
  Else
    out = s
  Endif

  Return out

End

'' Decode the block header.

Public Function DWGDecodeHandle(s As String) As String

  Dim out As String

  If InStr(s, "[H 5]") > 0 Then
    out = Split(s, "[")[0]
  Else
    out = s
  Endif

  Return out

End

Public Function DWGDecodeBlockHeader(s As String) As String

  Dim out As String

  If InStr(s, " => BLOCK_HEADER ") > 0 Then
    out = Split(Replace(s, " => BLOCK_HEADER ", "\t"), "\t")[1]
  Else
    out = s
  Endif

  Return out

End

'' Decode the text style field.

Public Function DWGDecodeTextStyle(s As String) As String

  Dim out As String

  If InStr(s, " => STYLE ") > 0 Then
    out = Split(Replace(s, " => STYLE ", "\t"), "\t")[1]
  Else
    out = s
  Endif

  Return out

End

'' Decode the text fields.

Public Function DWGDecodeText(s As String) As String

  Dim out As String

  s = Conv$(s, "ISO-8859-1", "UTF-8")
  If InStr(s, "\\U+") > 0 Then
    s = String2.Flat(s)
  Endif

  If InStr(s, " [") > 0 Then
    out = Split(Replace(s, " [", "\t"), "\t")[0]
    If String.Left(out) = Chr(34) Then
      out = String.Mid(out, 2)
    Endif
    If String.Right(out) = Chr(34) Then
      out = String.Mid(out, 1, String.Len(out) - 1)

    Endif
  Else
    out = s
  Endif

  Return out

End

Public Function DWGAlias() As Collection

  Dim d As New Collection

  d.Add("linewt", "linewt")
  d.Add("style", "ltype_flags")
  d.Add("block", "ownerhandle")

  Return d

End

Public Function DWGArrangeEnty(c As Collection) As Collection

  Dim o As New Collection
  Dim x As New Collection
  Dim err As New String[]
  Dim tag As String
  Dim str As String
  Dim p As Integer
  Dim pt As String
  Dim ps As String
  Dim px As New Float[]
  Dim flo As Float
  Dim int As Integer

  If c.Exist("entity") Then

    o.Add(c["entity"], "entity")

    If c.Exist("id") Then
      o.Add(c["id"], "id")
    Else
      o.Add("id", "error")
    Endif

    If c.Exist("handle") Then
      o.Add(c["handle"], "handle")
    Else
      If c.Exist("id") Then
        o.Add(c["id"], "handle")
      Else
        o.Add("handle", "error")
      Endif
    Endif

    For Each tag In ["layer", "style", "linewt"]
      If c.Exist(tag) Then
        o.Add(c[tag], tag)
      Else
        err.Add(tag)
      Endif
    Next

    If c.Exist("invisible") Then
      o.Add(c["invisible"], "invisible")
    Else
      o.Add(0, "invisible")
    Endif

    If c.Exist("block") Then
      o.Add(c["block"], "block")
    Else
      o.Add("", "block")
    Endif

    If c.Exist("color.index") Then
      o.Add(c["color.index"], "colour")
    Else
      If c.Exist("color.raw") Then
        o.Add(c["color.raw"], "colour")
      Else
        o.Add(0, "colour")
      Endif
    Endif

    Select c["entity"]

      Case "ELLIPSE"
        x.Clear
        If c.Exist("center") Then
          x.Add(c["center"], "p0")
          If c.Exist("sm_axis") Then
            x.Add(c["sm_axis"], "p1")
          Endif
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

        If c.Exist("axis_ratio") Then
          o.Add(c["axis_ratio"], "ratio")
        Else
          err.Add("ratio")
        Endif

        If c.Exist("start_angle") Then
          o.Add(c["start_angle"], "start_angle")
        Else
          err.Add("start_angle")
        Endif

        If c.Exist("end_angle") Then
          o.Add(c["end_angle"], "end_angle")
        Else
          err.Add("end_angle")
        Endif

      Case "ARC"
        If c.Exist("center") Then
          x.Clear
          x.Add(c["center"], "p0")
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

        If c.Exist("radius") Then
          o.Add(c["radius"], "radius")
        Else
          err.Add("radius")
        Endif

        If c.Exist("start_angle") Then
          o.Add(c["start_angle"], "start_angle")
        Else
          err.Add("start_angle")
        Endif

        If c.Exist("end_angle") Then
          o.Add(c["end_angle"], "end_angle")
        Else
          err.Add("end_angle")
        Endif

      Case "ATTDEF"
        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          o.Add(x.Copy(), "p")
          x.Clear
        Else
          err.Add("p")
        Endif
        If c.Exist("height") Then
          flo = DWGDecodeFloat(c["height"])
          o.Add(flo, tag)
        Else
          err.Add("height")
        Endif
        For Each tag In ["default_value", "tag", "prompt", "style"]
          If c.Exist(tag) Then
            str = UnQuote(c[tag])
            o.Add(str, tag)
          Else
            err.Add(tag)
          Endif
        Next

        'Case "ATTRIB"

      Case "CIRCLE"
        If c.Exist("center") Then
          x.Clear
          x.Add(c["center"], "p0")
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif
        If c.Exist("radius") Then
          o.Add(c["radius"], "radius")
        Else
          err.Add("radius")
        Endif

      Case "HATCH"

      Case "INSERT"

        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

        If c.Exist("scale") Then
          If c["scale"].Count > 1 Then
            o.Add(c["scale"][0], "scalex")
            o.Add(c["scale"][1], "scaley")
            If c["scale"].Count > 2 Then
              o.Add(c["scale"][2], "scalez")
            Endif
          Else
            err.Add("scalex")
            err.Add("scaley")
          Endif
        Endif

        If c.Exist("rotation") Then
          o.Add(c["rotation"], "angle")
        Else
          err.Add("angle")
        Endif

        If c.Exist("block_header") Then
          o.Add(c["block_header"], "block")
        Else
          err.Add("block")
        Endif

      Case "LINE"
        If c.Exist("start") And c.Exist("end") Then
          x.Clear
          x.Add(c["start"], "p0")
          x.Add(c["end"], "p1")
          o.Add(x.Copy(), "p")
          x.Clear
        Else
          err.Add("p")
        Endif

      Case "LWPOLYLINE"
        If c.Exist("num_points") Then
          o.Add(c["num_points"], "num_points")
          x.Clear
          For p = 0 To c["num_points"] - 1
            pt = "p" & CStr(p)
            ps = "points[" & CStr(p) & "]"

            If c.Exist(ps) Then
              px = DWGDecodeCoord(c[ps])
              If px.Count = 2 Then
                px.Add(0.0)
              Endif
              x.Add(px, pt)
            Else
              err.Add("p")
            Endif
          Next
          o.Add(x.Copy(), "p")
          x.Clear
        Else
          err.Add("p")
        Endif

      Case "MTEXT"

        If c.Exist("text_height") Then
          flo = c["text_height"]
          o.Add(flo, "text_height")
        Else
          err.Add("text_height")
        Endif

        If c.Exist("rotation") Then
          flo = c["rotation"]
        Else
          flo = 0.0
        Endif
        o.Add(flo, "angle")

        If c.Exist("horiz_alignment") Then
          int = c["horiz_alignment"]
          o.Add(int, "horiz_alignment")
        Endif

        If c.Exist("text") Then
          str = UnQuote(c["text"])
          o.Add(str, "text")
        Else
          err.Add("text")
        Endif

        If c.Exist("text_style") Then
          str = UnQuote(c["text_style"])
          o.Add(str, "text_style")
        Else
          err.Add("text_style")
        Endif

        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          If c.Exist("alignment_pt") Then
            x.Add(c["alignment_pt"], "p1")
          Endif
          o.Add(x.Copy(), "p")
        Endif

      Case "POINT"
        If c.Exist("x") And c.Exist("y") And c.Exist("z") Then
          x.Clear
          px.Add(c["x"])
          px.Add(c["y"])
          px.Add(c["z"])
          x.Add(px, "p0")
          o.Add(x, "p")
        Else
          err.Add("p")
        Endif

      Case "TEXT"

        If c.Exist("height") Then
          flo = c["height"]
          o.Add(flo, "text_height")
        Else
          err.Add("text_height")
        Endif

        If c.Exist("rotation") Then
          flo = c["rotation"]
        Else
          flo = 0.0
        Endif
        o.Add(flo, "angle")

        If c.Exist("horiz_alignment") Then
          int = c["horiz_alignment"]
          o.Add(int, "horiz_alignment")
        Endif

        If c.Exist("text") Then
          str = UnQuote(c["text"])
          o.Add(str, "text")
        Else
          err.Add("text")
        Endif

        If c.Exist("text_style") Then
          str = UnQuote(c["text_style"])
          o.Add(str, "text_style")
        Else
          err.Add("text_style")
        Endif

        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          If c.Exist("alignment_pt") Then
            x.Add(c["alignment_pt"], "p1")
          Endif
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

    End Select
  Endif

  If err.Count > 0 Then
    o.Add(err, "error")
  Endif

  Return o

End

'' creates a list of dimension codes.

Public Function DWGDimCodes() As Collection

  Dim d As New Collection

  d.Add(["DIMPOST", "string"], "3")
  d.Add(["DIMAPOST", "float"], "4")
  d.Add(["DIMBLK", "string"], "5")
  d.Add(["DIMBLK1", "string"], "6")
  d.Add(["DIMBLK2", "string"], "7")
  d.Add(["DIMSCALE", "float"], "40")
  d.Add(["DIMASZ", "float"], "41")
  d.Add(["DIMEXO", "float"], "42")
  d.Add(["DIMDLI", "float"], "43")
  d.Add(["DIMEXE", "float"], "44")
  d.Add(["DIMRND", "float"], "45")
  d.Add(["DIMDLE", "float"], "46")
  d.Add(["DIMTP", "float"], "47")
  d.Add(["DIMTM", "float"], "48")
  d.Add(["DIMTXT", "float"], "140")
  d.Add(["DIMCEN", "float"], "141")
  d.Add(["DIMTSZ", "float"], "142")
  d.Add(["DIMALTF", "float"], "143")
  d.Add(["DIMLFAC", "float"], "144")
  d.Add(["DIMTVP", "float"], "145")
  d.Add(["DIMTFAC", "float"], "146")
  d.Add(["DIMGAP", "float"], "147")
  d.Add(["DIMALTRND", "float"], "148")
  d.Add(["DIMTOL", "float"], "71")
  d.Add(["DIMLIM", "float"], "72")
  d.Add(["DIMTIH", "float"], "73")
  d.Add(["DIMTOH", "float"], "74")
  d.Add(["DIMSE1", "float"], "75")
  d.Add(["DIMSE2", "float"], "76")
  d.Add(["DIMTAD", "float"], "77")
  d.Add(["DIMZIN", "float"], "78")
  d.Add(["DIMAZIN", "float"], "79")
  d.Add(["DIMALT", "float"], "170")
  d.Add(["DIMALTD", "float"], "171")
  d.Add(["DIMTOFL", "float"], "172")
  d.Add(["DIMSAH", "float"], "173")
  d.Add(["DIMTIX", "float"], "174")
  d.Add(["DIMSOXD", "float"], "175")
  d.Add(["DIMCLRD", "float"], "176")
  d.Add(["DIMCLRE", "float"], "177")
  d.Add(["DIMCLRT", "float"], "178")
  d.Add(["DIMADEC", "float"], "179")
  d.Add(["DIMUNIT", "float"], "270")
  d.Add(["DIMDEC", "float"], "271")
  d.Add(["DIMTDEC", "float"], "272")
  d.Add(["DIMALTU", "float"], "273")
  d.Add(["DIMALTTD", "float"], "274")
  d.Add(["DIMAUNIT", "float"], "275")
  d.Add(["DIMFRAC", "float"], "276")
  d.Add(["DIMLUNIT", "float"], "277")
  d.Add(["DIMDSEP", "float"], "278")
  d.Add(["DIMTMOVE", "float"], "279")
  d.Add(["DIMJUST", "float"], "280")
  d.Add(["DIMSD1", "float"], "281")
  d.Add(["DIMSD2", "float"], "282")
  d.Add(["DIMTOLJ", "float"], "283")
  d.Add(["DIMTZIN", "float"], "284")
  d.Add(["DIMALTZ", "float"], "285")
  d.Add(["DIMALTTZ", "float"], "286")
  d.Add(["DIMFIT", "float"], "287")
  d.Add(["DIMUPT", "float"], "288")
  d.Add(["DIMATFIT", "float"], "289")
  d.Add(["DIMTXSTY", "string"], "340")
  d.Add(["DIMLDRBLK", "string"], "341")
  d.Add(["DIMBLK", "string"], "342")
  d.Add(["DIMBLK1", "string"], "343")
  d.Add(["DIMBLK2", "string"], "344")
  d.Add(["DIMLWD", "string"], "371")
  d.Add(["DIMLWE", "string"], "372")

  Return d

End

'' Creates a list with the codes of an entity indicated as a parameter.

Public Function DXFEntityDefaults(Optional ent As String) As Collection

  Dim cod As New Collection
  'Common defaults
  cod.Add("BYLAYER", "6")
  cod.Add("BYLAYER", "347")
  cod.Add(0, "370") ' Este no es el valor por defecto en el estandar pero lo puse asi porque a veces es omitido en el dxf
  cod.Add(0, "60")
  cod.Add(256, "62")
  cod.Add(0, "67")
  cod.Add(1.0, "48")

  Select String.LCase(ent)
    Case "insert"
      cod.Add(1, "41")
      cod.Add(1, "42")
      cod.Add(1, "43")
      cod.Add(0, "44")
      cod.Add(0, "45")
      cod.Add(0, "50")
      cod.Add(1, "70")
      cod.Add(1, "71")

    Case "text"
      cod.Add(0, "39")
      cod.Add(0, "50")
      cod.Add("STANDARD", "7")
      cod.Add(1, "41")
      cod.Add(0, "71")
      cod.Add(0, "72")
      cod.Add(0, "73")
    Case "mtext"
      cod.Add(1, "71")
      cod.Add(0, "50")

  End Select

  Return cod

End

'' Creates a list with all the codes of an entity indicated as a parameter.

Public Function DXFEntityCodes(Optional ent As String) As Collection

  Dim cod As New Collection

  cod.Add("entity", "0") '*
  cod.Add("handle", "5") '*
  cod.Add("style", "6") '*
  cod.Add("layer", "8") '*
  cod.Add("colour", "62") '*
  cod.Add("material", "347")
  cod.Add("linewt", "370") '*
  cod.Add("linetype_scale", "48")

  cod.Add("visible", "60") '*
  cod.Add("paper", "67") '*
  cod.Add("flag", "71")
  cod.Add("elev", "38")
  cod.Add("thick", "39")
  cod.Add("x0", "10")
  cod.Add("y0", "20")
  cod.Add("z0", "30")
  cod.Add("x1", "11")
  cod.Add("y1", "21")
  cod.Add("z1", "31")

  cod.Add("x2", "12")
  cod.Add("y2", "22")
  cod.Add("z2", "32")

  cod.Add("x3", "13")
  cod.Add("y3", "23")
  cod.Add("z3", "33")

  ' used in dims
  cod.Add("x4", "14")
  cod.Add("y4", "24")
  cod.Add("z4", "34")

  cod.Add("x5", "15")
  cod.Add("y5", "25")
  cod.Add("z5", "35")

  cod.Add("x6", "16")
  cod.Add("y6", "26")
  cod.Add("z6", "36")

  cod.Add("extrx", "210")
  cod.Add("extry", "220")
  cod.Add("extrz", "230")
  cod.Add("blkid", "330")

  Select String.LCase(ent)

    Case "3dsolid"
      cod.Add("format", "70")

    Case "arc"
      cod.Add("radius", "40")
      cod.Add("start_angle", "50")
      cod.Add("end_angle", "51")

    Case "circle"
      cod.Add("radius", "40")

    Case "ellipse"
      cod.Add("ratio", "40")
      cod.Add("start_angle", "41")
      cod.Add("end_angle", "42")

    Case "lwpolyline"
      cod.Add("points", "90")
      cod.Add("closed", "70")
      cod.Add("constant", "43")

    Case "insert"
      cod.Add("block", "2")
      cod.Add("scalex", "41")
      cod.Add("scaley", "42")
      cod.Add("scalez", "43")
      cod.Add("angle", "50")
      cod.Add("has_attribs", "66")
      cod.Add("column_count", "70")
      cod.Add("row_count", "71")
      cod.Add("column_spacing", "44")
      cod.Add("row_spacing", "45")

    Case "attdef"
      cod.Add("text_height", "40")
      cod.Add("default_value", "1")
      cod.Add("tag", "2")
      cod.Add("promt", "3")
      cod.Add("flen", "73")
      cod.Add("vert", "74")
      cod.Add("angle", "50")
      cod.Add("wfactor", "41")
      cod.Add("tstyle", "7")
      cod.Add("oblique", "51")
      cod.Add("version", "280")

    Case "block"
      cod.Add("xref", "1")
      cod.Add("block", "2")
      cod.Add("bdesc", "4")

    Case "text"
      cod.Add("text_height", "40")
      cod.Add("text", "1")
      cod.Add("hjust", "72")
      cod.Add("vjust", "73")
      cod.Add("angle", "50")
      cod.Add("wfactor", "41")
      cod.Add("tstyle", "7")
      cod.Add("oblique", "51")

    Case "mtext"
      cod.Add("text_height", "40")
      cod.Add("textv", "43")
      cod.Add("text", "1")
      cod.Add("text2", "3")
      cod.Add("attachment_point", "71")
      cod.Add("hjust", "72")
      cod.Add("vjust", "73")
      cod.Add("angle", "50")
      cod.Add("rfactor", "41")
      cod.Add("hfactor", "42")
      cod.Add("lfactor", "44")
      cod.Add("tstyle", "7")
      cod.Add("oblique", "51")

      'Dimensions
    Case "arc_dimension"
      'common
      cod.Add("text", "1")
      cod.Add("block", "2")
      cod.Add("dimstyle", "3")
      cod.Add("version", "280")
      cod.Add("dimtype", "70")
      cod.Add("attachment_point", "71")
      cod.Add("text_style", "72")
      cod.Add("leader_length", "40")
      cod.Add("text_factor", "41")
      cod.Add("measurement", "42")
      cod.Add("rotation_angle", "53")
      cod.Add("horizontal_direction", "51")
      cod.Add("angle_rotated", "50")
      cod.Add("angle_extensions", "52")

  End Select

  Return cod

End

'' Return a colors list by the form r,g,b where each index is the DXF color integer number.

Public Function DWGColors() As String[]

  Dim rgbx As New String[]

  rgbx.Add("0,0,0")
  rgbx.Add("255,0,0")
  rgbx.Add("255,255,0")
  rgbx.Add("0,255,0")
  rgbx.Add("0,255,255")
  rgbx.Add("0,0,255")
  rgbx.Add("255,0,255")
  rgbx.Add("255,255,255")
  rgbx.Add("128,128,128")
  rgbx.Add("192,192,192")
  rgbx.Add("255,0,0")
  rgbx.Add("255,127,127")
  rgbx.Add("165,0,0")
  rgbx.Add("165,82,82")
  rgbx.Add("127,0,0")
  rgbx.Add("127,63,63")
  rgbx.Add("76,0,0")
  rgbx.Add("76,38,38")
  rgbx.Add("38,0,0")
  rgbx.Add("38,19,19")
  rgbx.Add("255,63,0")
  rgbx.Add("255,159,127")
  rgbx.Add("165,41,0")
  rgbx.Add("165,103,82")
  rgbx.Add("127,31,0")
  rgbx.Add("127,79,63")
  rgbx.Add("76,19,0")
  rgbx.Add("76,47,38")
  rgbx.Add("38,9,0")
  rgbx.Add("38,23,19")
  rgbx.Add("255,127,0")
  rgbx.Add("255,191,127")
  rgbx.Add("165,82,0")
  rgbx.Add("165,124,82")
  rgbx.Add("127,63,0")
  rgbx.Add("127,95,63")
  rgbx.Add("76,38,0")
  rgbx.Add("76,57,38")
  rgbx.Add("38,19,0")
  rgbx.Add("38,28,19")
  rgbx.Add("255,191,0")
  rgbx.Add("255,223,127")
  rgbx.Add("165,124,0")
  rgbx.Add("165,145,82")
  rgbx.Add("127,95,0")
  rgbx.Add("127,111,63")
  rgbx.Add("76,57,0")
  rgbx.Add("76,66,38")
  rgbx.Add("38,28,0")
  rgbx.Add("38,33,19")
  rgbx.Add("255,255,0")
  rgbx.Add("255,255,127")
  rgbx.Add("165,165,0")
  rgbx.Add("165,165,82")
  rgbx.Add("127,127,0")
  rgbx.Add("127,127,63")
  rgbx.Add("76,76,0")
  rgbx.Add("76,76,38")
  rgbx.Add("38,38,0")
  rgbx.Add("38,38,19")
  rgbx.Add("191,255,0")
  rgbx.Add("223,255,127")
  rgbx.Add("124,165,0")
  rgbx.Add("145,165,82")
  rgbx.Add("95,127,0")
  rgbx.Add("111,127,63")
  rgbx.Add("57,76,0")
  rgbx.Add("66,76,38")
  rgbx.Add("28,38,0")
  rgbx.Add("33,38,19")
  rgbx.Add("127,255,0")
  rgbx.Add("191,255,127")
  rgbx.Add("82,165,0")
  rgbx.Add("124,165,82")
  rgbx.Add("63,127,0")
  rgbx.Add("95,127,63")
  rgbx.Add("38,76,0")
  rgbx.Add("57,76,38")
  rgbx.Add("19,38,0")
  rgbx.Add("28,38,19")
  rgbx.Add("63,255,0")
  rgbx.Add("159,255,127")
  rgbx.Add("41,165,0")
  rgbx.Add("103,165,82")
  rgbx.Add("31,127,0")
  rgbx.Add("79,127,63")
  rgbx.Add("19,76,0")
  rgbx.Add("47,76,38")
  rgbx.Add("9,38,0")
  rgbx.Add("23,38,19")
  rgbx.Add("0,255,0")
  rgbx.Add("127,255,127")
  rgbx.Add("0,165,0")
  rgbx.Add("82,165,82")
  rgbx.Add("0,127,0")
  rgbx.Add("63,127,63")
  rgbx.Add("0,76,0")
  rgbx.Add("38,76,38")
  rgbx.Add("0,38,0")
  rgbx.Add("19,38,19")
  rgbx.Add("0,255,63")
  rgbx.Add("127,255,159")
  rgbx.Add("0,165,41")
  rgbx.Add("82,165,103")
  rgbx.Add("0,127,31")
  rgbx.Add("63,127,79")
  rgbx.Add("0,76,19")
  rgbx.Add("38,76,47")
  rgbx.Add("0,38,9")
  rgbx.Add("19,38,23")
  rgbx.Add("0,255,127")
  rgbx.Add("127,255,191")
  rgbx.Add("0,165,82")
  rgbx.Add("82,165,124")
  rgbx.Add("0,127,63")
  rgbx.Add("63,127,95")
  rgbx.Add("0,76,38")
  rgbx.Add("38,76,57")
  rgbx.Add("0,38,19")
  rgbx.Add("19,38,28")
  rgbx.Add("0,255,191")
  rgbx.Add("127,255,223")
  rgbx.Add("0,165,124")
  rgbx.Add("82,165,145")
  rgbx.Add("0,127,95")
  rgbx.Add("63,127,111")
  rgbx.Add("0,76,57")
  rgbx.Add("38,76,66")
  rgbx.Add("0,38,28")
  rgbx.Add("19,38,33")
  rgbx.Add("0,255,255")
  rgbx.Add("127,255,255")
  rgbx.Add("0,165,165")
  rgbx.Add("82,165,165")
  rgbx.Add("0,127,127")
  rgbx.Add("63,127,127")
  rgbx.Add("0,76,76")
  rgbx.Add("38,76,76")
  rgbx.Add("0,38,38")
  rgbx.Add("19,38,38")
  rgbx.Add("0,191,255")
  rgbx.Add("127,223,255")
  rgbx.Add("0,124,165")
  rgbx.Add("82,145,165")
  rgbx.Add("0,95,127")
  rgbx.Add("63,111,127")
  rgbx.Add("0,57,76")
  rgbx.Add("38,66,76")
  rgbx.Add("0,28,38")
  rgbx.Add("19,33,38")
  rgbx.Add("0,127,255")
  rgbx.Add("127,191,255")
  rgbx.Add("0,82,165")
  rgbx.Add("82,124,165")
  rgbx.Add("0,63,127")
  rgbx.Add("63,95,127")
  rgbx.Add("0,38,76")
  rgbx.Add("38,57,76")
  rgbx.Add("0,19,38")
  rgbx.Add("19,28,38")
  rgbx.Add("0,63,255")
  rgbx.Add("127,159,255")
  rgbx.Add("0,41,165")
  rgbx.Add("82,103,165")
  rgbx.Add("0,31,127")
  rgbx.Add("63,79,127")
  rgbx.Add("0,19,76")
  rgbx.Add("38,47,76")
  rgbx.Add("0,9,38")
  rgbx.Add("19,23,38")
  rgbx.Add("0,0,255")
  rgbx.Add("127,127,255")
  rgbx.Add("0,0,165")
  rgbx.Add("82,82,165")
  rgbx.Add("0,0,127")
  rgbx.Add("63,63,127")
  rgbx.Add("0,0,76")
  rgbx.Add("38,38,76")
  rgbx.Add("0,0,38")
  rgbx.Add("19,19,38")
  rgbx.Add("63,0,255")
  rgbx.Add("159,127,255")
  rgbx.Add("41,0,165")
  rgbx.Add("103,82,165")
  rgbx.Add("31,0,127")
  rgbx.Add("79,63,127")
  rgbx.Add("19,0,76")
  rgbx.Add("47,38,76")
  rgbx.Add("9,0,38")
  rgbx.Add("23,19,38")
  rgbx.Add("127,0,255")
  rgbx.Add("191,127,255")
  rgbx.Add("82,0,165")
  rgbx.Add("124,82,165")
  rgbx.Add("63,0,127")
  rgbx.Add("95,63,127")
  rgbx.Add("38,0,76")
  rgbx.Add("57,38,76")
  rgbx.Add("19,0,38")
  rgbx.Add("28,19,38")
  rgbx.Add("191,0,255")
  rgbx.Add("223,127,255")
  rgbx.Add("124,0,165")
  rgbx.Add("145,82,165")
  rgbx.Add("95,0,127")
  rgbx.Add("111,63,127")
  rgbx.Add("57,0,76")
  rgbx.Add("66,38,76")
  rgbx.Add("28,0,38")
  rgbx.Add("33,19,38")
  rgbx.Add("255,0,255")
  rgbx.Add("255,127,255")
  rgbx.Add("165,0,165")
  rgbx.Add("165,82,165")
  rgbx.Add("127,0,127")
  rgbx.Add("127,63,127")
  rgbx.Add("76,0,76")
  rgbx.Add("76,38,76")
  rgbx.Add("38,0,38")
  rgbx.Add("38,19,38")
  rgbx.Add("255,0,191")
  rgbx.Add("255,127,223")
  rgbx.Add("165,0,124")
  rgbx.Add("165,82,145")
  rgbx.Add("127,0,95")
  rgbx.Add("127,63,111")
  rgbx.Add("76,0,57")
  rgbx.Add("76,38,66")
  rgbx.Add("38,0,28")
  rgbx.Add("38,19,33")
  rgbx.Add("255,0,127")
  rgbx.Add("255,127,191")
  rgbx.Add("165,0,82")
  rgbx.Add("165,82,124")
  rgbx.Add("127,0,63")
  rgbx.Add("127,63,95")
  rgbx.Add("76,0,38")
  rgbx.Add("76,38,57")
  rgbx.Add("38,0,19")
  rgbx.Add("38,19,28")
  rgbx.Add("255,0,63")
  rgbx.Add("255,127,159")
  rgbx.Add("165,0,41")
  rgbx.Add("165,82,103")
  rgbx.Add("127,0,31")
  rgbx.Add("127,63,79")
  rgbx.Add("76,0,19")
  rgbx.Add("76,38,47")
  rgbx.Add("38,0,9")
  rgbx.Add("38,19,23")
  rgbx.Add("0,0,0")
  rgbx.Add("51,51,51")
  rgbx.Add("102,102,102")
  rgbx.Add("153,153,153")
  rgbx.Add("204,204,204")
  rgbx.Add("255,255,255")
  rgbx.Add("255,255,255")
  rgbx.Add("255,255,255")

  Return rgbx

End

'' Input a DXF color return a RGB color.

Public Function GauchoDecodeColor() As Integer[]

  Dim rgb As New Integer[]

  Dim s As String
  Dim r As String
  Dim g As String
  Dim b As String
  Dim irgb As Integer
  Dim rgbx As String[]

  rgbx = DWGColors()

  For Each s In rgbx
    r = Split(s, ",")[0]
    g = Split(s, ",")[1]
    b = Split(s, ",")[2]
    irgb = Color.RGB(CInt(r), CInt(g), CInt(b))
    rgb.Add(irgb)
  Next

  Return rgb

End

'' Create a collection whith te program variables needed

Public Function GauchoConfig() As Collection

  Dim ctnOut As New Collection
  Dim ctnTmp As New Collection
  Dim str As String
  Dim sBase As String

  sBase = User.Home &/ "." & String.LCase(vag.NoSymbols(Application.Name))

  ctnTmp.Clear

  'Program
  ctnTmp.Clear
  ctnTmp.Add("Application.Directory", "Name")
  ctnTmp.Add(("Program"), "Group")
  ctnTmp.Add(sBase, "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("dio", "Ctrl")
  ctnTmp.Add(("Application directory"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Clear
  ctnTmp.Add("Application.window-background-color", "Name")
  ctnTmp.Add(("Program"), "Group")
  ctnTmp.Add("Dark", "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("cmo~Dark:Light", "Ctrl")
  ctnTmp.Add(("Window background color"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  'Desktop
  ctnTmp.Clear
  ctnTmp.Add("Desktop.Text-Editor", "Name")
  If sog.MimeDefaultApp("text/plain").Count > 0 Then
    str = sog.MimeDefaultApp("text/plain")[0]
  Else
    str = ""
  Endif
  ctnTmp.Add(("Desktop"), "Group")
  ctnTmp.Add(str, "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("txo", "Ctrl")
  ctnTmp.Add(("Simple text editor by default"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Clear
  ctnTmp.Add("Desktop.Icons", "Name")
  ctnTmp.Add(("Desktop"), "Group")
  ctnTmp.Add("/usr/share/icons/Numix/32", "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("dio", "Ctrl")
  ctnTmp.Add(("Program icons"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ' CAD
  ctnTmp.Add("CAD.Background-Dark", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Drawing window dark mode"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawOriginals", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw originals"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawMarcados", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(True, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw marked"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawSoloColumnas", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw only columns"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawBounds", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw bounds"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.FormatoCotas", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add("0.00", "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("txo", "Ctrl")
  ctnTmp.Add(("Dimensions format"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.ColorForSelected", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(&H70E000, "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("txo", "Ctrl")
  ctnTmp.Add(("Color sellection"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.ToolActive", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(True, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Tool active"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.Orthogonal", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Orthogonal"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.OrthogonalForced", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Orthogonal forced"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.OrthogonalIgnored", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Orthogonal ignored"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.flgShowInspector", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Show inspector"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  Return ctnOut

End

'DXF ========================================================================

'' Create a list of sections from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFSections(sFile As String) As Collection

  Dim sContent As String
  Dim tmx As New String[]
  Dim sec As String
  Dim sSub As String
  Dim out As New Collection
  Dim sName As String
  Dim sCont As String
  Dim cCont As New Collection
  Dim isec As Variant

  If Exist(sFile) Then
    If Stat(sFile).Type = gb.File Then
      sContent = File.Load(sFile)
      sSub = String.Mid(sContent, 1, 25)

      out.Add(File.Name(sFile), "File")

      sContent = Replace(sContent, "\r\n", "\n")
      sContent = Replace(sContent, "\t", " ")
      sContent = Replace(sContent, "  0\nSECTION\n  2\n", "\t")
      sContent = Replace(sContent, "  0\nENDSEC\n", "\t")
      tmx = Split(sContent, "\t")

      If tmx.count > 0 Then
        For Each sec In tmx
          If sec <> "" Then
            'File.Save(User.Home &/ ".txt", sec)
            sName = Split(sec, "\n")[0]
            sCont = String.Mid(sec, String.Len(sName & "\n") + 1)

            Select sName
              Case "HEADER"
                cCont = DXFHeader(sCont)
                If cCont.Exist("ACADVER") Then
                  out.Add(cCont["ACADVER"], "version")
                Endif
                out.Add(cCont, "Variables")

              Case "TABLES"
                cCont = DXFTables(sCont)
                For Each isec In cCont
                  out.Add(isec.Copy(), cCont.Key)
                Next

              Case "BLOCKS"
                cCont = DXFBlocks(sCont)
                out.Add(cCont, "Blocks")

              Case "ENTITIES"
                cCont = DXFEntities(sCont)
                out.Add(cCont, "Entities")

            End Select

          Endif
        Next
      Endif
    Endif
  Endif

  Return out

End

'' Creates a list of blocks from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFBlocks(sCont As String) As Collection

  Dim stx As New String[]
  Dim out As New Collection
  Dim i As Integer
  Dim cItem As New Collection

  sCont = Replace(sCont, "\t", " ")
  sCont = Replace(sCont, "  0\nBLOCK\n", "\t  0\nBLOCK\n")

  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbBlockBegin") > 0 Then
      If String2.Count(stx[i], "\n  0\n") > 1 And InStr(stx[i], "  0\nVIEWPORT") = 0 Then
        cItem = DXFDecodeBlock(stx[i])
        If cItem.Count > 1 Then
          out.Add(cItem.Copy(), cItem["block"])
          cItem.Clear
        Endif
      Endif
    Endif
  Next
  Return out

End

'' Creates a list of entities from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFEntities(sCont As String) As Collection

  Dim stx As New String[]
  Dim out As New Collection
  Dim sout As New Collection
  Dim i As Integer
  Dim cItem As New Collection
  Dim sKey As String
  Dim cEnty As Collection
  Dim eN As Variant

  cEnty = DWGEntityList()

  sCont = Replace(sCont, "\t", " ")

  For Each eN In cEnty
    sCont = Replace(sCont, "  0\n" & cEnty.Key & "\n  5\n", "\t  0\n" & cEnty.Key & "\n  5\n")
  Next

  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "\n100\nAcDbEntity\n") > 0 Then
      cItem.Clear
      cItem = DXFDecodeItem(stx[i])
      cItem.Add(CStr(i), "id")
      If cItem.Count > 1 Then
        sKey = ""
        If cItem.Exist("id") Then
          sKey = cItem["entity"] & ":" & cItem["id"]
          out.Add(cItem.Copy(), sKey)
        Endif
      Endif
    Endif
    APPMain.Progress(stx.Count, i)
  Next

  sout = GauchoEntitiesSort(out)

  Return sout

End

'' Sorts the list of entities previously generated that is passed as a parameter.

Public Function GauchoEntitiesSort(c As Collection) As Collection

  Dim stx As New String[]
  Dim eName As String
  Dim eType As String
  Dim tmp As New Collection
  Dim out As New Collection
  Dim ety As Variant

  For Each ety In c
    If ety.Exist("entity") Then
      eName = String.LCase(ety["entity"])
      eType = "entity"
    Else
      If ety.Exist("object") Then
        eName = String.LCase(ety["object"])
        eType = "object"
      Endif
    Endif

    If stx.Exist(eName) = False Then
      stx.Add(eName)
    Endif
  Next

  stx.Sort

  For Each eName In stx
    For Each ety In c
      If eName = String.LCase(ety["entity"]) Or eName = String.LCase(ety["object"]) Then
        If ety.Exist("handle") Then
          Select TypeOf(ety["handle"])
            Case gb.Object
              If ety["handle"] Is Variant[] Then
                tmp.Add(ety, ety["handle"][1])
              Endif
            Case Else
              tmp.Add(ety, ety["handle"])
          End Select
        Endif
      Endif
    Next
    out.Add(tmp.Copy(), eName)
    tmp.Clear
  Next

  Return out

End

'' Creates a list of headers from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFHeader(sCont As String) As Collection

  Dim stx As New String[]
  Dim cTmp As New Collection
  Dim out As New Collection
  Dim item As String
  Dim vrt As Variant

  sCont = Replace(sCont, "  9\n$", "\t")

  stx = Split(sCont, "\t")

  For Each item In stx
    If item <> "" Then
      If TypeOf(item) = gb.String Then
        cTmp = DXFDecodeHeader(item)

        Select cTmp.Count
          Case 0
            'skip
          Case 1
            For Each vrt In cTmp
              out.Add(vrt, cTmp.Key)
            Next
        End Select
      Endif

    Endif
  Next
  Return out

End

'' Creates a list of tables from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFTables(sCont As String) As Collection

  Dim stx As New String[]
  Dim cDecoded As New Collection
  Dim out As New Collection
  Dim item As String

  sCont = Replace(sCont, "\t", " ")
  sCont = Replace(sCont, "  0\nTABLE\n  2\n", "\t")
  sCont = Replace(sCont, "  0\nENDTAB\n", "\t")

  stx = Split(sCont, "\t")

  For Each item In stx
    If item <> "" Then
      If InStr(item, "\n  5\n") > 0 Then
        Select Split(item, "\n")[0]
          Case "LAYER"
            cDecoded = DXFLayerList(item)
            out.Add(cDecoded.Copy(), "Layers")
            cDecoded.Clear
          Case "LTYPE"
            cDecoded = DXFLtypeList(item)
            out.Add(cDecoded.Copy(), "LineTypes")
            cDecoded.Clear
          Case "STYLE"
            cDecoded = DXFStyleList(item)
            out.Add(cDecoded.Copy(), "TextStyles")
            cDecoded.Clear
          Case "DIMSTYLE"
            cDecoded = DXFDimStyleList(item)
            out.Add(cDecoded.Copy(), "DimStyles")
            cDecoded.Clear
        End Select
      Endif
    Endif
  Next
  Return out

End

'' Creates a list of layers from a DXF file, for this it requires the text in the LAYER section in tables.

Private Function DXFLayerList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "LAYER\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbLayerTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbLayerTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "name")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag
          Case "70"
            Select sVal
              Case "1"
                cTmp.Add(True, "frozen")
                cTmp.Add(False, "locked")
              Case "4"
                cTmp.Add(False, "frozen")
                cTmp.Add(True, "locked")
              Case Else
                cTmp.Add(False, "locked")
                cTmp.Add(False, "frozen")
            End Select
          Case "62"
            If InStr(sVal, "-") = 0 Then
              cTmp.Add(True, "show")
              cTmp.Add(CInt(sVal), "colour")
            Else
              cTmp.Add(False, "show")
              cTmp.Add(CInt(Replace(sVal, "-", "")), "colour")
            Endif

          Case "6"
            cTmp.Add(sVal, "style")

          Case "290"
            If sVal = 0 Then
              cTmp.Add(False, "print")
            Else
              cTmp.Add(True, "print")
            Endif

          Case "370"
            cTmp.Add(CInt(sVal), "linewt")

        End Select
        If cTmp.Exist("print") = False Then
          cTmp.Add(True, "print")
        Endif

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

Private Function DXFLtypeList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "LTYPE\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbLinetypeTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbLinetypeTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "Ltype")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag

          Case "3"
            cTmp.Add(sVal, "desc")

          Case "72"
            cTmp.Add(vag.CInt(sVal), "align")

          Case "73"
            cTmp.Add(vag.CInt(sVal), "elements")

          Case "40"
            cTmp.Add(vag.CFloat(sVal), "patern")

        End Select

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

'' Creates a list of styles from a DXF file, for this it requires the text in the STYLE section in tables.

Private Function DXFStyleList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "STYLE\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbTextStyleTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbTextStyleTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "Style")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag
          Case "70"
            Select sVal
              Case "1"
                cTmp.Add(True, "shape")
              Case "4"
                cTmp.Add(True, "vertical")
            End Select
          Case "40"
            cTmp.Add(vag.CFloat(sVal), "fixed")

          Case "41"
            cTmp.Add(vag.CFloat(sVal), "wfactor")

          Case "50"
            cTmp.Add(vag.CFloat(sVal), "oblique")

          Case "71"
            Select sVal
              Case "2"
                cTmp.Add(True, "mirrored_x")
              Case "4"
                cTmp.Add(True, "mirrored_y")
            End Select

          Case "42"
            cTmp.Add(vag.CFloat(sVal), "last")

          Case "3"
            cTmp.Add(sVal, "font")
          Case "4"

            If sVal <> "" Then
              cTmp.Add(sVal, "fbig")
            Endif

        End Select

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

'' Creates a list of dimension styles from a DXF file, for this it requires the text in the  DIMSTYLE section in tables.

Private Function DXFDimStyleList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer
  Dim code As Collection

  code = DWGDimCodes()

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "STYLE\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbDimStyleTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbDimStyleTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "DimStyle")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        If code.Exist(sTag) Then
          Select code[sTag][1]
            Case "string"
              cTmp.Add(sVal, code[sTag][0])
            Case "float"
              cTmp.Add(vag.CFloat(sVal), code[sTag][0])
          End Select
        Endif
      Next
      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear
    Endif
  Next

  Return cDeco

End

'' Creates a list of blocks from a DXF file, for this it requires the text in the BLOCK section in tables.

Private Function DXFBLockList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "BLOCK_RECORD\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbBlockTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbBlockTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "Block")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag

          Case "70"
            cTmp.Add(sVal, "units")

          Case "340"
            cTmp.Add(CInt(sVal), "handle")

        End Select

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

'' Create a list with all the information of a DXF entity.

Private Function DXFDecodeEntity(sItem As String) As Collection

  Dim stx As String[]
  Dim cTmp As New Collection
  Dim cTmp2 As New Collection
  Dim i As Integer
  Dim sTag As String
  Dim Entity As String
  Dim sVal As String
  Dim codes As New Collection
  Dim rep As New Collection
  Dim e As Variant
  Dim xTag As String
  Dim xOrd As String
  Dim pt As String
  Dim spt As New String[]
  Dim cp As New Collection
  Dim a0 As Float
  Dim a1 As Float
  Dim r As Float
  Dim sx As Float
  Dim sy As Float
  Dim sz As Float
  Dim tg As Variant
  Dim flo As Float
  Dim int As Integer

  stx = Split(sItem, "\n")

  If stx[0] = "  0" Then
    sTag = "entity"
    sVal = stx[1]
    cTmp.Add(sVal, sTag)
    codes = DXFEntityCodes(sVal)
  Endif

  For i = 0 To stx.Max Step 2
    If stx[i] <> "" Then
      sTag = Replace(stx[i], " ", "")
      If codes.Exist(sTag) Then
        sTag = codes[sTag]
      Endif
      If rep.Exist(sTag) = False Then
        rep.Add([1, 0], sTag)
      Else
        rep[sTag][0] = rep[sTag][0] + 1
      Endif
    Endif
  Next

  For i = 0 To stx.Max Step 2
    If stx[i] = "  0" Then
      Entity = ""
      cTmp.Clear
      sVal = stx[i + 1]
      cTmp.Add(sVal, "entity")
    Else
      If stx[i] <> "" Then
        sTag = Replace(stx[i], " ", "")
        If codes.Exist(sTag) Then
          sTag = codes[sTag]
        Endif

        sVal = stx[i + 1]

        If rep.Exist(sTag) And rep[sTag][0] > 1 Then
          rep[sTag][1] = rep[sTag][1] + 1
          cTmp.Add(sVal, sTag & "." & CStr(rep[sTag][1]))
        Else
          cTmp.Add(sVal, sTag)
        Endif

      Endif
    Endif
  Next

  If cTmp.Exist("style") = False Then
    cTmp.Add(0, "style")
  Endif

  If cTmp.Exist("linewt") = False Then
    cTmp.Add(0, "linewt")
  Endif

  If cTmp.Exist("colour") = False Then
    cTmp.Add(0, "colour")
  Endif

  If cTmp.Exist("x0") Or cTmp.Exist("x0.1") Then
    spt.Clear
    For Each e In cTmp
      If InStr(cTmp.Key, "x0") > 0 Or InStr(cTmp.Key, "x1") > 0 Then

        If InStr(cTmp.Key, ".") > 0 Then
          xTag = Split(cTmp.Key, ".")[0]
          xOrd = "." & Split(cTmp.Key, ".")[1]
        Else
          xTag = cTmp.Key
          xOrd = ""
        Endif

        Select xTag
          Case "x0"
            pt = cTmp[cTmp.Key]
            If cTmp.Exist("y0" & xOrd) Then
              pt &= ":" & cTmp["y0" & xOrd]
            Endif
            If cTmp.Exist("z0" & xOrd) Then
              pt &= ":" & cTmp["z0" & xOrd]
            Endif
            spt.Add(pt)
          Case "x1"
            pt = cTmp[cTmp.Key]
            If cTmp.Exist("y1" & xOrd) Then
              pt &= ":" & cTmp["y1" & xOrd]
            Endif
            If cTmp.Exist("z1" & xOrd) Then
              pt &= ":" & cTmp["z1" & xOrd]
            Endif
            spt.Add(pt)
        End Select
      Endif

      Select cTmp.Key
        Case "entity", "handle", "layer", "style", "linewt", "colour", "blkid", "visible", "paper", "elev", "thick"
          cTmp2.Add(cTmp[cTmp.Key], cTmp.Key)
      End Select

    Next
    cp = GauchoEncodePoint(spt.Join(";"), "p")
    cTmp2.Add(cp.Copy(), "p")
    cp.Clear

    Select cTmp["entity"]

      Case "BLOCK"
        If cTmp.Exist("block") Then
          cTmp2.Add(cTmp["block"], "block")
        Else
          cTmp2.Add("", "block")
        Endif
        If cTmp.Exist("bdesc") Then
          cTmp2.Add(cTmp["bdesc"], "bdesc")
        Else
          cTmp2.Add("", "bdesc")
        Endif

      Case "ELLIPSE", "CIRCLE", "ARC"
        If cTmp.Exist("ratio") Then ' For ellipse
          r = vag.CFloat(cTmp["ratio"])
          cTmp2.Add(r, "ratio")
        Endif

        If cTmp.Exist("radius") Then ' For circle and arc
          r = vag.CFloat(cTmp["radius"])
          cTmp2.Add(r, "radius")
        Endif

        If cTmp.Exist("angle0") And cTmp.Exist("angle1") Then ' For ellipse and arc
          a0 = vag.CFloat(cTmp["angle0"])
          a1 = vag.CFloat(cTmp["angle1"])
          cTmp2.Add(a0, "start_angle")
          cTmp2.Add(a1, "end_angle")
        Else
          cTmp2.Add(0.0, "start_angle")
          cTmp2.Add(0.0, "end_angle")
        Endif

      Case "INSERT"

        If cTmp.Exist("block") Then
          cTmp2.Add(cTmp["block"], "block")
        Else
          cTmp2.Add("", "block")
        Endif

        If cTmp.Exist("angle") Then
          flo = vag.CFloat(cTmp["angle"])
          cTmp2.Add(flo, "angle")
        Else
          cTmp2.Add(0.0, "angle")
        Endif

        If cTmp.Exist("scalex") Then
          flo = vag.CFloat(cTmp["scalex"])
          sx = flo
        Else
          sx = 1.0
        Endif

        If cTmp.Exist("scaley") Then
          flo = vag.CFloat(cTmp["scaley"])
          sy = flo
        Else
          sy = 1.0
        Endif

        If cTmp.Exist("scalez") Then
          flo = vag.CFloat(cTmp["scalez"])
          sz = flo
        Else
          sz = 1.0
        Endif

        cTmp2.Add([sx, sy, sz], "scale")

        If cTmp.Exist("columns") Then
          cTmp2.Add(CInt(cTmp["columns"]), "co")
        Else
          cTmp2.Add(1, "co")
        Endif

        If cTmp.Exist("rows") Then
          int = vag.CInt(cTmp["rows"])
          cTmp2.Add(int, "ro")
        Else
          cTmp2.Add(1, "ro")
        Endif

        If cTmp.Exist("cspace") Then
          flo = vag.CFloat(cTmp["cspace"])
          cTmp2.Add(flo, "cs")
        Else
          cTmp2.Add(0.0, "cs")
        Endif

      Case "TEXT"
        For Each tg In cTmp

          Select cTmp.Key

            Case "texth"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "height")
            Case "text"
              cTmp2.Add(CStr(tg), "text")
            Case "hjust"
              int = vag.CInt(tg)
              cTmp2.Add(int, "just_h")

            Case "vjust"
              int = vag.CInt(tg)
              cTmp2.Add(int, "just_v")

            Case "angle"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "angle")

            Case "wfactor"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "wfactor")

            Case "tstyle"
              cTmp2.Add(CStr(tg), "font")

            Case "oblique"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "oblique")

          End Select
        Next

        If cTmp2.Exist("angle") = False Then
          cTmp2.Add(0, "angle")
        Endif

      Case "MTEXT"
        For Each tg In cTmp

          Select cTmp.Key

            Case "texth"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "height")
            Case "text"
              If cTmp.Exist("text2") Then
                cTmp2.Add(CStr(tg) & cTmp["text2"], "text")
              Else
                cTmp2.Add(CStr(tg), "text")
              Endif

            Case "angle"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "angle")

          End Select
        Next

        If cTmp2.Exist("angle") = False Then
          cTmp2.Add(0, "angle")
        Endif

      Case Else
        For Each tg In cTmp
          cTmp2.Add(tg, cTmp.Key)
        Next
    End Select

    cTmp2.Add(0, "linewt")

    Return cTmp2
  Else
    Return cTmp
  Endif

End

''Creates a collection With the entities that make up a block.

Private Function DXFDecodeBlock(sItem As String) As Collection

  Dim sCont As String
  Dim btx As String[]
  Dim raw As New Collection       '' List all the entities including the block and endblk at the same level
  Dim out As New Collection       '' List returned by the function that represent the block and its contents
  Dim parts As New Collection     '' List of all entities in the block
  Dim i As Integer
  Dim cTmp As Collection
  Dim cEnty As Collection
  Dim eN As Variant
  Dim rw As Variant
  Dim bl As Variant

  cEnty = DWGEntityList()

  sCont = Replace(sItem, "\t", " ")

  For Each eN In cEnty
    sCont = Replace(sCont, "  0\n" & cEnty.Key & "\n  5\n", "\t  0\n" & cEnty.Key & "\n  5\n")
  Next

  btx = Split(sCont, "\t")

  For i = 0 To btx.Max
    If InStr(btx[i], "100\nAcDbEntity") > 0 Then
      cTmp = DXFDecodeItem(btx[i])

      If cTmp.Count > 0 Then
        If cTmp.Exist("handle") Then
          raw.Add(cTmp.Copy(), cTmp["handle"])
        Endif
      Endif

      cTmp.Clear
    Endif

  Next
  cTmp.Clear
  For Each rw In raw
    Select rw["entity"]
      Case "BLOCK"
        For Each bl In rw
          out.Add(bl, rw.Key)
        Next

      Case Else

        For Each bl In rw
          cTmp.Add(bl, rw.Key)
        Next
        parts.Add(cTmp.Copy(), rw["handle"])
        cTmp.Clear

    End Select
  Next

  If parts.Count > 0 Then
    out.Add(parts.Copy(), "Entities")
  Endif

  Return out

End

'' Create a list with the information it decodes from a DXF entity.

Public Function DXFDecodeItem(sItem As String) As Collection

  Dim stx As String[]
  Dim cTmp As New Collection
  Dim i As Integer
  Dim vrt As Variant
  Dim sTag As String
  Dim codes As Collection
  Dim sVal As String
  Dim sKey As String
  Dim cPts As New Collection
  Dim p As Variant
  Dim df As Variant
  Dim defaults As New Collection
  Dim str As String

  stx = Split(sItem, "\n")

  If stx[0] = "  0" Then
    sTag = "entity"
    sVal = stx[1]
    If sVal = "LWPOLYLINE" Then
      Print "x"
    Endif
    cTmp.Add(sVal, sTag)
    codes = DXFEntityCodes(sVal)
    defaults = DXFEntityDefaults(sVal)
  Endif

  For i = 0 To stx.Max - 1 Step 2
    sKey = Replace(stx[i], " ", "")
    sTag = sKey
    Select sKey
      Case "1", "3", "5", "6", "8"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)
      Case "70", "62", "66", "370", "280", "290", "380", "90"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        str = Replace(stx[i + 1], " ", "")
        vrt = CInt(str)
        cTmp.Add(vrt, sTag)

      Case "40", "50", "41", "42", "43"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        str = Replace(stx[i + 1], " ", "")

        vrt = vag.CFloat(str)
        cTmp.Add(vrt, sTag)
      Case "10", "20", "30", "11", "21", "31" ' coordenadas habituales
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)

      Case "12", "22", "32", "13", "23", "33" ' coordenadas extras
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)

      Case "14", "24", "34", "15", "25", "35" ' coordenadas de dimensiones

      Case "16", "26", "36", "17", "27", "37" ' coordenadas de dimensiones

      Case "100"
        'skip

      Case Else
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif

        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)

    End Select
  Next

  'Check defalults
  For Each df In defaults
    If codes.Exist(defaults.Key) Then
      sTag = codes[defaults.Key]
    Else
      sTag = defaults.Key
    Endif
    If cTmp.Exist(sTag) = False Then
      cTmp.Add(df, sTag)
    Endif

  Next

  cPts = DXFDecodeCoords(sItem)

  If cPts Then
    For Each p In cPts
      cTmp.Add(p.Copy(), cPts.Key)
    Next
  Endif

  Return cTmp

End

'' Create a list with the coords decodes from a DXF entity.

Public Function DXFDecodeCoords(sItem As String) As Collection

  Dim stx As String[]
  Dim c As New Collection
  Dim p As New Collection
  Dim i As Integer
  Dim vrt As Variant
  Dim sTag As String
  Dim codes As Collection
  Dim sVal As String
  Dim sKey As String
  Dim rep As New Collection
  Dim spt As New String[]
  Dim e As Variant
  Dim xTag As String
  Dim xOrd As String
  Dim pt As Variant
  Dim cp As Collection
  Dim ptx As New String[]
  Dim k As Integer
  Dim tp As String
  Dim str As String

  stx = Split(sItem, "\n")

  ptx = ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"]

  If stx[0] = "  0" Then
    sVal = stx[1]
    codes = DXFEntityCodes(sVal)
  Endif

  For i = 0 To stx.Max - 1 Step 2
    sKey = Replace(stx[i], " ", "")
    Select sKey

      Case "10", "20", "30", "11", "21", "31", "12", "22", "32", "13", "23", "33", "14", "24", "34", "15", "25", "35", "16", "26", "36", "17", "27", "37"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Else
          sTag = sKey
        Endif

        str = Replace(stx[i + 1], " ", "")
        vrt = vag.CFloat(str)
        c.Add(vrt, sTag)
    End Select
  Next

  For i = 0 To stx.Max Step 2
    If stx[i] <> "" Then
      sTag = Replace(stx[i], " ", "")
      If codes.Exist(sTag) Then
        sTag = codes[sTag]
      Endif
      If rep.Exist(sTag) = False Then
        rep.Add([1, 0], sTag)
      Else
        rep[sTag][0] = rep[sTag][0] + 1
      Endif
    Endif
  Next

  For i = 0 To stx.Max Step 2
    sKey = Replace(stx[i], " ", "")
    Select sKey

      Case "10", "20", "30", "11", "21", "31", "12", "22", "32", "13", "23", "33", "14", "24", "34", "15", "25", "35", "16", "26", "36", "17", "27", "37"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Else
          sTag = sKey
        Endif
        str = Replace(stx[i + 1], " ", "")
        vrt = vag.CFloat(str)
        If rep.Exist(sTag) And rep[sTag][0] > 1 Then
          rep[sTag][1] = rep[sTag][1] + 1
          c.Add(vrt, sTag & "." & CStr(rep[sTag][1]))
        Else
          c.Add(vrt, sTag)
        Endif
    End Select
  Next

  If c.Exist("x0") Or c.Exist("x0.1") Then
    spt.Clear
    For Each e In c
      For Each tp In ptx
        If InStr(c.Key, tp) > 0 Then

          If InStr(c.Key, ".") > 0 Then
            xTag = Split(c.Key, ".")[0]
            xOrd = "." & Split(c.Key, ".")[1]
          Else
            xTag = c.Key
            xOrd = ""
          Endif

          If ptx.Exist(xTag) Then
            k = ptx.Find(xTag)
            pt = c[c.Key]
            If c.Exist("y" & CStr(k) & xOrd) Then
              pt &= ":" & c["y" & CStr(k) & xOrd]
            Endif
            If c.Exist("z" & CStr(k) & xOrd) Then
              pt &= ":" & c["z" & CStr(k) & xOrd]
            Endif
            spt.Add(pt)
          Endif
        Endif
      Next
    Next
    cp = GauchoEncodePoint(spt.Join(";"), "p")
    p.Add(cp.Copy(), "p")
    cp.Clear
  Endif
  Return p

End

'' Create a list with the headers decodes from a DXF entity.

Private Function DXFDecodeHeader(sItem As String) As Collection

  Dim stx As String[]
  Dim cTmp As New Collection
  Dim i As Integer
  Dim vrt As Variant
  Dim sTag As String
  Dim x As Float
  Dim y As Float
  Dim z As Float

  stx = Split(sItem, "\n")

  If stx.Count = 4 Then
    sTag = stx[0]

    If InStr(sTag, "INTERFERECOLOR") > 0 Then
      Print "milestone"
    Endif

    For i = 1 To stx.Max Step 2
      Select Replace(stx[i], " ", "")
        Case "1", "2", "3", "5", "6", "7" "8"
          vrt = vag.CFloat(stx[i] + 1)
        Case "70", "62", "370", "280", "290", "380", "390"
          vrt = vag.CInt(stx[i] + 1)
        Case "345", "346", "349"
          vrt = stx[i + 1]
        Case "40", "50"
          vrt = vag.CFloat(stx[i] + 1)

        Case "10"
          vrt = vag.CFloat(stx[i] + 1)

          If Replace(stx[i + 2], " ", "") = "20" Then
            y = vag.CFloat(stx[i] + 3)

          Endif

          If Replace(stx[i + 4], " ", "") = "30" Then
            z = vag.CFloat(stx[i] + 5)
          Endif
          vrt = [x, y, z]
      End Select
      If vrt Then
        cTmp.Add(vrt, sTag)
        Print "Ok : " & sTag
      Else
        Print "Error in : " & sTag
      Endif
    Next
  Endif

  Return cTmp

End
