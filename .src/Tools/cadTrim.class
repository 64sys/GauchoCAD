' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Inherits ToolsBase
Create Static
Public Const Gender As String = "Trim"

Public arrTijeras As New Integer[]
Public eRecortar As Entity

Public Function Start(Optional ElemToBuild As Variant, Optional _Mode As Integer = 0) As Boolean
    ' Llamada por FCAD al inicio de la aplicacion de esta herramienta

    Dim i As Integer
    ' Aprovechamos para establecer los helpers (comentarios de ayuda en pantalla)
    Me.PointsDone = 0
    Me.PointsTotal = 2

    clsDrawingAids.HelperTrabajo = ("Trim ")
    gcd.clsJob.EntityChecking = True

    ' chequeamos si hubo seleccion previa
    Me.SelectionCount = clsEntities.GetSelectionCount()

    If Me.SelectionCount = 0 Then                                     ' we have no elements in the selection
        arrTijeras.Clear
        clsDrawingAids.Helper.texto = clsDrawingAids.HelperTrabajo & (": Select cutting edges")

        gcd.clsJobPrevious = Me
        gcd.clsJob = clsDefaultJob

    Else                                                               ' TENEMOS QUE PEDIR MAS ENTIDADES PARA CORTAR

        ' recolecto las tijeras
        For i = 0 To appmain.hFCAD.arrEntities.Max
            If appmain.hFCAD.arrEntities[i].selected Then arrTijeras.Add(i)
        Next

        '
        clsDrawingAids.Helper.texto = clsDrawingAids.HelperTrabajo & (": entities to cut")
        'clsDrawingAids.HelperTrabajo = clsDrawingAids.HelperTrabajo & Str(Me.SelectionCount) & (" elements")

    Endif

    gcd.ToolActive = True

End

Public Function MouseDown(mouseX As Integer, mouseY As Integer)

    Dim i As Integer, eTijera As Entity, v1, v2, flxIntersec As New Float[]

    Me.SelEndXr = appmain.hFcad.Xreal(mouseX)
    Me.SelEndyr = appmain.hFcad.Yreal(mouseY)
    If Mouse.Left Then

        If appmain.hFcad.iEntity[3] >= 0 Then

            Me.eRecortar = appmain.hFCAD.arrEntities[appmain.hFcad.iEntity[3]]
            Select Case eRecortar.Gender
                Case "Line"
                    DoTrimLine
                Case "Pline"
                    DoTrimPline
            End Select

            Me.Active = False

        Else

            Me.Active = True
        End If
    End If

End

Public Sub Draw() ' esta rutina es llamada por FCAD en el evento DrawingArea_Draw
    ' por ultimo, y para que se vea arriba, la seleccion

    If Me.Active Then

        If Me.SelStartX > Me.SelEndX Then                               ' Seleccion crossing, o sea que si cualquier arista del rectangulo cruza el bounding poligon, queda seleccionado

            GLplus.Rectangle2D(Me.SelStartXr, Me.SelStartYr, Me.SelEndXr - Me.SelStartXr, Me.SelEndyr - Me.SelStartYr, Color.RGB(224, 220, 207, 215),,,, Color.red, 1, 1, 2)

        Else                                                            ' seleccion full, todos los puntos deben estar adentro

            GLplus.Rectangle2D(Me.SelStartXr, Me.SelStartYr, Me.SelEndXr - Me.SelStartXr, Me.SelEndyr - Me.SelStartYr, Color.RGB(224, 220, 207, 215),,,, Color.Green, 1, 1, 2)

        End If
    Else

        ' gl.CallList(appmain.hFCAD.GlListSelectedEntities)
        ' clsEntities.DrawPoiSymbolsAll

    End If

End

Public Function MouseUp(mouseX As Integer, mouseY As Integer) ' called by FCAD-> DrawingArea_MouseUp

    If Mouse.Left Then

        Me.SelEndX = mouseX
        Me.SelEndy = mouseY

        If Me.Active Then
            Dim Crossing As Boolean = False
            ' corrijo para start<end
            Me.Active = False
            If Me.SelStartX > Me.SelEndX Then
                crossing = True
                Swap Me.SelStartX, Me.SelEndX
            Else
                crossing = False
            End If
            If Me.SelStartY < Me.SelEndy Then Swap Me.SelStartY, Me.SelEndy                     ' this is FLIPPED

            ' Paso a coordenadas reales
            Me.SelStartXr = appmain.hFcad.Xreal(Me.SelStartX)
            Me.SelStartYr = appmain.hFcad.Yreal(Me.SelStartY)
            Me.SelEndXr = appmain.hFcad.Xreal(Me.SelEndX)
            Me.SelEndyr = appmain.hFcad.Yreal(Me.SelEndy)

            ' veo si el rectangulo es suficientemente grande como para representar una seleccion por rectangulo
            If (Me.SelEndX - Me.SelStartX + (-Me.SelEndy + Me.SelStartY)) > 10 Then

                Me.selectionCount = clsEntities.SelectionSquare(Me.SelStartXr, Me.SelStartYr, Me.SelEndXr, Me.SelEndyr,, crossing)
                Appmain.hFCAD.regen

            End If

            clsDrawingAids.HelperTrabajo = ("Selected ") & Str$(Me.selectionCount) & (" elements")

            '     'aprovecho para ver si hay algo util en la seleccion
            '
            ' Select Case Me.Mode
            '
            '     Case 0 ' Move, all vertices must be selected
            '        clsDrawingAids.HelperTrabajo = ("Selected ") & Str$(clsEntities.DeSelection("todo", "mover")) & (" elements")
            '
            '     Case 1 ' Stretch
            '         clsDrawingAids.HelperTrabajo = ("Selected ") & Str$(clsEntities.DeSelection("todo", "estirar")) & (" elements")
            '
            ' End Select
        Else

        End If

    Else

        Me.Finish

    Endif

End

'' Esta sub recorta una cosa con otras cosas
Public Sub DoTrimLine()

    Dim i, iii As Integer, v1, v2, flxIntersecMin, flxIntersec As New Float[], dIntersect, dIntersectMin As Float = 1e20
    Dim flxObjeto, flxTijera As Float[]
    Dim s1 As Integer
    Dim Xcorte As Float
    Dim eTijera, eNewPart As Entity

    Dim C1x, C1y, C2x, C2y As Float ' candidatos al recorte, C1 es el que esta mas cerca de P01 y C2 de P23
    Dim Ycorte As Float

    Xcorte = Me.SelEndXr
    Ycorte = Me.SelEndyr

    ' debo encontrar los puntos de corte mas cercanos a cada lado del punto que esta sobre la entidad a recortar
    C1x = eRecortar.p[0]
    C1y = eRecortar.p[1]        ' inicialmente estan en los limites
    C2x = eRecortar.p[2]
    C2y = eRecortar.p[3]

    For iii = 0 To Me.arrTijeras.Max
        eTijera = appmain.hFCAD.arrEntities[iii]
        Select Case eTijera.Gender
            Case "Line"
                If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.p[0], eTijera.p[1], eTijera.p[2], eTijera.p[3]) Then

                    ' obtengo el punto de interseccion
                    flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.p[0], eTijera.p[1]], [eTijera.p[2], eTijera.p[3]])

                    ' ahora veo cual es el lado a recortar
                    ' necesito encontrar los vectores, si van en direccion contraria, es el punto a recortar
                    '       P1------X--------------|----------------P2
                    '            click           tijera

                    If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                        ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                        If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                            C1x = flxIntersec[0]
                            C1y = flxIntersec[1]
                        End If

                    Endif

                    ' lo mismo para P23
                    If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                        ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                        If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                            C2x = flxIntersec[0]
                            C2y = flxIntersec[1]
                        End If

                    Endif

                Endif
            Case "PLine"

                For i = 0 To eTijera.p.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                    If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.p[i + 0], eTijera.p[i + 1], eTijera.p[i + 2], eTijera.p[i + 3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.p[i + 0], eTijera.p[i + 1]], [eTijera.p[i + 2], eTijera.p[i + 3]])

                        If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif

                Next

            Case "Text", "MText"

                For i = 0 To eTijera.Polygon.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                    If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.polygon[i + 0], eTijera.polygon[i + 1], eTijera.polygon[i + 2], eTijera.polygon[i + 3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.polygon[i + 0], eTijera.polygon[i + 1]], [eTijera.polygon[i + 2], eTijera.polygon[i + 3]])

                        If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif

                Next
            Case "Arc", "Ellipse", "Circle"

                For i = 0 To eTijera.polyline.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                    If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.polyline[i + 0], eTijera.polyline[i + 1], eTijera.polyline[i + 2], eTijera.polyline[i + 3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.polyline[i + 0], eTijera.polyline[i + 1]], [eTijera.polyline[i + 2], eTijera.polyline[i + 3]])

                        If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif

                Next
        End Select
    Next
    ' termine la busqueda de puntos de recorte
    'ahora recorto la entidad
    ' primer o determino si debo partir la entidad o si solo se recorta
    If (eRecortar.p[0] = C1x) And (eRecortar.p[1] = C1y) And (eRecortar.p[2] = C2x) And (eRecortar.p[3] = C2y) Then
        ' este entidad no sera recortada

    Else If (eRecortar.p[0] = C1x) And (eRecortar.p[1] = C1y) Then ' elimino el tramo P01 - C2

        eRecortar.p[0] = C2x
        eRecortar.p[1] = C2y

    Else If (eRecortar.p[2] = C2x) And (eRecortar.p[3] = C2y) Then ' elimino el tramo p23 - C1

        eRecortar.p[2] = C1x
        eRecortar.p[3] = C1y

    Else ' se parte en dos la entidad

        eNewPart = clsEntities.ClonEntity(eRecortar)          ' primero la clono
        eNewPart.p[0] = C2x
        eNewPart.p[1] = C2y

        ' tareas finales en las entidades
        eNewPart.ClassHandler.finish(eNewPart)
        appmain.hFCAD.arrEntities.Add(eNewPart)                ' la agrego al dibujo

        eRecortar.p[2] = C1x
        eRecortar.p[3] = C1y
        eRecortar.ClassHandler.finish(eRecortar)                ' para regenerar los POI

        ' regenro las listas openGL de ambas entidades
        'clsEntities.glGenDrawList(appmain.hFcad.iEntity[3])
        'clsEntities.glGenDrawList(appmain.hFCAD.arrEntities.max)
        'clsEntities.glGenDrawListAll
        gcd.Regen
    End If

End

'' Esta sub recorta una cosa con otras cosas
Public Sub DoTrimPline()

    Dim i, iii As Integer, v1, v2, flxIntersecMin, flxIntersec As New Float[], dIntersect, dIntersectMin As Float = 1e20
    Dim flxObjeto, flxTijera As Float[]
    Dim s1 As Integer
    Dim Xcorte As Float
    Dim eTijera, eNewPart As Entity

    Dim C1x, C1y, C2x, C2y As Float ' candidatos al recorte, C1 es el que esta mas cerca de P01 y C2 de P23
    Dim TramoC1, TramoC2 As Integer ' tramos donde estan los puntos para recortar
    Dim T1x, T1y, T2x, T2y As Float ' puntos del tramo en cuestion
    Dim Ycorte As Float
    Dim TramoCorte, t, tramo As Integer

    Xcorte = Me.SelEndXr
    Ycorte = Me.SelEndyr

    ' necesito encontrar el tramo donde esta el punto
    TramoCorte = puntos.inPolySegment(eRecortar.p, Xcorte, Ycorte)

    ' debo encontrar los puntos de corte mas cercanos a cada lado del punto que esta sobre la entidad a recortar
    C1x = eRecortar.p[0]
    C1y = eRecortar.p[1]        ' inicialmente estan en los limites
    C2x = eRecortar.p[eRecortar.p.Max - 1]
    C2y = eRecortar.p[eRecortar.p.Max]

    TramoC1 = 0                         ' y los tramos en el primero y el ultimo
    TramoC2 = eRecortar.p.Count / 2

    For t = 0 To eRecortar.p.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea
        Tramo = t / 2
        T1x = eRecortar.p[t + 0]
        T1y = eRecortar.p[t + 1]
        T2x = eRecortar.p[t + 2]
        T2y = eRecortar.p[t + 3]

        For iii = 0 To Me.arrTijeras.Max
            eTijera = appmain.hFCAD.arrEntities[iii]
            Select Case eTijera.Gender
                Case "Line"
                    If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.p[0], eTijera.p[1], eTijera.p[2], eTijera.p[3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.p[0], eTijera.p[1]], [eTijera.p[2], eTijera.p[3]])

                        ' ahora veo cual es el lado a recortar
                        ' necesito encontrar los vectores, si van en direccion contraria, es el punto a recortar
                        '       P1------X--------------|----------------P2
                        '            click           tijera

                        If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif
                Case "PLine"

                    For i = 0 To eTijera.p.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                        If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.p[i + 0], eTijera.p[i + 1], eTijera.p[i + 2], eTijera.p[i + 3]) Then

                            ' obtengo el punto de interseccion
                            flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.p[i + 0], eTijera.p[i + 1]], [eTijera.p[i + 2], eTijera.p[i + 3]])

                            If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                    C1x = flxIntersec[0]
                                    C1y = flxIntersec[1]
                                End If

                            Endif

                            ' lo mismo para P23
                            If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                    C2x = flxIntersec[0]
                                    C2y = flxIntersec[1]
                                End If

                            Endif

                        Endif

                    Next

                Case "Text", "MText"

                    For i = 0 To eTijera.Polygon.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                        If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.polygon[i + 0], eTijera.polygon[i + 1], eTijera.polygon[i + 2], eTijera.polygon[i + 3]) Then

                            ' obtengo el punto de interseccion
                            flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.polygon[i + 0], eTijera.polygon[i + 1]], [eTijera.polygon[i + 2], eTijera.polygon[i + 3]])

                            If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                    C1x = flxIntersec[0]
                                    C1y = flxIntersec[1]
                                End If

                            Endif

                            ' lo mismo para P23
                            If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                    C2x = flxIntersec[0]
                                    C2y = flxIntersec[1]
                                End If

                            Endif

                        Endif

                    Next
                Case "Arc", "Ellipse", "Circle"

                    For i = 0 To eTijera.polyline.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                        If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.polyline[i + 0], eTijera.polyline[i + 1], eTijera.polyline[i + 2], eTijera.polyline[i + 3]) Then

                            ' obtengo el punto de interseccion
                            flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.polyline[i + 0], eTijera.polyline[i + 1]], [eTijera.polyline[i + 2], eTijera.polyline[i + 3]])

                            If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                    C1x = flxIntersec[0]
                                    C1y = flxIntersec[1]
                                End If

                            Endif

                            ' lo mismo para P23
                            If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                    C2x = flxIntersec[0]
                                    C2y = flxIntersec[1]
                                End If

                            Endif

                        Endif

                    Next
            End Select
        Next
        ' termine la busqueda de puntos de recorte
        'ahora recorto la entidad
        ' primer o determino si debo partir la entidad o si solo se recorta
        If (T1x = C1x) And (T1y = C1y) And (T2x = C2x) And (T2y = C2y) Then
            ' este entidad no sera recortada

        Else If (T1x = C1x) And (T1y = C1y) Then ' elimino el tramo P01 - C2

            T1x = C2x
            T1y = C2y

        Else If (T2x = C2x) And (T2y = C2y) Then ' elimino el tramo p23 - C1

            T2x = C1x
            T2y = C1y

        Else ' se parte en dos la entidad

            eNewPart = clsEntities.ClonEntity(eRecortar)          ' primero la clono
            eNewPart.p[0] = C2x
            eNewPart.p[1] = C2y

            ' tareas finales en las entidades
            eNewPart.ClassHandler.finish(eNewPart)
            appmain.hFCAD.arrEntities.Add(eNewPart)                ' la agrego al dibujo

            T2x = C1x
            T2y = C1y
            eRecortar.ClassHandler.finish(eRecortar)                ' para regenerar los POI

            ' regenro las listas openGL de ambas entidades
            'clsEntities.glGenDrawList(appmain.hFcad.iEntity[3])
            'clsEntities.glGenDrawList(appmain.hFCAD.arrEntities.max)
            'clsEntities.glGenDrawListAll
            gcd.Regen
        End If
    Next

End

'' Esta sub recorta una cosa con otras cosas
Public Sub DoTrimCircle()

    Dim i, iii As Integer, v1, v2, flxIntersecMin, flxIntersec As New Float[], dIntersect, dIntersectMin As Float = 1e20
    Dim flxObjeto, flxTijera As Float[]
    Dim s1 As Integer
    Dim Xcorte As Float
    Dim eTijera, eNewPart As Entity

    Dim C1x, C1y, C2x, C2y As Float ' candidatos al recorte, C1 es el que esta mas cerca de P01 y C2 de P23
    Dim TramoC1, TramoC2 As Integer ' tramos donde estan los puntos para recortar
    Dim T1x, T1y, T2x, T2y As Float ' puntos del tramo en cuestion
    Dim Ycorte As Float
    Dim TramoCorte, t, tramo As Integer

    Xcorte = Me.SelEndXr
    Ycorte = Me.SelEndyr

    ' necesito encontrar el tramo donde esta el punto
    TramoCorte = puntos.inPolySegment(eRecortar.p, Xcorte, Ycorte)

    ' debo encontrar los puntos de corte mas cercanos a cada lado del punto que esta sobre la entidad a recortar
    C1x = eRecortar.p[0]
    C1y = eRecortar.p[1]        ' inicialmente estan en los limites
    C2x = eRecortar.p[eRecortar.p.Max - 1]
    C2y = eRecortar.p[eRecortar.p.Max]

    TramoC1 = 0                         ' y los tramos en el primero y el ultimo
    TramoC2 = eRecortar.p.Count / 2

    For t = 0 To eRecortar.p.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea
        Tramo = t / 2
        T1x = eRecortar.p[t + 0]
        T1y = eRecortar.p[t + 1]
        T2x = eRecortar.p[t + 2]
        T2y = eRecortar.p[t + 3]

        For iii = 0 To Me.arrTijeras.Max
            eTijera = appmain.hFCAD.arrEntities[iii]
            Select Case eTijera.Gender
                Case "Line"
                    If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.p[0], eTijera.p[1], eTijera.p[2], eTijera.p[3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.p[0], eTijera.p[1]], [eTijera.p[2], eTijera.p[3]])

                        ' ahora veo cual es el lado a recortar
                        ' necesito encontrar los vectores, si van en direccion contraria, es el punto a recortar
                        '       P1------X--------------|----------------P2
                        '            click           tijera

                        If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif
                Case "PLine"

                    For i = 0 To eTijera.p.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                        If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.p[i + 0], eTijera.p[i + 1], eTijera.p[i + 2], eTijera.p[i + 3]) Then

                            ' obtengo el punto de interseccion
                            flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.p[i + 0], eTijera.p[i + 1]], [eTijera.p[i + 2], eTijera.p[i + 3]])

                            If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                    C1x = flxIntersec[0]
                                    C1y = flxIntersec[1]
                                End If

                            Endif

                            ' lo mismo para P23
                            If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                    C2x = flxIntersec[0]
                                    C2y = flxIntersec[1]
                                End If

                            Endif

                        Endif

                    Next

                Case "Text", "MText"

                    For i = 0 To eTijera.Polygon.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                        If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.polygon[i + 0], eTijera.polygon[i + 1], eTijera.polygon[i + 2], eTijera.polygon[i + 3]) Then

                            ' obtengo el punto de interseccion
                            flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.polygon[i + 0], eTijera.polygon[i + 1]], [eTijera.polygon[i + 2], eTijera.polygon[i + 3]])

                            If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                    C1x = flxIntersec[0]
                                    C1y = flxIntersec[1]
                                End If

                            Endif

                            ' lo mismo para P23
                            If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                    C2x = flxIntersec[0]
                                    C2y = flxIntersec[1]
                                End If

                            Endif

                        Endif

                    Next
                Case "Arc", "Ellipse", "Circle"

                    For i = 0 To eTijera.polyline.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                        If puntos.doIntersect(T1x, T1y, T2x, T2y, eTijera.polyline[i + 0], eTijera.polyline[i + 1], eTijera.polyline[i + 2], eTijera.polyline[i + 3]) Then

                            ' obtengo el punto de interseccion
                            flxIntersec = puntos.lineLineIntersection([T1x, T1y], [T2x, T2y], [eTijera.polyline[i + 0], eTijera.polyline[i + 1]], [eTijera.polyline[i + 2], eTijera.polyline[i + 3]])

                            If puntos.distancia(T1x, T1y, Xcorte, Ycorte) > puntos.distancia(T1x, T1y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                    C1x = flxIntersec[0]
                                    C1y = flxIntersec[1]
                                End If

                            Endif

                            ' lo mismo para P23
                            If puntos.distancia(T2x, T2y, Xcorte, Ycorte) > puntos.distancia(T2x, T2y, flxIntersec[0], flxIntersec[1]) Then

                                ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                                If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                    C2x = flxIntersec[0]
                                    C2y = flxIntersec[1]
                                End If

                            Endif

                        Endif

                    Next
            End Select
        Next
        ' termine la busqueda de puntos de recorte
        'ahora recorto la entidad
        ' primer o determino si debo partir la entidad o si solo se recorta
        If (T1x = C1x) And (T1y = C1y) And (T2x = C2x) And (T2y = C2y) Then
            ' este entidad no sera recortada

        Else If (T1x = C1x) And (T1y = C1y) Then ' elimino el tramo P01 - C2

            T1x = C2x
            T1y = C2y

        Else If (T2x = C2x) And (T2y = C2y) Then ' elimino el tramo p23 - C1

            T2x = C1x
            T2y = C1y

        Else ' se parte en dos la entidad

            eNewPart = clsEntities.ClonEntity(eRecortar)          ' primero la clono
            eNewPart.p[0] = C2x
            eNewPart.p[1] = C2y

            ' tareas finales en las entidades
            eNewPart.ClassHandler.finish(eNewPart)
            appmain.hFCAD.arrEntities.Add(eNewPart)                ' la agrego al dibujo

            T2x = C1x
            T2y = C1y
            eRecortar.ClassHandler.finish(eRecortar)                ' para regenerar los POI

            ' regenro las listas openGL de ambas entidades
            'clsEntities.glGenDrawList(appmain.hFcad.iEntity[3])
            'clsEntities.glGenDrawList(appmain.hFCAD.arrEntities.max)
            'clsEntities.glGenDrawListAll
            gcd.Regen
        End If
    Next

End

'' Esta sub recorta una cosa con otras cosas
Public Sub DoTrimArc()

    Dim i, iii As Integer, v1, v2, flxIntersecMin, flxIntersec As New Float[], dIntersect, dIntersectMin As Float = 1e20
    Dim flxObjeto, flxTijera As Float[]
    Dim s1 As Integer
    Dim Xcorte As Float
    Dim eTijera, eNewPart As Entity

    Dim C1x, C1y, C2x, C2y As Float ' candidatos al recorte, C1 es el que esta mas cerca de P01 y C2 de P23
    Dim Ycorte As Float

    Xcorte = Me.SelEndXr
    Ycorte = Me.SelEndyr

    ' debo encontrar los puntos de corte mas cercanos a cada lado del punto que esta sobre la entidad a recortar
    C1x = eRecortar.p[0]
    C1y = eRecortar.p[1]        ' inicialmente estan en los limites
    C2x = eRecortar.p[2]
    C2y = eRecortar.p[3]

    For iii = 0 To Me.arrTijeras.Max
        eTijera = appmain.hFCAD.arrEntities[iii]
        Select Case eTijera.Gender
            Case "Line"
                If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.p[0], eTijera.p[1], eTijera.p[2], eTijera.p[3]) Then

                    ' obtengo el punto de interseccion
                    flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.p[0], eTijera.p[1]], [eTijera.p[2], eTijera.p[3]])

                    ' ahora veo cual es el lado a recortar
                    ' necesito encontrar los vectores, si van en direccion contraria, es el punto a recortar
                    '       P1------X--------------|----------------P2
                    '            click           tijera

                    If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                        ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                        If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                            C1x = flxIntersec[0]
                            C1y = flxIntersec[1]
                        End If

                    Endif

                    ' lo mismo para P23
                    If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                        ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                        If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                            C2x = flxIntersec[0]
                            C2y = flxIntersec[1]
                        End If

                    Endif

                Endif
            Case "PLine"

                For i = 0 To eTijera.p.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                    If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.p[i + 0], eTijera.p[i + 1], eTijera.p[i + 2], eTijera.p[i + 3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.p[i + 0], eTijera.p[i + 1]], [eTijera.p[i + 2], eTijera.p[i + 3]])

                        If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif

                Next

            Case "Text", "MText"

                For i = 0 To eTijera.Polygon.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                    If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.polygon[i + 0], eTijera.polygon[i + 1], eTijera.polygon[i + 2], eTijera.polygon[i + 3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.polygon[i + 0], eTijera.polygon[i + 1]], [eTijera.polygon[i + 2], eTijera.polygon[i + 3]])

                        If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif

                Next
            Case "Arc", "Ellipse", "Circle"

                For i = 0 To eTijera.polyline.count - 4 Step 2         ' Idem linea, pero  para todos los tramos de la polilinea

                    If puntos.doIntersect(eRecortar.p[0], eRecortar.p[1], eRecortar.p[2], eRecortar.p[3], eTijera.polyline[i + 0], eTijera.polyline[i + 1], eTijera.polyline[i + 2], eTijera.polyline[i + 3]) Then

                        ' obtengo el punto de interseccion
                        flxIntersec = puntos.lineLineIntersection([eRecortar.p[0], eRecortar.p[1]], [eRecortar.p[2], eRecortar.p[3]], [eTijera.polyline[i + 0], eTijera.polyline[i + 1]], [eTijera.polyline[i + 2], eTijera.polyline[i + 3]])

                        If puntos.distancia(eRecortar.p[0], eRecortar.p[1], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[0], eRecortar.p[1], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la izq del click, entonces lo asignamos a C1, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C1x, C1y, Xcorte, Ycorte) Then
                                C1x = flxIntersec[0]
                                C1y = flxIntersec[1]
                            End If

                        Endif

                        ' lo mismo para P23
                        If puntos.distancia(eRecortar.p[2], eRecortar.p[3], Xcorte, Ycorte) > puntos.distancia(eRecortar.p[2], eRecortar.p[3], flxIntersec[0], flxIntersec[1]) Then

                            ' el punto encontrado esta a la derecha del click, entonces lo asignamos a C2, pero solo si es mas cercano
                            If puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1]) < puntos.distancia(C2x, C2y, Xcorte, Ycorte) Then
                                C2x = flxIntersec[0]
                                C2y = flxIntersec[1]
                            End If

                        Endif

                    Endif

                Next
        End Select
    Next
    ' termine la busqueda de puntos de recorte
    'ahora recorto la entidad
    ' primer o determino si debo partir la entidad o si solo se recorta
    If (eRecortar.p[0] = C1x) And (eRecortar.p[1] = C1y) And (eRecortar.p[2] = C2x) And (eRecortar.p[3] = C2y) Then
        ' este entidad no sera recortada

    Else If (eRecortar.p[0] = C1x) And (eRecortar.p[1] = C1y) Then ' elimino el tramo P01 - C2

        eRecortar.p[0] = C2x
        eRecortar.p[1] = C2y

    Else If (eRecortar.p[2] = C2x) And (eRecortar.p[3] = C2y) Then ' elimino el tramo p23 - C1

        eRecortar.p[2] = C1x
        eRecortar.p[3] = C1y

    Else ' se parte en dos la entidad

        eNewPart = clsEntities.ClonEntity(eRecortar)          ' primero la clono
        eNewPart.p[0] = C2x
        eNewPart.p[1] = C2y

        ' tareas finales en las entidades
        eNewPart.ClassHandler.finish(eNewPart)
        appmain.hFCAD.arrEntities.Add(eNewPart)                ' la agrego al dibujo

        eRecortar.p[2] = C1x
        eRecortar.p[3] = C1y
        eRecortar.ClassHandler.finish(eRecortar)                ' para regenerar los POI

        ' regenro las listas openGL de ambas entidades
        'clsEntities.glGenDrawList(appmain.hFcad.iEntity[3])
        'clsEntities.glGenDrawList(appmain.hFCAD.arrEntities.max)
        'clsEntities.glGenDrawListAll
        gcd.Regen
    End If

End