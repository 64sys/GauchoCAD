' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Inherits ToolsBase
Create Static
Public Const Gender As String = "Trim"

Public arrTijeras As New Integer[]

Public Function Start(Optional ElemToBuild As Variant, Optional _Mode As Integer = 0) As Boolean
    ' Llamada por FCAD al inicio de la aplicacion de esta herramienta

    ' TODO: remover al seguir con esta herramienta

    Me.Finish

    Return

    Dim i As Integer
    ' Aprovechamos para establecer los helpers (comentarios de ayuda en pantalla)
    Me.PointsDone = 0
    Me.PointsTotal = 2

    clsDrawingAids.HelperTrabajo = ("Trim ")

    ' chequeamos si hubo seleccion previa
    Me.SelectionCount = clsEntities.GetSelectionCount()

    If Me.SelectionCount = 0 Then                                     ' we have no elements in the selection
        arrTijeras.Clear
        clsDrawingAids.Helper.texto = clsDrawingAids.HelperTrabajo & (": Selecct cutting edges")

        modCAD.clsJobPrevious = Me
        modCAD.clsJob = clsDefaultJob

    Else                                                               ' TENEMOS QUE PEDIR MAS ENTIDADES PARA CORTAR

        ' recolecto las tijeras
        For i = 0 To appmain.hFCAD.arrEntities.Max
            If appmain.hFCAD.arrEntities[i].selected Then arrTijeras.Add(i)
        Next

        'clsEntities.BackUp(True)
        clsDrawingAids.Helper.texto = clsDrawingAids.HelperTrabajo & (": entities to cut")
        'clsDrawingAids.HelperTrabajo = clsDrawingAids.HelperTrabajo & Str(Me.SelectionCount) & (" elements")

    Endif

    modCAD.ToolActive = True

End

Public Function MouseDown(mouseX As Integer, mouseY As Integer)

    Dim i As Integer, oTijera As Entity, v1, v2, flxIntersec As New Float[]

    If Mouse.Left Then

        If appmain.hFcad.iEntity[2] >= 0 Then                               ' hay una entidad para recortar

            Select Case appmain.hFcad.oEntity.Gender                  ' tengo que ver cada caso particular
                Case "Line"
                    ' busco las tijeras
                    For i = 0 To arrTijeras.Max
                        'oTijera = appmain.hFCAD.arrEntities[arrTijeras[i]]
                        recortar(appmain.hFCAD.oEntity, appmain.hFcad.iEntity[0], appmain.hFcad.iEntity[1], appmain.hFCAD.arrEntities[arrTijeras[i]])

                    Next
            End Select

            If appmain.hFcad.oEntity.selected Then
                clsEntities.deSelectElem(appmain.hFcad.oEntity)             '   -> la deselecciono
            Else
                clsEntities.SelectElem(appmain.hFcad.oEntity)               '   -> la selecciono
            Endif
            Me.Active = False
            appmain.hFcad.regen

        Else

            Me.SelStartX = mouseX
            Me.SelStartY = mouseY
            Me.SelStartXr = appmain.hFcad.Xreal(Me.SelStartX)
            Me.SelStartYr = appmain.hFcad.Yreal(Me.SelStartY)

            Me.SelEndX = Me.SelStartX
            Me.SelEndy = Me.SelStartY

            Me.Active = True
        End If

    End If

End

Public Function MouseMove(mouseX As Integer, mouseY As Integer) ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseMove

    If Me.Active Then
        Me.SelEndX = mouseX
        Me.SelEndy = mouseY
        Me.SelEndXr = appmain.hFcad.Xreal(Me.SelEndX)
        Me.SelEndyr = appmain.hFcad.Yreal(Me.SelEndy)

        appmain.hFCAD.redraw
    End If

End

Public Function MouseUp(mouseX As Integer, mouseY As Integer) ' called by FCAD-> DrawingArea_MouseUp

    If Mouse.Left Then

        Me.SelEndX = mouseX
        Me.SelEndy = mouseY

        If Me.Active Then
            Dim Crossing As Boolean = False
            ' corrijo para start<end
            Me.Active = False
            If Me.SelStartX > Me.SelEndX Then
                crossing = True
                Swap Me.SelStartX, Me.SelEndX
            Else
                crossing = False
            End If
            If Me.SelStartY < Me.SelEndy Then Swap Me.SelStartY, Me.SelEndy                     ' this is FLIPPED

            Dim tipo As String
            tipo = "nueva"
            If Mouse.Shift Then tipo = "resta" ' estos elementos de la seleccion anterior
            If Mouse.Control Then tipo = "suma" ' elementos a la seleccion anterior

            ' Paso a coordenadas reales
            Me.SelStartXr = appmain.hFcad.Xreal(Me.SelStartX)
            Me.SelStartYr = appmain.hFcad.Yreal(Me.SelStartY)
            Me.SelEndXr = appmain.hFcad.Xreal(Me.SelEndX)
            Me.SelEndyr = appmain.hFcad.Yreal(Me.SelEndy)

            ' veo si el rectangulo es suficientemente grande como para representar una seleccion por rectangulo
            If (Me.SelEndX - Me.SelStartX + (-Me.SelEndy + Me.SelStartY)) > 10 Then

                Me.selectionCount = clsEntities.SelectionSquare(Me.SelStartXr, Me.SelStartYr, Me.SelEndXr, Me.SelEndyr, tipo, crossing)
                Appmain.hFCAD.regen

            End If

            clsDrawingAids.HelperTrabajo = ("Selected ") & Str$(Me.selectionCount) & (" elements")

            '     'aprovecho para ver si hay algo util en la seleccion
            '
            ' Select Case Me.Mode
            '
            '     Case 0 ' Move, all vertices must be selected
            '        clsDrawingAids.HelperTrabajo = ("Selected ") & Str$(clsEntities.DeSelection("todo", "mover")) & (" elements")
            '
            '     Case 1 ' Stretch
            '         clsDrawingAids.HelperTrabajo = ("Selected ") & Str$(clsEntities.DeSelection("todo", "estirar")) & (" elements")
            '
            ' End Select
        Else

        End If

    Else

        Me.Finish

    Endif

End

'' Esta sub recorta una cosa con otra cosa
Public Sub Recortar(oRecortar As Entity, Xcorte As Float, Ycorte As Float, oTijera As Entity)

    Dim i, iii As Integer, v1, v2, flxIntersecMin, flxIntersec As New Float[], dIntersect, dIntersectMin As Float = 1e20
    Dim flxObjeto, flxTijera As Float[]
    Dim s1 As Integer

    Select Case oTijera.Gender
        Case "Line"             ' recorto linea con linea
            If puntos.doIntersect(oRecortar.p[0], oRecortar.p[1], oRecortar.p[2], oRecortar.p[3], oTijera.p[0], oTijera.p[1], oTijera.p[2], oTijera.p[3]) Then

                ' obtengo el punto de interseccion
                flxIntersec = puntos.lineLineIntersection([oRecortar.p[0], oRecortar.p[1]], [oRecortar.p[2], oRecortar.p[3]], [oTijera.p[0], oTijera.p[1]], [oTijera.p[2], oTijera.p[3]])

                ' ahora veo cual es el lado a recortar
                ' necesito encontrar los vectores, si van en direccion contraria, es el punto a recortar
                '       P1------X--------------|----------------P2
                '            click           tijera

                v1.Add(oRecortar.p[0] - Xcorte)
                v1.Add(oRecortar.p[1] - Ycorte)       ' click - P1

                v2.Add(flxIntersec[0] - Xcorte)       ' cick - Tijera
                v2.Add(flxIntersec[1] - Ycorte)

                If Sgn(v1[0]) <> Sgn(v2[0]) Or Sgn(v1[1]) <> Sgn(v2[1]) Then ' van en sentido contrario

                    ' intercambio P1 con Tijera
                    oRecortar.p[0] = flxIntersec[0]
                    oRecortar.p[1] = flxIntersec[1]

                Else
                    ' intercambio P2 con Tijera
                    oRecortar.p[2] = flxIntersec[0]
                    oRecortar.p[3] = flxIntersec[1]

                End If

            Endif
        Case "PLine"
            ' verifico cual punto de interseccion es el mas cercano
            For i = 0 To oTijera.p.count - 4 Step 2         ' para todos los puntos de la polilinea
                If puntos.doIntersect(oRecortar.p[0], oRecortar.p[1], oRecortar.p[2], oRecortar.p[3], oTijera.p[i + 0], oTijera.p[i + 1], oTijera.p[i + 2], oTijera.p[i + 3]) Then

                    ' obtengo el punto de interseccion
                    flxIntersec = puntos.lineLineIntersection([oRecortar.p[0], oRecortar.p[1]], [oRecortar.p[2], oRecortar.p[3]], [oTijera.p[i + 0], oTijera.p[i + 1]], [oTijera.p[i + 2], oTijera.p[i + 3]])

                    ' mido la distancia

                    dIntersect = puntos.distancia(Xcorte, Ycorte, flxIntersec[0], flxIntersec[1])
                    If dIntersect < dIntersectMin Then
                        dIntersectMin = dIntersect
                        flxIntersecMin.Clear
                        flxIntersecMin.Insert(flxIntersec)

                    Endif
                End If
            Next

            If dIntersectMin < 1e19 Then ' enconte un punto y es el mas cercano al click

                ' ahora veo cual es el lado a recortar
                ' necesito encontrar los vectores, si van en direccion contraria, es el punto a recortar
                '       P1------X--------------|----------------P2
                '            click           tijera

                v1.Add(oRecortar.p[0] - Xcorte)
                v1.Add(oRecortar.p[1] - Ycorte)       ' click - P1

                v2.Add(flxIntersecMin[0] - Xcorte)       ' cick - Tijera
                v2.Add(flxIntersecMin[1] - Ycorte)

                If Sgn(v1[0]) <> Sgn(v2[0]) Or Sgn(v1[1]) <> Sgn(v2[1]) Then ' van en sentido contrario

                    ' intercambio P1 con Tijera
                    oRecortar.p[0] = flxIntersecMin[0]
                    oRecortar.p[1] = flxIntersecMin[1]

                Else
                    ' intercambio P2 con Tijera
                    oRecortar.p[2] = flxIntersecMin[0]
                    oRecortar.p[3] = flxIntersecMin[1]

                End If
            End If

        Case "Arc", "Ellipse", "Text", "MText", "Circle"

            ' en el caso general, la tijera es un poligono y la entidad a recortar, otro
            ' yo tengo que encontrar , para cada cruce de la tijera y la entidad , la distancia (o mejor dicho recorrido)
            ' entre el cruce y el click del usuario porque eso determina la parte a recortar

            flxTijera = oTijera.Polygon
            flxObjeto = oRecortar.Polygon

            ' Paso 1: encontrar el cruce que esta mas cerca del click del user sobre la entidad a recortar
            Do
                ' arranco del segmento donde hice el click, el que busco de nuevo

                s1 = puntos.inPolySegment(flxObjeto, Xcorte, Ycorte)

                For i = 0 To flxObjeto.max Step 2
                    If puntos.IsPoligonCrossingLine.doIntersect(flxObjeto[i], flxObjeto[i])

                        ' For i = 0 To flxTijera.count - 4 Step 2
                        '     If puntos.doIntersect(oRecortar.p[0], oRecortar.p[1], oRecortar.p[2], oRecortar.p[3], flxTijera[i + 0], flxTijera[i + 1], flxTijera[i + 2], flxTijera[i + 3]) Then
                        '
                        '         ' recorto la linea con otra linea
                        '         ' obtengo el punto de interseccion
                        '         flxIntersec = puntos.lineLineIntersection([oRecortar.p[0], oRecortar.p[1]], [oRecortar.p[2], oRecortar.p[3]], [flxTijera[i + 0], flxTijera[i + 1]], [flxTijera[i + 2], flxTijera[i + 3]])
                        '
                        '         ' ahora veo cual es el lado a recortar
                        '         ' necesito encontrar los vectores, si van en direccion contraria, es el punto a recortar
                        '         '       P1------X--------------|----------------P2
                        '         '            click           tijera
                        '
                        '         v1.Add(oRecortar.p[0] - Xcorte)
                        '         v1.Add(oRecortar.p[1] - Ycorte)       ' click - P1
                        '
                        '         v2.Add(flxIntersec[0] - Xcorte)       ' cick - Tijera
                        '         v2.Add(flxIntersec[1] - Ycorte)
                        '
                        '         If Sgn(v1[0]) <> Sgn(v2[0]) Or Sgn(v1[1]) <> Sgn(v2[1]) Then ' van en sentido contrario
                        '
                        '             ' intercambio P1 con Tijera
                        '             oRecortar.p[0] = flxIntersec[0]
                        '             oRecortar.p[1] = flxIntersec[1]
                        '
                        '         Else
                        '             ' intercambio P2 con Tijera
                        '             oRecortar.p[2] = flxIntersec[0]
                        '             oRecortar.p[3] = flxIntersec[1]
                        '
                        '         End If

                    Endif
                Next

            Loop
    End Select

End

Public Sub Finish()

    modCAD.clsJobPrevious = Me
    modCAD.clsJob = clsDefaultJob
    clsDrawingAids.CleanTexts
    clsEntities.DeSelection()
    appmain.hFCAD.Regen
    Me.Active = False
    modCAD.ToolActive = False

End
