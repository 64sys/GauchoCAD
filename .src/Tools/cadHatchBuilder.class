' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Martin Belmonte
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Inherits ToolsBase
Public Const Gender As String = "Hatchs"

Public StepsDone As Integer

Public UserResponse As Integer  ' 1 = Cancel ; 2 =
Public entHatch As Entity
Public Xmenor As Float = 1e10
Public Ymenor As Float = 1e10
Public Xmayor As Float = -1e10
Public Ymayor As Float = -1e10

Public polyHatchFinal As Polygon
Public polyEntity As Polygon

Public Function Start(Optional filename As Variant, Optional _mode As Integer = 0) As Boolean

  Dim xf As String[]
  Dim f As String
  Dim iREt, nsel As Integer

  ' desde el grafico entramos siempre a esta parte de la clase
  ' yo tengo q saber el estado de la comunicacion con el user
  ' entonces verifico

  Select Case StepsDone
    Case 0 ' nuevo hatch

      iRet = FHatch.Showmodal()

      Debug gcd.CurrentDrawing.LastHatchFile

      Select Case iRet
        Case 2 ' busqueda de contorno
          gcd.clsJobPrevious = Me
          gcd.clsJob = clsDefaultJob
          StepsDone = 1 ' cuando vuelvo aca, ya tengo un contorno

        Case 1 ' el user cancelo el hetch
          gcd.clsJobPrevious = Me
          gcd.clsJob = clsDefaultJob
          StepsDone = 0 ' cuando vuelvo aca, empiezo de nuevo

      End Select

    Case 1 ' vengo de seleccionar los parametros de hatch

      nSel = clsEntities.GetSelectionCount()
      If nsel = 0 Then Return
      If (gcd.CurrentDrawing.oEntities[gcd.CurrentDrawing.arrSelecIndex[0]].Gender <> "LWPolyline") And (gcd.CurrentDrawing.oEntities[gcd.CurrentDrawing.arrSelecIndex[0]].PolyLine.Count < 6) Then
        Message("El contorno esta mal definido")

      Else
        StepsDone = 2
        iRet = FHatch.Showmodal()

        Debug gcd.CurrentDrawing.LastHatchFile

        Select Case iRet
          Case 2 ' nueva busqueda de contorno
            gcd.clsJobPrevious = Me
            gcd.clsJob = clsDefaultJob
            StepsDone = 1 ' cuando vuelvo aca, ya tengo un contorno

          Case 1 ' el user cancelo el hetch
            gcd.clsJobPrevious = Me
            gcd.clsJob = clsDefaultJob
            StepsDone = 0 ' cuando vuelvo aca, empiezo de nuevo

          Case 3 ' confirma el Hatch

            entHatch = New Entity
            entHatch.Gender = "Hatch"
            entHatch.ClassHandler = cadHatch

            entHatch.StringData[cadHatch.sdaPattern] = gcd.CurrentDrawing.LastHatchPattern
            entHatch.StringData[cadHatch.sdaPaternFile] = gcd.CurrentDrawing.LastHatchFile

            entHatch.fParam[cadHatch.ipaScale] = gcd.CurrentDrawing.LastScale
            entHatch.fParam[cadHatch.ipaRotation] = gcd.CurrentDrawing.LastAngle

            entHatch.pLayer = gcd.CurrentDrawing.CurrLayer ' "0" 'gcd.GetpLayer(fMain.CurrentLayer)

            entHatch.colour = gcd.CurrentDrawing.CurrColor
            entHatch.ColorToPaint = gcd.gColor[entHatch.colour]

            If gcd.CurrentDrawing.oEntities[gcd.CurrentDrawing.arrSelecIndex[0]].Gender <> "LWPolyline" Then
              If gcd.CurrentDrawing.oEntities[gcd.CurrentDrawing.arrSelecIndex[0]].PolyLine.Count >= 6 Then
                entHatch.P.Insert(gcd.CurrentDrawing.oEntities[gcd.CurrentDrawing.arrSelecIndex[0]].PolyLine.Copy())
              Endif

            Else

              entHatch.P.Insert(gcd.CurrentDrawing.oEntities[gcd.CurrentDrawing.arrSelecIndex[0]].p.Copy())

            Endif

            gcd.CurrentDrawing.oEntities.Add(entHatch)

            entHatch.ClassHandler.Finish(entHatch, entHatch.ClassHandler.StepsDone)

            'LastEntity = entHatch                                       ' save it to repeat on rigth click

            gcd.clsJobPrevious = Me
            gcd.clsJob = clsDefaultJob
            clsDefaultJob.PoiChecking = True
            DrawingAids.CleanTexts

            clsEntities.GLGenDrawList

            gcd.Redraw

        End Select

      Endif

  End Select

End

Public Sub FillEntityWithHatch(entToFill As Entity)

  ' Parametros de la entidad:

  ' P[]:        son los puntos de la polilinea que define el contorno del sombreado
  ' fParam[0]:  escala del sombreado
  ' fParam[1]:  angulo
  ' StringData[0]: nombre del patron del sombreado

  Dim e As Entity
  Dim fPAtternSide As Float
  Dim iPatternNx, iPatternNy As Integer
  Dim nx As Integer
  Dim ny As Integer
  Dim ie As Integer
  Dim flxPatternLimits As Float[]
  Dim iLoop As Integer
  Dim enxPattern As New Collection
  Dim cPattern As New Collection
  Dim enxPatternScaled As New Collection
  Dim eBorder As Entity
  Dim sPAtternFile As String

  ' este valor intenta commpensar un problema de compatibilidad entre DWG y DXF
  ' para estar de acuerdo a LibreCAD, debe ser =1, pero algunos DWG se represetan
  ' con una densidad de relleno menor (mas disperso el relleno)
  Dim CorrectionScale As Float = 1 '0.01 ' 0.1

  sPAtternFile = entToFill.StringData[cadHatch.sdaPaternFile]

  ' verifico si tengo el pattern
  If Not Exist(sPAtternFile) Then ' lo reemplazo

    sPAtternFile = Application.Path &/ "patterns" &/ "ansi31.dxf"

  End If

  ' cargo el sombreado en un array auxiliar
  Dxf.LoadFile(sPAtternFile, cPattern, True, True, True) ' lo cargo
  gcd.ImpEnty6(cPattern["ENTITIES"], enxPattern, True)

  ' necesito saber cuanto mide el contorno para aplicar la escala y multiplicar hasta cubrir todo el contorno

  flxPatternLimits = clsEntities.ComputeLimits(enxPattern)

  ' los patrones son cuadrados, computo el lado
  fPatternSide = 100 ' flxPatternLimits[2] - flxPatternLimits[0]

  If entToFill.fParam[cadHatch.ipaScale] = 0 Then entToFill.fParam[cadHatch.ipaScale] = 1

  For iLoop = 0 To entToFill.fParam[cadHatch.ipaTotalLoops] - 1

    MakeBorder(entToFill, iLoop)

    Xmenor = 1e10
    Ymenor = 1e10
    Xmayor = -1e10
    Ymayor = -1e10

    GetBoundLimits(entToFill)    ' veo los limites del contorno

    ' este borde es nulo
    If entToFill.P.Count < 6 Then Continue

    ' vamos a mentir un poco
    ' xmenor -= 1
    ' ymenor -= 1
    ' Xmayor += 1
    ' ymayor += 1

    ' calculo cuantos patrones necesito
    iPatternNx = (Xmayor - Xmenor) / fPAtternSide / entToFill.fParam[cadHatch.ipaScale] / CorrectionScale + 1
    iPatternNy = (ymayor - ymenor) / fPAtternSide / entToFill.fParam[cadHatch.ipaScale] / CorrectionScale + 1

    ' creo un array para el sombreado total  <---No mas

    ' Muevo el pattern y filtro

    For nx = 0 To iPatternNx - 1
      For ny = 0 To iPatternNy - 1
        For Each e In enxPattern

          e.ClassHandler.scale(e, entToFill.fParam[cadHatch.ipaScale] * CorrectionScale, entToFill.fParam[cadHatch.ipaScale] * CorrectionScale)

          e.ClassHandler.translate(e, nx * fPAtternSide * entToFill.fParam[cadHatch.ipaScale] * CorrectionScale + Xmenor, ny * fPAtternSide * entToFill.fParam[cadHatch.ipaScale] * CorrectionScale + ymenor)

          ' ahora lo dibujo
          ' ahora tengo que filtrar las entidades que quedan fuera del contorno y generar lineas sueltas que forman
          ' el sombreado (por ahora seran solo lineas)
          ' esas lineas las acumulo en un array

          Select Case e.Gender
            Case "Line", "LWPolyline"
              entToFill.PolyLine.Insert(puntos.PolyPolyIntersection(e.p, entToFill.p))

              ' this is test to see if the pattern is made correctly
              'entToFill.PolyLine.Insert(e.p.Copy())

            Case "Circle", "Arc", "Ellipse"
              ' estas entidades deben dibujarse primero
              e.ClassHandler.MakePolyline(e, 6)
              entToFill.PolyLine.Insert(puntos.PolyPolyIntersection(e.PolyLine, entToFill.p))
          End Select

          ' Vuelvo a la posicion original

          e.ClassHandler.translate(e, -(nx * fPAtternSide * entToFill.fParam[cadHatch.ipaScale] * CorrectionScale + Xmenor), -(ny * fPAtternSide * entToFill.fParam[cadHatch.ipaScale] * CorrectionScale + ymenor))

          e.ClassHandler.scale(e, 1 / entToFill.fParam[cadHatch.ipaScale] * CorrectionScale, 1 / entToFill.fParam[cadHatch.ipaScale] * CorrectionScale)

        Next

      Next
    Next

  Next

End

Public Sub MakeBorder(entToFill As Entity, iLoopNumber As Integer)

  Dim eBorder, eFind As Entity
  ' armo ese contorno
  entToFill.P.Clear

  For Each eBorder In entToFill.pBlock.entities
    If eborder.Group = iLoopNumber Then
      If eBorder.Gender = "" Then ' es una entdidad contorno, la busco
        eFind = gcd.FindEntity(eborder.Handle, True)
        If IsNull(eFind) Then
          Continue
          'Stop

        Else
          eborder = eFind
        End If
      End If
      Select Case eBorder.ClassHandler.Gender

        Case cadLWPolyline.Gender
          entToFill.P.Insert(eborder.P.Copy())
          If eborder.iParam[cadLWPolyline.iiiPolylineClosed] Then ' agrego el punto inicial
            entToFill.P.Insert(eborder.P.Copy(0, 2))
          Endif
        Case "Arc", "Circle", "Ellipse", "SPLine"
          ' FIXME: puede haber entidades como Text como bordes
          Try eBorder.ClassHandler.MakePolyline(eborder)
          entToFill.P.Insert(eborder.PolyLine.Copy())

        Case "Text", "MText"
          ' FIXME: puede haber entidades como Text como bordes

          entToFill.P.Insert(eborder.Polygon.Copy())
        Case "Line"
          entToFill.P.Insert(eborder.P.Copy(2, 2))
          ' entToFill.P.Insert(eborder.P.Copy())
      End Select
    End If
  Next

End

Public Sub GetBoundLimits(e As Entity)

  Dim i As Integer

  For i = 0 To e.p.max Step 2

    If e.p[i] < Xmenor Then Xmenor = e.p[i]

    If e.p[i + 1] < Ymenor Then Ymenor = e.p[i + 1]

    If e.p[i] > Xmayor Then Xmayor = e.p[i]

    If e.p[i + 1] > Ymayor Then Ymayor = e.p[i + 1]

  Next

End

Public Function ConformPolygon() As Boolean ' True = contorno bien definido

  ' formo el poligono que seria la interseccion de todos los pasados como parametro
  'gcd.CurrDrawing.arrSelecIndex

End
