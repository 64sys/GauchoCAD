' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

' Tool maintained by Terco

' Some of this gotten from
' http://www.dcs.gla.ac.uk/~pat/52233/slides/Geometry1x1.pdf

' Tools helpers

' Operations on the element's vertices

Create Static
Create Private
Fast Unsafe
Public HookSize As Integer = 16                       ' for use with poi
Public NumericTolerance As Float = 1e-7
Public GridSpacing As Float = 0.5
Public GridActive As Boolean           ' use with F7: 0 = no grid, 1 = dots, 2 = lines

'' Returns the index in the array of pairs that is near the given point using HookSize parameter
Public Function FindPOI(xr As Float, yr As Float, arr As Float[], hook As Float) As Float[]

  Dim i As Integer

  For i = 0 To arr.Max Step 2

    If ((arr[i] - hook) < Xr And (arr[i] + hook) > Xr) Or ((arr[i] - hook) > Xr And (arr[i] + hook < Xr)) Then

      If ((arr[i + 1] - hook) < yr And (arr[i + 1] + hook) > yr) Or ((arr[i + 1] - hook) > yr And (arr[i + 1] + hook) < yr) Then

        Return [arr[i], arr[i + 1], i / 2]

      End If

    Endif

  Next

  Return [xr, yr, -1]           ' no points near

End

'' Returns the index in the array of pairs that is near the given point using HookSize parameter
Public Function FindPOILines(xreal As Float, Yreal As Float, arr As Float[], tolerance As Float) As Integer

  Dim i As Integer

  For i = 0 To arr.count - 4 Step 4
    If puntos.doIntersect(xreal - tolerance / 2, Yreal, Xreal + tolerance / 2, Yreal, arr[i + 0], arr[i + 1], arr[i + 2], arr[i + 3]) Or puntos.doIntersect(xreal, Yreal - tolerance / 2, Xreal, Yreal + tolerance / 2, arr[i + 0], arr[i + 1], arr[i + 2], arr[i + 3]) Then ' its above me

      Return i / 4
    End If
  Next
  Return -1

End

'' Returns the index in the array of pairs that is near the given point using HookSize parameter
Public Function FindPOIPoligon(xr As Float, yr As Float, arr As Float[], arrIndexes As Integer[], arrNElements As Integer[]) As Integer

  Dim i As Integer

  For i = 0 To arrIndexes.Max

    If isInside(arr, xr, yr, arrIndexes[i], arrNElements[i]) Then Return i

  Next

  Return -1

End

Public Function Near(xyzReal As Float) As Float
  ' return the nearest point to the grid
  ' this is a world to world points (not pixels)

  ' Example:
  ' if                    GridSpacing = 0.2
  ' we pass               xyzReal = 1.35
  ' function will give    NearReal = 1.40

  Dim n As Integer, r As Float

  If Not Gridactive Then Return xyzReal

  r = xyzReal / GridSpacing
  n = Int(r)
  r = r - Int(r)

  If r > 0.5 Then n += 1

  Return n * GridSpacing

End

Public Function distancia(x1 As Float, y1 As Float, x2 As Float, y2 As Float) As Float
  ' returns distance between points

  Return ((x2 - x1) ^ 2 + (y2 - y1) ^ 2) ^ 0.5

End

Public Function InBetween(x As Float, x1 As Float, x2 As Float) As Boolean
  ' determine if a number is between the other two
  ' this is valid for negative values

  If (x1 <= X And x2 >= X) Or (x1 >= X And x2 <= X) Then Return True Else Return False

End

'' Devuelve el segmento en el que esta el punto, considerando la tolerancia numerica
'' o -1 si no estan en ningun segmento. Si el punto esta en un vertice, devuelve el primer segmento.
Public Function inPolySegment(poligon As Float[], px As Float, py As Float, Optional Tolerance As Float = 0) As Integer

  Dim i As Integer

  If tolerance = 0 Then tolerance = NumericTolerance

  For i = 0 To poligon.Count - 4 Step 2

    If PointToLineDistance([px, py], poligon.Copy(i, 4)) <= tolerance Then Return (i + 2) / 2

  Next

  Return -1

End

'' determines if a XZ point is in the area of other by proximity parameter
'' this is valid for negative values
'' Float version
Public Function Around(p1x As Float, p1z As Float, p2x As Float, p2z As Float, prox As Float) As Boolean

  ' determines if a XZ point is in the area of other by proximity parameter
  ' this is valid for negative values

  If InBetween(p1x, p2x - prox, p2x + prox) And InBetween(p1z, p2z - prox, p2z + prox) Then Return True Else Return False

End

Public Function doIntersect(p1x As Float, p1y As Float, q1x As Float, q1y As Float, p2x As Float, p2y As Float, q2x As Float, q2y As Float) As Boolean

  Dim o1, o2, o3, o4 As Integer
  ' Find the four orientations needed For
  ' general And special cases
  o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y)
  o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y)
  o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y)
  o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y)

  ' General Case
  If (o1 <> o2 And o3 <> o4) Then
    Return True
  Endif

  ' Special Cases
  ' p1x , p1y, q1x ,q1y And p2x , p2y are colinear And
  ' p2x , p2y lies On segment p1x , p1yq1x ,q1y
  If (o1 = 0 And onSegment(p1x, p1y, p2x, p2y, q1x, q1y)) Then
    Return True
  Endif

  ' p1x , p1y, q1x ,q1y And p2x , p2y are colinear And
  ' q2x ,q2y lies On segment p1x , p1yq1x ,q1y
  If (o2 = 0 And onSegment(p1x, p1y, q2x, q2y, q1x, q1y)) Then
    Return True
  Endif

  ' p2x , p2y, q2x ,q2y And p1x , p1y are colinear And
  ' p1x , p1y lies On segment p2x , p2yq2x ,q2y
  If (o3 = 0 And onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) Then
    Return True
  Endif

  ' p2x , p2y, q2x ,q2y And q1x ,q1y are colinear And
  ' q1x ,q1y lies On segment p2x , p2yq2x ,q2y
  If (o4 = 0 And onSegment(p2x, p2y, q1x, q1y, q2x, q2y)) Then
    Return True
  Endif

  ' Doesn 't fall in any of the above cases
  Return False

End

' To find orientation Of ordered triplet(p, q, r).
' The function returns following values
' 0 - - > p, q And r are colinear
' 2 - - > Clockwise                     WATCH OUT: WE ARE USING AND INVERTED Y AXIS, SO THIS WILL RETURN 2 to clockwise
' 1 - - > Counterclockwise              functions on the internet are the other way
Public Function orientation(px As Float, py As Float, qx As Float, qy As Float, rx As Float, ry As Float) As Integer

  Dim v As Float

  v = (qy - py) * (rx - qx) - (qx - px) * (ry - qy)
  'Print v
  '

  If (v = 0) Then Return 0 ' colinear

  If (v > 0) Then Return 2

  If (v < 0) Then Return 1

End

' Given three colinear points p, q, r,
' the function checks If point q lies
' On Line segment 'pr'
Public Function onSegment(px As Float, py As Float, qx As Float, qy As Float, rx As Float, ry As Float) As Boolean

  If (qx <= Max(px, rx) And
      qx >= Min(px, rx) And
      qy <= Max(py, ry) And
      qy >= Min(py, ry)) Then
    Return True
  Endif

  Return False

End

' Returns True If the point p lies
' inside the polygon[] With n vertices
Public Function isInside(polygon As Float[], px As Float, py As Float, Optional StartIndex As Integer = 0, Vertices As Integer = 0) As Boolean

  ' There must be at least 3 vertices In polygon[]
  If vertices = 0 Then vertices = polygon.Count / 2

  If (Vertices < 3) Then
    Return False
  Endif

  ' Create a point For Line segment From p To infinite
  Dim extremeX, extremeY As Float   '= New Point(INF, p.y)

  extremeX = 10E10
  extremeY = py

  ' Count intersections Of the above Line
  ' With sides Of polygon
  Dim count As Integer = 0, i As Integer = 0
  Dim next1 As Integer
  For i = StartIndex To vertices * 2 - 1 Step 2

    Next1 = i + 2
    If i = polygon.max - 1 Then next1 = 0

    ' Check If the Line segment From 'p' to
    ' 'extreme' intersects with the line
    ' segment From 'polygon[i]' to 'polygon[next]'

    If (doIntersect(polygon[i], polygon[i + 1], polygon[Next1], polygon[Next1 + 1], px, py, extremeX, extremeY)) Then
      ' If the point 'p' is colinear with line
      ' segment 'i-next', then check if it lies
      ' On segment.If it lies, Return True, otherwise False

      If (orientation(polygon[i], polygon[i + 1], px, py, polygon[Next1], polygon[next1 + 1]) = 0) Then

        Return onSegment(polygon[i], polygon[i + 1], px, py, polygon[Next1], polygon[next1 + 1])

      Endif

      Inc count

    Endif

  Next

  ' Return True If count Is Odd, False otherwise
  Return (count Mod 2 = 1) ' Same As (count % 2 = 1)

End

Public Function RotateFromPointWithAngle(CenterX As Float, CenterZ As Float, angle As Float, Px As Float, Pz As Float) As Float[]

  Dim s, c, xnew, ynew As Float

  s = Sin(angle)
  c = Cos(angle)

  ' translate point back To origin:
  px -= CenterX
  pz -= CenterZ

  ' rotate point
  xnew = px * c - pz * s
  ynew = px * s + pz * c

  ' translate point back:
  px = xnew + CenterX
  pz = ynew + CenterZ

  Return [px, pz]

End

Public Function RotateWithSinCos(Px As Float, Pz As Float, S As Float, C As Float) As Float[]

  Dim xnew, ynew As Float

  ' translate point back To origin:

  ' rotate point
  xnew = px * c - pz * s
  ynew = px * s + pz * c

  Return [xnew, ynew]

End

Public Function RotateFromPointWithSinCos(CenterX As Float, CenterZ As Float, S As Float, C As Float, Px As Float, Pz As Float) As Float[]

  Dim xnew, ynew As Float

  ' translate point back To origin:
  px -= CenterX
  pz -= CenterZ

  ' rotate point
  xnew = px * c - pz * s
  ynew = px * s + pz * c

  ' translate point back:
  px = xnew + CenterX
  pz = ynew + CenterZ

  Return [px, pz]

End

Public Function lineLineIntersection(A As Float[], B As Float[], C As Float[], D As Float[]) As Float[]

  '     / / Line AB represented As A1x + b1y = c1
  Dim a1 As Float = B[1] - A[1]
  Dim b1 As Float = A[0] - B[0]
  Dim c1 As Float = a1 * (A[0]) + b1 * (A[1])
  '
  '     / / Line CD represented As A2x + b2y = c2
  Dim a2 As Float = D[1] - C[1]
  Dim b2 As Float = C[0] - D[0]
  Dim c2 As Float = a2 * (C[0]) + b2 * (C[1])
  '
  Dim determinant As Float = a1 * b2 - a2 * b1
  '
  If (determinant = 0) Then
    '
    '         / / The lines are parallel.This Is Simplified
    '         / / by returning a pair Of FLT_MAX
    Return A
    '
  Else
    '
    Dim x As Float = (b2 * c1 - b1 * c2) / determinant
    Dim y As Float = (a1 * c2 - a2 * c1) / determinant
    Return [x, y]
  End If

End
'' Devuelve la interseccion de A-B con D-C

Public Function lineLineIntersection2(Ax As Float, Ay As Float, Bx As Float, By As Float, Cx As Float, Cy As Float, Dx As Float, Dy As Float) As Float[]

  '     / / Line AB represented As A1x + b1y = c1
  Dim a1 As Float = By - Ay
  Dim b1 As Float = Ax - Bx
  Dim c1 As Float = a1 * (Ax) + b1 * (Ay)
  '
  '     / / Line CD represented As A2x + b2y = c2
  Dim a2 As Float = Dy - Cy
  Dim b2 As Float = Cx - Dx
  Dim c2 As Float = a2 * (Cx) + b2 * (Cy)
  '
  Dim determinant As Float = a1 * b2 - a2 * b1
  '
  If (determinant = 0) Then
    '
    '         / / The lines are parallel.This Is Simplified
    '         / / by returning a pair Of FLT_MAX
    Return [Ax, Ay]
    '
  Else
    '
    Dim x As Float = (b2 * c1 - b1 * c2) / determinant
    Dim y As Float = (a1 * c2 - a2 * c1) / determinant
    Return [x, y]
  End If

End

' Devuelve un conjunto de lineas que representan la interseccion de una linea con una polilinea cerrada
Public Function LinePolyIntersection(flxLine As Float[], flxPoly As Float[]) As Float[]

  ' la polylinea se considera cerrada y de mas de 3 puntos, caso contrario se devuelve la linea sin cambios
  ' la linea es de dos puntos , si esta afuera de la polilinea, se devuelve un array vacio
  ' Chequeos previos:
  Dim FirstInside As Boolean
  Dim LastInside As Boolean
  Dim i As Integer
  Dim flxRta As New Float[]

  If flxLine.Count <> 4 Then Return []

  If flxPoly.Count < 6 Then Return flxLine.Copy()

  ' fuera de los casos triviales, entonces armo el array de intersecciones
  Dim flxIntersections As New Float[]

  ' determino si el primer punto esta dentro de la poly
  If puntos.isInside(flxPoly, flxLine[0], flxLine[1]) Then FirstInside = True

  ' y el ultimo
  If puntos.isInside(flxPoly, flxLine[2], flxLine[3]) Then LastInside = True

  ' busco todas las intersecciones de la linea con la polilinea
  For i = 0 To flxPoly.count - 4 Step 2
    If puntos.doIntersect(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[i + 0], flxPoly[i + 1], flxPoly[i + 2], flxPoly[i + 3]) Then
      flxIntersections.Insert(puntos.lineLineIntersection2(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[i + 0], flxPoly[i + 1], flxPoly[i + 2], flxPoly[i + 3]))
    Endif
  Next
  ' ' y el cierre de la poly
  ' If puntos.doIntersect(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[flxPoly.Max - 1], flxPoly[flxPoly.Max], flxPoly[0], flxPoly[1]) Then
  '   flxIntersections.Insert(puntos.lineLineIntersection2(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[flxPoly.Max - 1], flxPoly[flxPoly.Max], flxPoly[0], flxPoly[1]))
  ' Endif

  ' si el primer punto esta adentro, pero no se da el caso particular que coincide con parte de la polilinea, lo agrego

  If flxIntersections.Count > 0 Then

    If FirstInside Xor (flxLine[0] = flxIntersections[0] And flxLine[1] = flxIntersections[1]) Then
      flxRta.Insert(flxLine.Copy(0, 2))

    End If

    ' y luego agrego todas las intersecciones
    flxRta.Insert(flxIntersections.Copy())

    ' si el ultimo punto esta adentro, pero no se da el caso particular que coincide con parte de la polilinea, lo agrego
    If LastInside Then
      If (flxLine[2] <> flxIntersections[flxIntersections.Max - 1]) Or (flxLine[3] <> flxIntersections[flxIntersections.Max]) Then

        flxRta.Insert(flxLine.Copy(2, 2))
      End If
    End If

  Else

    If FirstInside Then flxRta.Insert(flxLine.Copy(0, 2))
    If LastInside Then flxRta.Insert(flxLine.Copy(2, 2))

  End If

  If flxRta.Count = 6 Then Return []
  If flxRta.Count = 2 Then Return []

  Return flxRta

End

' devuelve un conjunto de lineas que representan la interseccion de dos polilineas, la primera
' es abierta; la segunda, cerrada
Public Function PolyPolyIntersection(flxPolyOpen As Float[], flxPolyClosed As Float[]) As Float[]

  Dim i As Integer

  Dim flxRta As New Float[]

  For i = 0 To flxPolyOpen.Count - 4 Step 2
    flxRta.Insert(LinePolyIntersection(flxPolyOpen.Copy(i, 4), flxPolyClosed))
  Next

  Return flxRta

End

Public Function PointToLineDistance(fPoint As Float[], fLine As Float[]) As Float

  ' adaptado de
  ' https://www.mathopenref.com/coordpointdisttrig.html
  Dim E As Float[]

  Dim CE, angE As Float

  ' veo los casos mas simples

  If fLine[0] = fLine[2] Then ' la linea es vertical
    Return fLine[0] - fPoint[0]

  Else If fLine[1] = fLine[3] Then ' la linea es horizontal
    Return fLine[1] - fPoint[1]

  Endif

  e = lineLineIntersection(fPoint, [10e10, fPoint[1]], [fLine[0], fLine[1]], [fLine[2], fLine[3]])

  CE = fPoint[0] - e[0]

  angE = ATan2(fLine[3] - fLine[1], fLine[2] - fLine[0])

  ' Debug "Radio", ce
  ' Debug "angulo", angE
  ' Debug "distancia", CE * Sin(angE)
  Return CE * Sin(angE)

End

'' Returns the acute angle between two vectors
Public Function Angle(vector1 As Float[], vector2 As Float[]) As Float

  Dim alfa, beta, gamma, l As Float

  alfa = Ang(vector1[0], vector1[1])
  beta = Ang(vector2[0], vector2[1])
  gamma = beta - alfa

  If gamma < 0 Then gamma += 2 * Pi
  If gamma > Pi Then gamma -= Pi

  Return gamma

End

Public Function ReboundVector(vector As Float[], wall As Float[]) As Float[]

  Dim alfa, beta, gamma, l As Float

  alfa = Ang(vector[0], vector[1])
  beta = Ang(wall[0], wall[1])
  gamma = beta * 2 - alfa

  l = distancia(0, 0, vector[0], vector[1])
  Return [Cos(gamma) * l, Sin(gamma) * l]

End

Public Sub Normalize(v As Float[])

  Dim l As Float, i As Integer

  For i = 0 To v.Max
    l += v[i] * v[i]
  Next
  l = Sqr(l)
  For i = 0 To v.Max
    v[i] /= l
  Next

End

Public Function Dot(v1 As Float[], v2 As Float[]) As Float

  Return v1[0] * v2[0] + v1[1] * v2[1]

End

Public Function Translate(points As Float[], dx As Float, dy As Float) As Boolean

  Dim i As Integer

  For i = 0 To points.max Step 2
    points[i] += dx
    points[i + 1] += dy
  Next

End

'' Angle must be in Radians
Public Function Rotate(points As Float[], Radians As Float)

  Dim i As Integer
  Dim s, c, xnew, ynew As Float

  s = Sin(Radians)
  c = Cos(Radians)

  For i = 0 To points.max Step 2

    ' rotate point
    xnew = points[i] * c - points[i + 1] * s
    ynew = points[i] * s + points[i + 1] * c

    points[i] = xnew
    points[i + 1] = ynew
  Next

End

Public Function Scale(points As Float[], Sx As Float, Sy As Float) As Boolean

  Dim i As Integer

  For i = 0 To points.max Step 2
    points[i] *= Sx
    points[i + 1] *= Sy
  Next

End

'' Devuelve True si el poligono esta dentro del rectangulo
Public Function IsPoligonInsideRect(poligon As Float[], x0 As Float, y0 As Float, x1 As Float, y1 As Float, Optional StartIndex As Integer = 0, TotalElements As Integer = 0) As Boolean

  Dim i As Integer

  Dec TotalElements
  If totalelements < 0 Then TotalElements = poligon.Max

  For i = StartIndex To TotalElements Step 2
    If poligon[i] < x0 Then Return False
    If poligon[i] > x1 Then Return False
    If poligon[i + 1] < y0 Then Return False
    If poligon[i + 1] > y1 Then Return False
  Next
  Return True

End

'' Devuelve True si el poligono cruza la linea x0,y0 - x1,y1
Public Function IsPoligonCrossingLine(poligon As Float[], x0 As Float, y0 As Float, x1 As Float, y1 As Float, Optional StartIndex As Integer = 0, TotalElements As Integer = 0) As Boolean

  Dim i As Integer

  Dec TotalElements
  If totalelements < 0 Then TotalElements = poligon.Max

  For i = StartIndex To TotalElements - 3 Step 2
    If doIntersect(poligon[i], poligon[i + 1], poligon[i + 2], poligon[i + 3], x0, y0, x1, y1) Then Return True
  Next
  ' cierre del poligono, puntos inicial y final
  If doIntersect(poligon[StartIndex], poligon[StartIndex + 1], poligon[TotalElements - 1], poligon[TotalElements], x0, y0, x1, y1) Then Return True

  Return False

End

'' Devuelve True si el poligono cruza la linea x0,y0 - x1,y1
Public Function IsPoligonCrossingRect(poligon As Float[], x0 As Float, y0 As Float, x1 As Float, y1 As Float, Optional StartIndex As Integer = 0, TotalElements As Integer = 0) As Boolean

  Dim i As Integer

  If poligon.Count = 0 Then Return False
  If IsPoligonCrossingLine(poligon, x0, y0, x1, y0, StartIndex, TotalElements) Then Return True
  If IsPoligonCrossingLine(poligon, x0, y1, x1, y1, StartIndex, TotalElements) Then Return True
  If IsPoligonCrossingLine(poligon, x0, y0, x0, y1, StartIndex, TotalElements) Then Return True
  If IsPoligonCrossingLine(poligon, x1, y0, x1, y1, StartIndex, TotalElements) Then Return True
  Return False

End

'' Largo del poligono, o sea la suma del largo de cada tramo y, si
'' es cerrado, tambien suma del P0 al Pn
Public Function PoligonLength(points As Float[], Optional IsClosed As Boolean = True) As Float

  Dim i As Integer, l As Float

  For i = 0 To points.Count - 4 Step 2
    l += puntos.distancia(points[i], points[i + 1], points[i + 2], points[i + 3])
  Next
  If IsClosed Then l += puntos.distancia(points[0], points[1], points[points.max - 1], points[points.max])

  Return l

End

'' Area del poligono, OJO: si el poligono se cruza, esta funcion dara un resultado erroneo
Public Function PoligonArea(points As Float[]) As Float

  Dim i As Integer, area As Float

  For i = 0 To points.Count - 4 Step 2
    area += points[i] * points[i + 3] - points[i + 1] * points[i + 2]
  Next
  area += points[points.Max - 1] * points[1] - points[points.max] * points[0]

  Return Abs(area) / 2

End
